---
ms.openlocfilehash: d082393a00496b948ad4e3ff9e135d94e89d2448
ms.sourcegitcommit: 1a46441156b13db6c845f4bbb886284387d73023
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/13/2019
ms.locfileid: "67047032"
---
# <a name="conversions"></a><span data-ttu-id="3b24a-101">Conversioni</span><span class="sxs-lookup"><span data-stu-id="3b24a-101">Conversions</span></span>

<span data-ttu-id="3b24a-102">Oggetto ***conversione*** consente a un'espressione deve essere considerato in corso di un determinato tipo.</span><span class="sxs-lookup"><span data-stu-id="3b24a-102">A ***conversion*** enables an expression to be treated as being of a particular type.</span></span> <span data-ttu-id="3b24a-103">Una conversione potrebbe essere un'espressione di un determinato tipo per essere considerata come se presentasse un tipo diverso, altrimenti potrebbe verificarsi un'espressione senza un tipo da ottenere un tipo.</span><span class="sxs-lookup"><span data-stu-id="3b24a-103">A conversion may cause an expression of a given type to be treated as having a different type, or it may cause an expression without a type to get a type.</span></span> <span data-ttu-id="3b24a-104">Conversioni possono risultare ***implicita*** oppure ***esplicite***, e determina se è necessario un cast esplicito.</span><span class="sxs-lookup"><span data-stu-id="3b24a-104">Conversions can be ***implicit*** or ***explicit***, and this determines whether an explicit cast is required.</span></span> <span data-ttu-id="3b24a-105">Ad esempio, la conversione dal tipo `int` al tipo `long` è implicito, in tal caso espressioni di tipo `int` può essere gestito in modo implicito come tipo `long`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-105">For instance, the conversion from type `int` to type `long` is implicit, so expressions of type `int` can implicitly be treated as type `long`.</span></span> <span data-ttu-id="3b24a-106">La conversione dal tipo `long` al tipo `int`, è esplicito e pertanto non è richiesto un cast esplicito.</span><span class="sxs-lookup"><span data-stu-id="3b24a-106">The opposite conversion, from type `long` to type `int`, is explicit and so an explicit cast is required.</span></span>

```csharp
int a = 123;
long b = a;         // implicit conversion from int to long
int c = (int) b;    // explicit conversion from long to int
```

<span data-ttu-id="3b24a-107">Alcune conversioni sono definite dal linguaggio.</span><span class="sxs-lookup"><span data-stu-id="3b24a-107">Some conversions are defined by the language.</span></span> <span data-ttu-id="3b24a-108">I programmi possono anche definire le proprie conversioni ([conversioni definite dall'utente](conversions.md#user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-108">Programs may also define their own conversions ([User-defined conversions](conversions.md#user-defined-conversions)).</span></span>

## <a name="implicit-conversions"></a><span data-ttu-id="3b24a-109">Conversioni implicite</span><span class="sxs-lookup"><span data-stu-id="3b24a-109">Implicit conversions</span></span>

<span data-ttu-id="3b24a-110">Le conversioni seguenti sono classificate come le conversioni implicite:</span><span class="sxs-lookup"><span data-stu-id="3b24a-110">The following conversions are classified as implicit conversions:</span></span>

*  <span data-ttu-id="3b24a-111">Conversioni di identità</span><span class="sxs-lookup"><span data-stu-id="3b24a-111">Identity conversions</span></span>
*  <span data-ttu-id="3b24a-112">Conversioni numeriche implicite</span><span class="sxs-lookup"><span data-stu-id="3b24a-112">Implicit numeric conversions</span></span>
*  <span data-ttu-id="3b24a-113">Conversioni implicite di enumerazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-113">Implicit enumeration conversions.</span></span>
*  <span data-ttu-id="3b24a-114">Conversioni implicite che ammette valori null</span><span class="sxs-lookup"><span data-stu-id="3b24a-114">Implicit nullable conversions</span></span>
*  <span data-ttu-id="3b24a-115">Conversioni di valori letterali null</span><span class="sxs-lookup"><span data-stu-id="3b24a-115">Null literal conversions</span></span>
*  <span data-ttu-id="3b24a-116">Conversioni dei riferimenti impliciti</span><span class="sxs-lookup"><span data-stu-id="3b24a-116">Implicit reference conversions</span></span>
*  <span data-ttu-id="3b24a-117">Conversioni boxing</span><span class="sxs-lookup"><span data-stu-id="3b24a-117">Boxing conversions</span></span>
*  <span data-ttu-id="3b24a-118">Conversioni implicite dinamiche</span><span class="sxs-lookup"><span data-stu-id="3b24a-118">Implicit dynamic conversions</span></span>
*  <span data-ttu-id="3b24a-119">Conversioni implicite di espressioni costanti</span><span class="sxs-lookup"><span data-stu-id="3b24a-119">Implicit constant expression conversions</span></span>
*  <span data-ttu-id="3b24a-120">Conversioni implicite definite dall'utente</span><span class="sxs-lookup"><span data-stu-id="3b24a-120">User-defined implicit conversions</span></span>
*  <span data-ttu-id="3b24a-121">Conversioni delle funzioni anonime</span><span class="sxs-lookup"><span data-stu-id="3b24a-121">Anonymous function conversions</span></span>
*  <span data-ttu-id="3b24a-122">Conversioni dei metodi di gruppo</span><span class="sxs-lookup"><span data-stu-id="3b24a-122">Method group conversions</span></span>

<span data-ttu-id="3b24a-123">Le conversioni implicite possono verificarsi in diverse situazioni, tra cui le chiamate di funzione membro ([controllo della risoluzione dell'overload dinamico in fase di compilazione](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), le espressioni cast ([espressioni Cast](expressions.md#cast-expressions)), assegnazioni e ([gli operatori di assegnazione](expressions.md#assignment-operators)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-123">Implicit conversions can occur in a variety of situations, including function member invocations ([Compile-time checking of dynamic overload resolution](expressions.md#compile-time-checking-of-dynamic-overload-resolution)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), and assignments ([Assignment operators](expressions.md#assignment-operators)).</span></span>

<span data-ttu-id="3b24a-124">Le conversioni implicite predefinite hanno sempre esito positivo e non possono causare la generazione di eccezioni.</span><span class="sxs-lookup"><span data-stu-id="3b24a-124">The pre-defined implicit conversions always succeed and never cause exceptions to be thrown.</span></span> <span data-ttu-id="3b24a-125">Progettato correttamente le conversioni implicite definite dall'utente devono presentare anche queste caratteristiche.</span><span class="sxs-lookup"><span data-stu-id="3b24a-125">Properly designed user-defined implicit conversions should exhibit these characteristics as well.</span></span>

<span data-ttu-id="3b24a-126">Ai fini di conversione, i tipi `object` e `dynamic` vengono considerati equivalenti.</span><span class="sxs-lookup"><span data-stu-id="3b24a-126">For the purposes of conversion, the types `object` and `dynamic` are considered equivalent.</span></span>

<span data-ttu-id="3b24a-127">Tuttavia, conversioni dinamiche ([conversioni implicite dinamiche](conversions.md#implicit-dynamic-conversions) e [conversioni esplicite dinamiche](conversions.md#explicit-dynamic-conversions)) si applicano solo alle espressioni di tipo `dynamic` ([tipo dinamico](types.md#the-dynamic-type)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-127">However, dynamic conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)) apply only to expressions of type `dynamic` ([The dynamic type](types.md#the-dynamic-type)).</span></span>

### <a name="identity-conversion"></a><span data-ttu-id="3b24a-128">Conversione di identità</span><span class="sxs-lookup"><span data-stu-id="3b24a-128">Identity conversion</span></span>

<span data-ttu-id="3b24a-129">Una conversione di identità converte da qualsiasi tipo nello stesso tipo.</span><span class="sxs-lookup"><span data-stu-id="3b24a-129">An identity conversion converts from any type to the same type.</span></span> <span data-ttu-id="3b24a-130">Questa conversione esiste un'entità che dispone già di un tipo di richiesta si può affermare sia convertibile in quel tipo.</span><span class="sxs-lookup"><span data-stu-id="3b24a-130">This conversion exists such that an entity that already has a required type can be said to be convertible to that type.</span></span>

*  <span data-ttu-id="3b24a-131">In quanto `object` e `dynamic` sono considerati equivalenti è una conversione di identità tra `object` e `dynamic`e tra tipi costruiti che sono gli stessi durante la sostituzione di tutte le occorrenze di `dynamic` con `object`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-131">Because `object` and `dynamic` are considered equivalent there is an identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing all occurrences of `dynamic` with `object`.</span></span>

### <a name="implicit-numeric-conversions"></a><span data-ttu-id="3b24a-132">Conversioni numeriche implicite</span><span class="sxs-lookup"><span data-stu-id="3b24a-132">Implicit numeric conversions</span></span>

<span data-ttu-id="3b24a-133">Alle conversioni numeriche implicite sono:</span><span class="sxs-lookup"><span data-stu-id="3b24a-133">The implicit numeric conversions are:</span></span>

*  <span data-ttu-id="3b24a-134">Dal `sbyte` al `short`, `int`, `long`, `float`, `double`, o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-134">From `sbyte` to `short`, `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="3b24a-135">Dal `byte` al `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-135">From `byte` to `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="3b24a-136">Dal `short` al `int`, `long`, `float`, `double`, o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-136">From `short` to `int`, `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="3b24a-137">Dal `ushort` al `int`, `uint`, `long`, `ulong`, `float`, `double`, o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-137">From `ushort` to `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="3b24a-138">Dal `int` al `long`, `float`, `double`, o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-138">From `int` to `long`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="3b24a-139">Dal `uint` al `long`, `ulong`, `float`, `double`, o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-139">From `uint` to `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="3b24a-140">Dal `long` al `float`, `double`, o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-140">From `long` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="3b24a-141">Dal `ulong` al `float`, `double`, o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-141">From `ulong` to `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="3b24a-142">Dal `char` al `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-142">From `char` to `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="3b24a-143">Dal `float` a `double`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-143">From `float` to `double`.</span></span>

<span data-ttu-id="3b24a-144">Le conversioni da `int`, `uint`, `long`, o `ulong` per `float` e dal `long` oppure `ulong` per `double` potrebbe causare una perdita di precisione, ma non verrà mai causa una perdita di grandezza.</span><span class="sxs-lookup"><span data-stu-id="3b24a-144">Conversions from `int`, `uint`, `long`, or `ulong` to `float` and from `long` or `ulong` to `double` may cause a loss of precision, but will never cause a loss of magnitude.</span></span> <span data-ttu-id="3b24a-145">Le altre conversioni numeriche implicite non comportano la perdita di tutte le informazioni.</span><span class="sxs-lookup"><span data-stu-id="3b24a-145">The other implicit numeric conversions never lose any information.</span></span>

<span data-ttu-id="3b24a-146">Non sono presenti conversioni implicite per il `char` digita, in modo che i valori degli altri tipi integrali non vengono automaticamente convertiti il `char` tipo.</span><span class="sxs-lookup"><span data-stu-id="3b24a-146">There are no implicit conversions to the `char` type, so values of the other integral types do not automatically convert to the `char` type.</span></span>

### <a name="implicit-enumeration-conversions"></a><span data-ttu-id="3b24a-147">Conversioni implicite di enumerazione</span><span class="sxs-lookup"><span data-stu-id="3b24a-147">Implicit enumeration conversions</span></span>

<span data-ttu-id="3b24a-148">Una conversione implicita enumerazione consente il *decimal_integer_literal* `0` da convertire in qualsiasi *enum_type* e a qualsiasi *nullable_type* cui il tipo sottostante è un *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="3b24a-148">An implicit enumeration conversion permits the *decimal_integer_literal* `0` to be converted to any *enum_type* and to any *nullable_type* whose underlying type is an *enum_type*.</span></span> <span data-ttu-id="3b24a-149">Nel secondo caso viene valutata eseguendo la conversione a sottostante *enum_type* e il risultato di wrapping ([tipi Nullable](types.md#nullable-types)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-149">In the latter case the conversion is evaluated by converting to the underlying *enum_type* and wrapping the result ([Nullable types](types.md#nullable-types)).</span></span>

### <a name="implicit-interpolated-string-conversions"></a><span data-ttu-id="3b24a-150">Conversioni implicite stringa interpolata</span><span class="sxs-lookup"><span data-stu-id="3b24a-150">Implicit interpolated string conversions</span></span>

<span data-ttu-id="3b24a-151">Implicita interpolate consente la conversione di stringa un' *interpolated_string_expression* ([stringhe interpolate](expressions.md#interpolated-strings)) da convertire in `System.IFormattable` o `System.FormattableString` (che implementa `System.IFormattable`).</span><span class="sxs-lookup"><span data-stu-id="3b24a-151">An implicit interpolated string conversion permits an *interpolated_string_expression* ([Interpolated strings](expressions.md#interpolated-strings)) to be converted to `System.IFormattable` or `System.FormattableString` (which implements `System.IFormattable`).</span></span>

<span data-ttu-id="3b24a-152">Quando questa conversione viene applicata un valore stringa non è composto dalla stringa interpolata.</span><span class="sxs-lookup"><span data-stu-id="3b24a-152">When this conversion is applied a string value is not composed from the interpolated string.</span></span> <span data-ttu-id="3b24a-153">Invece un'istanza di `System.FormattableString` viene creata, come descritto [stringhe interpolate](expressions.md#interpolated-strings).</span><span class="sxs-lookup"><span data-stu-id="3b24a-153">Instead an instance of `System.FormattableString` is created, as further described in [Interpolated strings](expressions.md#interpolated-strings).</span></span>

### <a name="implicit-nullable-conversions"></a><span data-ttu-id="3b24a-154">Conversioni implicite che ammette valori null</span><span class="sxs-lookup"><span data-stu-id="3b24a-154">Implicit nullable conversions</span></span>

<span data-ttu-id="3b24a-155">Conversioni implicite predefinite che operano sui tipi di valore non nullable sono anche utilizzabile con le forme di tali tipi nullable.</span><span class="sxs-lookup"><span data-stu-id="3b24a-155">Predefined implicit conversions that operate on non-nullable value types can also be used with nullable forms of those types.</span></span> <span data-ttu-id="3b24a-156">Per ognuna delle identità impliciti predefiniti e conversioni numeriche che consentono di convertire da un tipo di valore non nullable `S` a un tipo di valore non nullable `T`, esistono le seguenti conversioni implicite che ammette valori null:</span><span class="sxs-lookup"><span data-stu-id="3b24a-156">For each of the predefined implicit identity and numeric conversions that convert from a non-nullable value type `S` to a non-nullable value type `T`, the following implicit nullable conversions exist:</span></span>

*  <span data-ttu-id="3b24a-157">Una conversione implicita da `S?` a `T?`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-157">An implicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="3b24a-158">Una conversione implicita da `S` a `T?`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-158">An implicit conversion from `S` to `T?`.</span></span>

<span data-ttu-id="3b24a-159">Valutazione di una conversione implicita che ammette valori null in base una conversione da sottostante `S` a `T` procede nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="3b24a-159">Evaluation of an implicit nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="3b24a-160">Se la conversione che ammette valori null dal `S?` a `T?`:</span><span class="sxs-lookup"><span data-stu-id="3b24a-160">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="3b24a-161">Se il valore di origine è null (`HasValue` proprietà è false), il risultato è il valore null di tipo `T?`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-161">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="3b24a-162">In caso contrario, la conversione viene valutata come un annullamento del wrapping da `S?` a `S`, seguita dalla conversione da sottostante `S` a `T`, seguito da un ritorno a capo ([tipi Nullable](types.md#nullable-types)) da `T` a `T?`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-162">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping ([Nullable types](types.md#nullable-types)) from `T` to `T?`.</span></span>

*  <span data-ttu-id="3b24a-163">Se la conversione che ammette valori null è da `S` al `T?`, la conversione viene valutata come la conversione da sottostante `S` a `T` seguita da un ritorno a capo da `T` per `T?`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-163">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>

### <a name="null-literal-conversions"></a><span data-ttu-id="3b24a-164">Conversioni di valori letterali null</span><span class="sxs-lookup"><span data-stu-id="3b24a-164">Null literal conversions</span></span>

<span data-ttu-id="3b24a-165">Esiste una conversione implicita dal `null` letterale a qualsiasi tipo che ammette valori null.</span><span class="sxs-lookup"><span data-stu-id="3b24a-165">An implicit conversion exists from the `null` literal to any nullable type.</span></span> <span data-ttu-id="3b24a-166">Questa conversione produce il valore null ([tipi Nullable](types.md#nullable-types)) del tipo che ammette valori null specificato.</span><span class="sxs-lookup"><span data-stu-id="3b24a-166">This conversion produces the null value ([Nullable types](types.md#nullable-types)) of the given nullable type.</span></span>

### <a name="implicit-reference-conversions"></a><span data-ttu-id="3b24a-167">Conversioni dei riferimenti impliciti</span><span class="sxs-lookup"><span data-stu-id="3b24a-167">Implicit reference conversions</span></span>

<span data-ttu-id="3b24a-168">Le conversioni di riferimenti impliciti sono:</span><span class="sxs-lookup"><span data-stu-id="3b24a-168">The implicit reference conversions are:</span></span>

*  <span data-ttu-id="3b24a-169">Da qualsiasi *reference_type* al `object` e `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-169">From any *reference_type* to `object` and `dynamic`.</span></span>
*  <span data-ttu-id="3b24a-170">Da qualsiasi *class_type* `S` a qualsiasi *class_type* `T`, fornito `S` è derivato da `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-170">From any *class_type* `S` to any *class_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="3b24a-171">Da qualsiasi *class_type* `S` a qualsiasi *interface_type* `T`, fornito `S` implementa `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-171">From any *class_type* `S` to any *interface_type* `T`, provided `S` implements `T`.</span></span>
*  <span data-ttu-id="3b24a-172">Da qualsiasi *interface_type* `S` a qualsiasi *interface_type* `T`, fornito `S` è derivato da `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-172">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is derived from `T`.</span></span>
*  <span data-ttu-id="3b24a-173">Da un *array_type* `S` con un tipo di elemento `SE` a un *array_type* `T` con un tipo di elemento `TE`, purché tutti gli elementi seguenti sono vere:</span><span class="sxs-lookup"><span data-stu-id="3b24a-173">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="3b24a-174">`S` e `T` differiscono solo nel tipo di elemento.</span><span class="sxs-lookup"><span data-stu-id="3b24a-174">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="3b24a-175">In altre parole, `S` e `T` hanno lo stesso numero di dimensioni.</span><span class="sxs-lookup"><span data-stu-id="3b24a-175">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="3b24a-176">Entrambe `SE` e `TE` vengono *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="3b24a-176">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="3b24a-177">Esiste una conversione implicita del riferimento da `SE` a `TE`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-177">An implicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="3b24a-178">Da qualsiasi *array_type* a `System.Array` e le interfacce implementate.</span><span class="sxs-lookup"><span data-stu-id="3b24a-178">From any *array_type* to `System.Array` and the interfaces it implements.</span></span>
*  <span data-ttu-id="3b24a-179">Da un tipo di matrice unidimensionale `S[]` al `System.Collections.Generic.IList<T>` e le relative interfacce di base, purché esista una conversione implicita di identità o un riferimento dal `S` a `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-179">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an implicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="3b24a-180">Da qualsiasi *delegate_type* a `System.Delegate` e le interfacce implementate.</span><span class="sxs-lookup"><span data-stu-id="3b24a-180">From any *delegate_type* to `System.Delegate` and the interfaces it implements.</span></span>
*  <span data-ttu-id="3b24a-181">Dal valore letterale null a qualsiasi *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="3b24a-181">From the null literal to any *reference_type*.</span></span>
*  <span data-ttu-id="3b24a-182">Da qualsiasi *reference_type* a un *reference_type* `T` se dispone di una conversione implicita di identità o un riferimento a un *reference_type* `T0` e `T0` dispone di una conversione di identità per `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-182">From any *reference_type* to a *reference_type* `T` if it has an implicit identity or reference conversion to a *reference_type* `T0` and `T0` has an identity conversion to `T`.</span></span>
*  <span data-ttu-id="3b24a-183">Da qualsiasi *reference_type* a un tipo interfaccia o delegato `T` se dispone di una conversione implicita di identità o un riferimento a un tipo interfaccia o delegato `T0` e `T0` è convertibile la varianza ([ La conversione della varianza](interfaces.md#variance-conversion)) a `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-183">From any *reference_type* to an interface or delegate type `T` if it has an implicit identity or reference conversion to an interface or delegate type `T0` and `T0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `T`.</span></span>
*  <span data-ttu-id="3b24a-184">Le conversioni implicite digitare i parametri sono noti come tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="3b24a-184">Implicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="3b24a-185">Visualizzare [conversioni implicite con i parametri di tipo](conversions.md#implicit-conversions-involving-type-parameters) per altre informazioni sulle conversioni implicite parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="3b24a-185">See [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) for more details on implicit conversions involving type parameters.</span></span>

<span data-ttu-id="3b24a-186">Le conversioni di riferimenti impliciti sono conversioni tra *reference_type*che hanno sempre esito positivo e pertanto non richiede alcun controllo in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-186">The implicit reference conversions are those conversions between *reference_type*s that can be proven to always succeed, and therefore require no checks at run-time.</span></span>

<span data-ttu-id="3b24a-187">Le conversioni dei riferimenti, implicite o esplicite, non modificano mai l'identità referenziale dell'oggetto da convertire.</span><span class="sxs-lookup"><span data-stu-id="3b24a-187">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="3b24a-188">In altre parole, mentre la conversione di un riferimento può modificare il tipo del riferimento, non modifica mai il tipo o il valore dell'oggetto a cui si fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="3b24a-188">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="3b24a-189">Conversioni boxing</span><span class="sxs-lookup"><span data-stu-id="3b24a-189">Boxing conversions</span></span>

<span data-ttu-id="3b24a-190">Una conversione boxing consente una *value_type* da convertire in modo implicito in un tipo di riferimento.</span><span class="sxs-lookup"><span data-stu-id="3b24a-190">A boxing conversion permits a *value_type* to be implicitly converted to a reference type.</span></span> <span data-ttu-id="3b24a-191">Esiste una conversione boxing da una qualsiasi *non_nullable_value_type* al `object` e `dynamic`, alla `System.ValueType` e a qualsiasi *interface_type* implementata dal *non_ nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="3b24a-191">A boxing conversion exists from any *non_nullable_value_type* to `object` and `dynamic`, to `System.ValueType` and to any *interface_type* implemented by the *non_nullable_value_type*.</span></span> <span data-ttu-id="3b24a-192">Inoltre un' *enum_type* può essere convertito nel tipo `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-192">Furthermore an *enum_type* can be converted to the type `System.Enum`.</span></span>

<span data-ttu-id="3b24a-193">Esiste una conversione boxing da una *nullable_type* a un tipo riferimento, se e solo se la conversione boxing esiste da sottostante *non_nullable_value_type* al tipo di riferimento.</span><span class="sxs-lookup"><span data-stu-id="3b24a-193">A boxing conversion exists from a *nullable_type* to a reference type, if and only if a boxing conversion exists from the underlying *non_nullable_value_type* to the reference type.</span></span>

<span data-ttu-id="3b24a-194">Un tipo di valore ha una conversione boxing in un tipo di interfaccia `I` se è presente una conversione boxing di un tipo di interfaccia `I0` e `I0` dispone di una conversione di identità per `I`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-194">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="3b24a-195">Un tipo di valore ha una conversione boxing in un tipo di interfaccia `I` se è presente una conversione boxing di un tipo interfaccia o delegato `I0` e `I0` è convertibile la varianza ([conversione della varianza](interfaces.md#variance-conversion)) al `I`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-195">A value type has a boxing conversion to an interface type `I` if it has a boxing conversion to an interface or delegate type `I0` and `I0` is variance-convertible ([Variance conversion](interfaces.md#variance-conversion)) to `I`.</span></span>

<span data-ttu-id="3b24a-196">Conversione boxing di un valore di una *non_nullable_value_type* consiste nell'allocare un'istanza dell'oggetto e copia le *value_type* valore in tale istanza.</span><span class="sxs-lookup"><span data-stu-id="3b24a-196">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *value_type* value into that instance.</span></span> <span data-ttu-id="3b24a-197">Uno struct può essere sottoposto a boxing per il tipo `System.ValueType`, dal momento che è una classe base per tutti gli struct ([ereditarietà](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-197">A struct can be boxed to the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="3b24a-198">Conversione boxing di un valore di una *nullable_type* procede nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="3b24a-198">Boxing a value of a *nullable_type* proceeds as follows:</span></span>

*  <span data-ttu-id="3b24a-199">Se il valore di origine è null (`HasValue` proprietà è false), il risultato è un riferimento null del tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-199">If the source value is null (`HasValue` property is false), the result is a null reference of the target type.</span></span>
*  <span data-ttu-id="3b24a-200">In caso contrario, il risultato è un riferimento a boxed `T` prodotti dalla rimozione del wrapping e il boxing del valore di origine.</span><span class="sxs-lookup"><span data-stu-id="3b24a-200">Otherwise, the result is a reference to a boxed `T` produced by unwrapping and boxing the source value.</span></span>

<span data-ttu-id="3b24a-201">Le conversioni boxing ulteriori informazioni sono vedere [conversioni Boxing](types.md#boxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="3b24a-201">Boxing conversions are described further in [Boxing conversions](types.md#boxing-conversions).</span></span>

### <a name="implicit-dynamic-conversions"></a><span data-ttu-id="3b24a-202">Conversioni implicite dinamiche</span><span class="sxs-lookup"><span data-stu-id="3b24a-202">Implicit dynamic conversions</span></span>

<span data-ttu-id="3b24a-203">Non esiste una conversione implicita dinamica da un'espressione di tipo `dynamic` a qualsiasi tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-203">An implicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="3b24a-204">La conversione in modo dinamico è associata ([binding dinamico](expressions.md#dynamic-binding)), il che significa che una conversione implicita verrà cercata in fase di esecuzione dal tipo di fase di esecuzione dell'espressione a `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-204">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an implicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="3b24a-205">Se non viene trovata alcuna conversione, viene generata un'eccezione in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-205">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="3b24a-206">Si noti che la conversione implicita apparentemente viola il Consiglio all'inizio della [conversioni implicite](conversions.md#implicit-conversions) che una conversione implicita non dovrebbe mai provocare un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-206">Note that this implicit conversion seemingly violates the advice in the beginning of [Implicit conversions](conversions.md#implicit-conversions) that an implicit conversion should never cause an exception.</span></span> <span data-ttu-id="3b24a-207">Tuttavia, non l'operazione di conversione, ma il *ricerca* della conversione che causa l'eccezione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-207">However it is not the conversion itself, but the *finding* of the conversion that causes the exception.</span></span> <span data-ttu-id="3b24a-208">Il rischio di eccezioni di run-time è dovuto all'uso dell'associazione dinamica.</span><span class="sxs-lookup"><span data-stu-id="3b24a-208">The risk of run-time exceptions is inherent in the use of dynamic binding.</span></span> <span data-ttu-id="3b24a-209">Se non si desidera l'associazione dinamica della conversione, l'espressione può essere convertita prima di tutto a `object`e quindi al tipo desiderato.</span><span class="sxs-lookup"><span data-stu-id="3b24a-209">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="3b24a-210">L'esempio seguente illustra le conversioni implicite di dinamiche:</span><span class="sxs-lookup"><span data-stu-id="3b24a-210">The following example illustrates implicit dynamic conversions:</span></span>

```csharp
object o  = "object"
dynamic d = "dynamic";

string s1 = o; // Fails at compile-time -- no conversion exists
string s2 = d; // Compiles and succeeds at run-time
int i     = d; // Compiles but fails at run-time -- no conversion exists
```

<span data-ttu-id="3b24a-211">Le assegnazioni per `s2` e `i` entrambi impiegare le conversioni implicite dinamiche, in cui l'associazione delle operazioni viene sospesa fino alla fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-211">The assignments to `s2` and `i` both employ implicit dynamic conversions, where the binding of the operations is suspended until run-time.</span></span> <span data-ttu-id="3b24a-212">In fase di esecuzione, vengono richieste le conversioni implicite dal tipo di runtime del `d`  --  `string` : il tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-212">At run-time, implicit conversions are sought from the run-time type of `d` -- `string` -- to the target type.</span></span> <span data-ttu-id="3b24a-213">Viene rilevata che una conversione `string` ma non al `int`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-213">A conversion is found to `string` but not to `int`.</span></span>

### <a name="implicit-constant-expression-conversions"></a><span data-ttu-id="3b24a-214">Conversioni implicite di espressioni costanti</span><span class="sxs-lookup"><span data-stu-id="3b24a-214">Implicit constant expression conversions</span></span>

<span data-ttu-id="3b24a-215">Una conversione implicita espressione costante consente le conversioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="3b24a-215">An implicit constant expression conversion permits the following conversions:</span></span>

*  <span data-ttu-id="3b24a-216">Oggetto *constant_expression* ([espressioni costanti](expressions.md#constant-expressions)) di tipo `int` può essere convertito nel tipo `sbyte`, `byte`, `short`, `ushort`, `uint`, oppure `ulong`, ha fornito il valore della *constant_expression* è compreso nell'intervallo del tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-216">A *constant_expression* ([Constant expressions](expressions.md#constant-expressions)) of type `int` can be converted to type `sbyte`, `byte`, `short`, `ushort`, `uint`, or `ulong`, provided the value of the *constant_expression* is within the range of the destination type.</span></span>
*  <span data-ttu-id="3b24a-217">Oggetto *constant_expression* typu `long` può essere convertito nel tipo `ulong`, fornito il valore del *constant_expression* non sia negativa.</span><span class="sxs-lookup"><span data-stu-id="3b24a-217">A *constant_expression* of type `long` can be converted to type `ulong`, provided the value of the *constant_expression* is not negative.</span></span>

### <a name="implicit-conversions-involving-type-parameters"></a><span data-ttu-id="3b24a-218">Conversioni implicite con i parametri di tipo</span><span class="sxs-lookup"><span data-stu-id="3b24a-218">Implicit conversions involving type parameters</span></span>

<span data-ttu-id="3b24a-219">Per un parametro di tipo specificato esistono le seguenti conversioni implicite `T`:</span><span class="sxs-lookup"><span data-stu-id="3b24a-219">The following implicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="3b24a-220">Dal `T` alla classe di base efficace `C`, da `T` per qualsiasi classe di base di `C`e da `T` a qualsiasi interfaccia implementata da `C`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-220">From `T` to its effective base class `C`, from `T` to any base class of `C`, and from `T` to any interface implemented by `C`.</span></span> <span data-ttu-id="3b24a-221">Se in fase di esecuzione, at `T` è un tipo di valore, la conversione viene eseguita la conversione boxing.</span><span class="sxs-lookup"><span data-stu-id="3b24a-221">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="3b24a-222">In caso contrario, la conversione viene eseguita come una conversione implicita del riferimento o conversione di identità.</span><span class="sxs-lookup"><span data-stu-id="3b24a-222">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="3b24a-223">Dal `T` a un tipo di interfaccia `I` nel `T`efficace interfaccia set e da `T` per qualsiasi interfaccia di base di `I`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-223">From `T` to an interface type `I` in `T`'s effective interface set and from `T` to any base interface of `I`.</span></span> <span data-ttu-id="3b24a-224">Se in fase di esecuzione, at `T` è un tipo di valore, la conversione viene eseguita la conversione boxing.</span><span class="sxs-lookup"><span data-stu-id="3b24a-224">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="3b24a-225">In caso contrario, la conversione viene eseguita come una conversione implicita del riferimento o conversione di identità.</span><span class="sxs-lookup"><span data-stu-id="3b24a-225">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="3b24a-226">Dal `T` a un parametro di tipo `U`, specificato `T` dipende `U` ([digitare i vincoli del parametro](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-226">From `T` to a type parameter `U`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="3b24a-227">Se in fase di esecuzione, at `U` è un tipo di valore, quindi `T` e `U` sono necessariamente dello stesso tipo e viene eseguita alcuna conversione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-227">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="3b24a-228">In caso contrario, se `T` è un tipo di valore, la conversione viene eseguita la conversione boxing.</span><span class="sxs-lookup"><span data-stu-id="3b24a-228">Otherwise, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="3b24a-229">In caso contrario, la conversione viene eseguita come una conversione implicita del riferimento o conversione di identità.</span><span class="sxs-lookup"><span data-stu-id="3b24a-229">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="3b24a-230">Dal valore letterale null per `T`, fornito `T` è noto come tipo di riferimento.</span><span class="sxs-lookup"><span data-stu-id="3b24a-230">From the null literal to `T`, provided `T` is known to be a reference type.</span></span>
*  <span data-ttu-id="3b24a-231">Dal `T` a un tipo riferimento `I` se dispone di una conversione implicita a un tipo di riferimento `S0` e `S0` dispone di una conversione di identità per `S`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-231">From `T` to a reference type `I` if it has an implicit conversion to a reference type `S0` and `S0` has an identity conversion to `S`.</span></span> <span data-ttu-id="3b24a-232">In fase di esecuzione la conversione viene eseguita esattamente come la conversione a `S0`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-232">At run-time the conversion is executed the same way as the conversion to `S0`.</span></span>
*  <span data-ttu-id="3b24a-233">Dal `T` a un tipo di interfaccia `I` se dispone di una conversione implicita a un tipo interfaccia o delegato `I0` e `I0` è convertibile la varianza per `I` ([conversione della varianza](interfaces.md#variance-conversion) ).</span><span class="sxs-lookup"><span data-stu-id="3b24a-233">From `T` to an interface type `I` if it has an implicit conversion to an interface or delegate type `I0` and `I0` is variance-convertible to `I` ([Variance conversion](interfaces.md#variance-conversion)).</span></span> <span data-ttu-id="3b24a-234">Se in fase di esecuzione, at `T` è un tipo di valore, la conversione viene eseguita la conversione boxing.</span><span class="sxs-lookup"><span data-stu-id="3b24a-234">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion.</span></span> <span data-ttu-id="3b24a-235">In caso contrario, la conversione viene eseguita come una conversione implicita del riferimento o conversione di identità.</span><span class="sxs-lookup"><span data-stu-id="3b24a-235">Otherwise, the conversion is executed as an implicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="3b24a-236">Se `T` è noto per essere un tipo riferimento ([digitare i vincoli del parametro](classes.md#type-parameter-constraints)), tutte le conversioni sopra sono classificate come le conversioni dei riferimenti impliciti ([le conversioni dei riferimenti implicita](conversions.md#implicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-236">If `T` is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)), the conversions above are all classified as implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions)).</span></span> <span data-ttu-id="3b24a-237">Se `T` non è noto per essere un tipo riferimento, le conversioni precedenti vengono classificate come le conversioni boxing ([conversioni Boxing](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-237">If `T` is not known to be a reference type, the conversions above are classified as boxing conversions ([Boxing conversions](conversions.md#boxing-conversions)).</span></span>

### <a name="user-defined-implicit-conversions"></a><span data-ttu-id="3b24a-238">Conversioni implicite definite dall'utente</span><span class="sxs-lookup"><span data-stu-id="3b24a-238">User-defined implicit conversions</span></span>

<span data-ttu-id="3b24a-239">Una conversione implicita definito dall'utente è costituito da una conversione implicita standard facoltativa, seguita dall'esecuzione di un operatore definito dall'utente la conversione implicita, seguito da un altro facoltativa standard la conversione implicita.</span><span class="sxs-lookup"><span data-stu-id="3b24a-239">A user-defined implicit conversion consists of an optional standard implicit conversion, followed by execution of a user-defined implicit conversion operator, followed by another optional standard implicit conversion.</span></span> <span data-ttu-id="3b24a-240">Le regole precise per la valutazione delle conversioni implicite definite dall'utente sono descritti [l'elaborazione delle conversioni implicite definite dall'utente](conversions.md#processing-of-user-defined-implicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="3b24a-240">The exact rules for evaluating user-defined implicit conversions are described in [Processing of user-defined implicit conversions](conversions.md#processing-of-user-defined-implicit-conversions).</span></span>

### <a name="anonymous-function-conversions-and-method-group-conversions"></a><span data-ttu-id="3b24a-241">Le conversioni di funzione anonima e di gruppo (metodo)</span><span class="sxs-lookup"><span data-stu-id="3b24a-241">Anonymous function conversions and method group conversions</span></span>

<span data-ttu-id="3b24a-242">Funzioni anonime e i gruppi di metodi non dispongono di tipi di se stessi, ma possono essere convertiti in modo implicito in tipi delegati o tipi di albero delle espressioni.</span><span class="sxs-lookup"><span data-stu-id="3b24a-242">Anonymous functions and method groups do not have types in and of themselves, but may be implicitly converted to delegate types or expression tree types.</span></span> <span data-ttu-id="3b24a-243">Conversioni delle funzioni anonime sono descritti più dettagliatamente [conversioni delle funzioni anonime](conversions.md#anonymous-function-conversions) metodo gruppo conversioni e in [conversioni dei metodi di gruppo](conversions.md#method-group-conversions).</span><span class="sxs-lookup"><span data-stu-id="3b24a-243">Anonymous function conversions are described in more detail in [Anonymous function conversions](conversions.md#anonymous-function-conversions) and method group conversions in [Method group conversions](conversions.md#method-group-conversions).</span></span>

## <a name="explicit-conversions"></a><span data-ttu-id="3b24a-244">Conversioni esplicite</span><span class="sxs-lookup"><span data-stu-id="3b24a-244">Explicit conversions</span></span>

<span data-ttu-id="3b24a-245">Le conversioni seguenti sono classificate come le conversioni esplicite:</span><span class="sxs-lookup"><span data-stu-id="3b24a-245">The following conversions are classified as explicit conversions:</span></span>

*  <span data-ttu-id="3b24a-246">Tutte le conversioni implicite.</span><span class="sxs-lookup"><span data-stu-id="3b24a-246">All implicit conversions.</span></span>
*  <span data-ttu-id="3b24a-247">Conversioni numeriche esplicite.</span><span class="sxs-lookup"><span data-stu-id="3b24a-247">Explicit numeric conversions.</span></span>
*  <span data-ttu-id="3b24a-248">Conversioni enumerazione esplicita.</span><span class="sxs-lookup"><span data-stu-id="3b24a-248">Explicit enumeration conversions.</span></span>
*  <span data-ttu-id="3b24a-249">Conversioni esplicite che ammette valori null.</span><span class="sxs-lookup"><span data-stu-id="3b24a-249">Explicit nullable conversions.</span></span>
*  <span data-ttu-id="3b24a-250">Conversioni riferimento esplicito.</span><span class="sxs-lookup"><span data-stu-id="3b24a-250">Explicit reference conversions.</span></span>
*  <span data-ttu-id="3b24a-251">Conversioni esplicite dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="3b24a-251">Explicit interface conversions.</span></span>
*  <span data-ttu-id="3b24a-252">Conversione unboxing.</span><span class="sxs-lookup"><span data-stu-id="3b24a-252">Unboxing conversions.</span></span>
*  <span data-ttu-id="3b24a-253">Conversioni esplicite dinamiche</span><span class="sxs-lookup"><span data-stu-id="3b24a-253">Explicit dynamic conversions</span></span>
*  <span data-ttu-id="3b24a-254">Conversioni esplicite definite dall'utente.</span><span class="sxs-lookup"><span data-stu-id="3b24a-254">User-defined explicit conversions.</span></span>

<span data-ttu-id="3b24a-255">Le conversioni esplicite possono verificarsi nelle espressioni cast ([espressioni Cast](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-255">Explicit conversions can occur in cast expressions ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="3b24a-256">Il set di conversioni esplicite include tutte le conversioni implicite.</span><span class="sxs-lookup"><span data-stu-id="3b24a-256">The set of explicit conversions includes all implicit conversions.</span></span> <span data-ttu-id="3b24a-257">Ciò significa che sono consentite espressioni cast ridondanti.</span><span class="sxs-lookup"><span data-stu-id="3b24a-257">This means that redundant cast expressions are allowed.</span></span>

<span data-ttu-id="3b24a-258">Le conversioni esplicite che non sono conversioni implicite sono conversioni che non hanno sempre esito positivo, le conversioni per cui sono noti per determinare una perdita di informazioni e le conversioni tra domini di tipi diversi di merito esplicita notazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-258">The explicit conversions that are not implicit conversions are conversions that cannot be proven to always succeed, conversions that are known to possibly lose information, and conversions across domains of types sufficiently different to merit explicit notation.</span></span>

### <a name="explicit-numeric-conversions"></a><span data-ttu-id="3b24a-259">Conversioni numeriche esplicite</span><span class="sxs-lookup"><span data-stu-id="3b24a-259">Explicit numeric conversions</span></span>

<span data-ttu-id="3b24a-260">Conversioni numeriche esplicite sono riportate le conversioni da un *numeric_type* a un'altra *numeric_type* per il quale una conversione numerica implicita ([conversioni numeriche implicite](conversions.md#implicit-numeric-conversions)) non esiste già:</span><span class="sxs-lookup"><span data-stu-id="3b24a-260">The explicit numeric conversions are the conversions from a *numeric_type* to another *numeric_type* for which an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) does not already exist:</span></span>

*  <span data-ttu-id="3b24a-261">Dal `sbyte` al `byte`, `ushort`, `uint`, `ulong`, o `char`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-261">From `sbyte` to `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="3b24a-262">Dal `byte` al `sbyte` e `char`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-262">From `byte` to `sbyte` and `char`.</span></span>
*  <span data-ttu-id="3b24a-263">Dal `short` al `sbyte`, `byte`, `ushort`, `uint`, `ulong`, o `char`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-263">From `short` to `sbyte`, `byte`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="3b24a-264">Dal `ushort` al `sbyte`, `byte`, `short`, o `char`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-264">From `ushort` to `sbyte`, `byte`, `short`, or `char`.</span></span>
*  <span data-ttu-id="3b24a-265">Dal `int` al `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, o `char`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-265">From `int` to `sbyte`, `byte`, `short`, `ushort`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="3b24a-266">Dal `uint` al `sbyte`, `byte`, `short`, `ushort`, `int`, o `char`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-266">From `uint` to `sbyte`, `byte`, `short`, `ushort`, `int`, or `char`.</span></span>
*  <span data-ttu-id="3b24a-267">Dal `long` al `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, o `char`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-267">From `long` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `ulong`, or `char`.</span></span>
*  <span data-ttu-id="3b24a-268">Dal `ulong` al `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, o `char`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-268">From `ulong` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, or `char`.</span></span>
*  <span data-ttu-id="3b24a-269">Dal `char` al `sbyte`, `byte`, o `short`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-269">From `char` to `sbyte`, `byte`, or `short`.</span></span>
*  <span data-ttu-id="3b24a-270">Dal `float` al `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-270">From `float` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, or `decimal`.</span></span>
*  <span data-ttu-id="3b24a-271">Dal `double` al `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-271">From `double` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `decimal`.</span></span>
*  <span data-ttu-id="3b24a-272">Dal `decimal` al `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, o `double`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-272">From `decimal` to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, or `double`.</span></span>

<span data-ttu-id="3b24a-273">Poiché le conversioni esplicite includono tutte le conversioni numeriche implicite ed esplicite, è sempre possibile eseguire la conversione da una qualsiasi *numeric_type* a qualsiasi altra *numeric_type* usando una coppia (espressione cast [Espressioni cast](expressions.md#cast-expressions)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-273">Because the explicit conversions include all implicit and explicit numeric conversions, it is always possible to convert from any *numeric_type* to any other *numeric_type* using a cast expression ([Cast expressions](expressions.md#cast-expressions)).</span></span>

<span data-ttu-id="3b24a-274">Conversioni numeriche esplicite determinare una perdita di informazioni o che si verifichi la generazione di eccezioni.</span><span class="sxs-lookup"><span data-stu-id="3b24a-274">The explicit numeric conversions possibly lose information or possibly cause exceptions to be thrown.</span></span> <span data-ttu-id="3b24a-275">Una conversione numerica esplicita viene elaborata come segue:</span><span class="sxs-lookup"><span data-stu-id="3b24a-275">An explicit numeric conversion is processed as follows:</span></span>

*  <span data-ttu-id="3b24a-276">Per una conversione da un tipo integrale a un altro tipo integrale, l'elaborazione dipende dal contesto di controllo dell'overflow ([gli operatori checked e unchecked](expressions.md#the-checked-and-unchecked-operators)) in cui la conversione richiede inserire:</span><span class="sxs-lookup"><span data-stu-id="3b24a-276">For a conversion from an integral type to another integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="3b24a-277">In un `checked` contesto, la conversione riesce se il valore dell'operando di origine è compreso nell'intervallo del tipo di destinazione, ma genera un `System.OverflowException` se il valore dell'operando di origine è compreso nell'intervallo del tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-277">In a `checked` context, the conversion succeeds if the value of the source operand is within the range of the destination type, but throws a `System.OverflowException` if the value of the source operand is outside the range of the destination type.</span></span>
    * <span data-ttu-id="3b24a-278">In un `unchecked` contesto, la conversione sempre ha esito positivo e procede nel modo seguente.</span><span class="sxs-lookup"><span data-stu-id="3b24a-278">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="3b24a-279">Se il tipo di origine è maggiore del tipo di destinazione, il valore di origine viene troncato rimuovendo i relativi "extra" bit più rilevanti.</span><span class="sxs-lookup"><span data-stu-id="3b24a-279">If the source type is larger than the destination type, then the source value is truncated by discarding its "extra" most significant bits.</span></span> <span data-ttu-id="3b24a-280">Il risultato viene quindi trattato come un valore del tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-280">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="3b24a-281">Se il tipo di origine è inferiore al tipo di destinazione, il valore di origine ha estensione firma o estensione zero in modo da avere le stesse dimensioni del tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-281">If the source type is smaller than the destination type, then the source value is either sign-extended or zero-extended so that it is the same size as the destination type.</span></span> <span data-ttu-id="3b24a-282">L'estensione firma viene usata se il tipo di origine dispone della firma; l'estensione zero viene usata se il tipo di origine è privo di firma.</span><span class="sxs-lookup"><span data-stu-id="3b24a-282">Sign-extension is used if the source type is signed; zero-extension is used if the source type is unsigned.</span></span> <span data-ttu-id="3b24a-283">Il risultato viene quindi trattato come un valore del tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-283">The result is then treated as a value of the destination type.</span></span>
        * <span data-ttu-id="3b24a-284">Se il tipo di origine ha le stesse dimensioni del tipo di destinazione, il valore di origine viene considerato un valore del tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-284">If the source type is the same size as the destination type, then the source value is treated as a value of the destination type.</span></span>
*  <span data-ttu-id="3b24a-285">Per una conversione da `decimal` a un tipo integrale, il valore di origine viene arrotondato per difetto al valore integrale più vicino e tale valore viene quindi il risultato della conversione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-285">For a conversion from `decimal` to an integral type, the source value is rounded towards zero to the nearest integral value, and this integral value becomes the result of the conversion.</span></span> <span data-ttu-id="3b24a-286">Se il valore integrale risultante non rientra nell'intervallo del tipo di destinazione, un `System.OverflowException` viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-286">If the resulting integral value is outside the range of the destination type, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="3b24a-287">Per una conversione da `float` oppure `double` a un tipo integrale, l'elaborazione dipende dal contesto di controllo dell'overflow ([gli operatori checked e unchecked](expressions.md#the-checked-and-unchecked-operators)) in cui la conversione richiede inserire:</span><span class="sxs-lookup"><span data-stu-id="3b24a-287">For a conversion from `float` or `double` to an integral type, the processing depends on the overflow checking context ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)) in which the conversion takes place:</span></span>
    * <span data-ttu-id="3b24a-288">In un `checked` contesto, la conversione avviene nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="3b24a-288">In a `checked` context, the conversion proceeds as follows:</span></span>
        * <span data-ttu-id="3b24a-289">Se il valore dell'operando è NaN o infinito, un `System.OverflowException` viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-289">If the value of the operand is NaN or infinite, a `System.OverflowException` is thrown.</span></span>
        * <span data-ttu-id="3b24a-290">In caso contrario, l'operando di origine viene arrotondato per difetto al valore integrale più vicino.</span><span class="sxs-lookup"><span data-stu-id="3b24a-290">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="3b24a-291">Se è questo valore integrale compreso nell'intervallo del tipo di destinazione questo valore è il risultato della conversione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-291">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="3b24a-292">In caso contrario viene generata un'eccezione `System.OverflowException`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-292">Otherwise, a `System.OverflowException` is thrown.</span></span>
    * <span data-ttu-id="3b24a-293">In un `unchecked` contesto, la conversione sempre ha esito positivo e procede nel modo seguente.</span><span class="sxs-lookup"><span data-stu-id="3b24a-293">In an `unchecked` context, the conversion always succeeds, and proceeds as follows.</span></span>
        * <span data-ttu-id="3b24a-294">Se il valore dell'operando è un valore NaN o infinito, il risultato della conversione è un valore non specificato del tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-294">If the value of the operand is NaN or infinite, the result of the conversion is an unspecified value of the destination type.</span></span>
        * <span data-ttu-id="3b24a-295">In caso contrario, l'operando di origine viene arrotondato per difetto al valore integrale più vicino.</span><span class="sxs-lookup"><span data-stu-id="3b24a-295">Otherwise, the source operand is rounded towards zero to the nearest integral value.</span></span> <span data-ttu-id="3b24a-296">Se è questo valore integrale compreso nell'intervallo del tipo di destinazione questo valore è il risultato della conversione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-296">If this integral value is within the range of the destination type then this value is the result of the conversion.</span></span>
        * <span data-ttu-id="3b24a-297">In caso contrario, il risultato della conversione è un valore non specificato del tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-297">Otherwise, the result of the conversion is an unspecified value of the destination type.</span></span>
*  <span data-ttu-id="3b24a-298">Per una conversione da `double` al `float`, il `double` valore viene arrotondato al più vicino `float` valore.</span><span class="sxs-lookup"><span data-stu-id="3b24a-298">For a conversion from `double` to `float`, the `double` value is rounded to the nearest `float` value.</span></span> <span data-ttu-id="3b24a-299">Se il `double` valore è troppo piccolo per essere rappresentato come un `float`, il risultato diventa zero positivo o negativo.</span><span class="sxs-lookup"><span data-stu-id="3b24a-299">If the `double` value is too small to represent as a `float`, the result becomes positive zero or negative zero.</span></span> <span data-ttu-id="3b24a-300">Se il `double` valore è troppo grande per essere rappresentato come un `float`, il risultato diventa infinito positivo o negativo.</span><span class="sxs-lookup"><span data-stu-id="3b24a-300">If the `double` value is too large to represent as a `float`, the result becomes positive infinity or negative infinity.</span></span> <span data-ttu-id="3b24a-301">Se il `double` valore è NaN, il risultato è NaN.</span><span class="sxs-lookup"><span data-stu-id="3b24a-301">If the `double` value is NaN, the result is also NaN.</span></span>
*  <span data-ttu-id="3b24a-302">Per una conversione da `float` oppure `double` al `decimal`, il valore di origine viene convertito in `decimal` rappresentazione e arrotondato al numero più vicino successivo dopo la posizione decimale 28, se necessario ([tipo decimale](types.md#the-decimal-type)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-302">For a conversion from `float` or `double` to `decimal`, the source value is converted to `decimal` representation and rounded to the nearest number after the 28th decimal place if required ([The decimal type](types.md#the-decimal-type)).</span></span> <span data-ttu-id="3b24a-303">Se il valore di origine è troppo piccolo per essere rappresentato come un `decimal`, il risultato diventa zero.</span><span class="sxs-lookup"><span data-stu-id="3b24a-303">If the source value is too small to represent as a `decimal`, the result becomes zero.</span></span> <span data-ttu-id="3b24a-304">Se il valore di origine è NaN, infinito o troppo grande per essere rappresentato come un `decimal`, un `System.OverflowException` viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-304">If the source value is NaN, infinity, or too large to represent as a `decimal`, a `System.OverflowException` is thrown.</span></span>
*  <span data-ttu-id="3b24a-305">Per una conversione da `decimal` a `float` oppure `double`, il `decimal` valore viene arrotondato al più vicino `double` o `float` valore.</span><span class="sxs-lookup"><span data-stu-id="3b24a-305">For a conversion from `decimal` to `float` or `double`, the `decimal` value is rounded to the nearest `double` or `float` value.</span></span> <span data-ttu-id="3b24a-306">Durante questa conversione possibile perdita di precisione, comporta mai la generazione di un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-306">While this conversion may lose precision, it never causes an exception to be thrown.</span></span>

### <a name="explicit-enumeration-conversions"></a><span data-ttu-id="3b24a-307">Conversioni enumerazione esplicita</span><span class="sxs-lookup"><span data-stu-id="3b24a-307">Explicit enumeration conversions</span></span>

<span data-ttu-id="3b24a-308">Le conversioni enumerazione esplicita sono:</span><span class="sxs-lookup"><span data-stu-id="3b24a-308">The explicit enumeration conversions are:</span></span>

*  <span data-ttu-id="3b24a-309">Dal `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, o `decimal` a qualsiasi *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="3b24a-309">From `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal` to any *enum_type*.</span></span>
*  <span data-ttu-id="3b24a-310">Da qualsiasi *enum_type* al `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, o `decimal`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-310">From any *enum_type* to `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, or `decimal`.</span></span>
*  <span data-ttu-id="3b24a-311">Da qualsiasi *enum_type* a qualsiasi altra *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="3b24a-311">From any *enum_type* to any other *enum_type*.</span></span>

<span data-ttu-id="3b24a-312">Una conversione esplicita di enumerazione tra due tipi viene elaborata, considerando qualsiasi partecipanti *enum_type* con il tipo sottostante di tale *enum_type*ed eseguendo un implicita o esplicita conversione numerica tra i tipi risultanti.</span><span class="sxs-lookup"><span data-stu-id="3b24a-312">An explicit enumeration conversion between two types is processed by treating any participating *enum_type* as the underlying type of that *enum_type*, and then performing an implicit or explicit numeric conversion between the resulting types.</span></span> <span data-ttu-id="3b24a-313">Si consideri, ad esempio, un' *enum_type* `E` con e il tipo sottostante del `int`, una conversione da `E` alla `byte` viene elaborato come una conversione numerica esplicita ([Explicit conversioni numeriche](conversions.md#explicit-numeric-conversions)) da `int` al `byte`e una conversione da `byte` al `E` viene elaborato come una conversione numerica implicita ([conversioni numeriche implicite](conversions.md#implicit-numeric-conversions)) dal `byte` a `int`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-313">For example, given an *enum_type* `E` with and underlying type of `int`, a conversion from `E` to `byte` is processed as an explicit numeric conversion ([Explicit numeric conversions](conversions.md#explicit-numeric-conversions)) from `int` to `byte`, and a conversion from `byte` to `E` is processed as an implicit numeric conversion ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions)) from `byte` to `int`.</span></span>

### <a name="explicit-nullable-conversions"></a><span data-ttu-id="3b24a-314">Conversioni esplicite che ammette valori null</span><span class="sxs-lookup"><span data-stu-id="3b24a-314">Explicit nullable conversions</span></span>

<span data-ttu-id="3b24a-315">***Conversioni esplicite nullable*** autorizzazione predefiniti per le conversioni esplicite che operano sui tipi di valore non nullable per essere usato anche con le forme di tali tipi nullable.</span><span class="sxs-lookup"><span data-stu-id="3b24a-315">***Explicit nullable conversions*** permit predefined explicit conversions that operate on non-nullable value types to also be used with nullable forms of those types.</span></span> <span data-ttu-id="3b24a-316">Per ognuna delle conversioni esplicite predefinite che consentono di convertire da un tipo di valore non nullable `S` a un tipo di valore non nullable `T` ([conversione di identità](conversions.md#identity-conversion), [conversioni numeriche implicite](conversions.md#implicit-numeric-conversions), [Conversioni implicite enumerazione](conversions.md#implicit-enumeration-conversions), [conversioni numeriche esplicite](conversions.md#explicit-numeric-conversions), e [conversioni enumerazione esplicita](conversions.md#explicit-enumeration-conversions)), quanto segue sono disponibili conversioni nullable:</span><span class="sxs-lookup"><span data-stu-id="3b24a-316">For each of the predefined explicit conversions that convert from a non-nullable value type `S` to a non-nullable value type `T` ([Identity conversion](conversions.md#identity-conversion), [Implicit numeric conversions](conversions.md#implicit-numeric-conversions), [Implicit enumeration conversions](conversions.md#implicit-enumeration-conversions), [Explicit numeric conversions](conversions.md#explicit-numeric-conversions), and [Explicit enumeration conversions](conversions.md#explicit-enumeration-conversions)), the following nullable conversions exist:</span></span>

*  <span data-ttu-id="3b24a-317">Una conversione esplicita dal `S?` a `T?`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-317">An explicit conversion from `S?` to `T?`.</span></span>
*  <span data-ttu-id="3b24a-318">Una conversione esplicita dal `S` a `T?`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-318">An explicit conversion from `S` to `T?`.</span></span>
*  <span data-ttu-id="3b24a-319">Una conversione esplicita dal `S?` a `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-319">An explicit conversion from `S?` to `T`.</span></span>

<span data-ttu-id="3b24a-320">Valutazione di una conversione che ammette valori null in base una conversione da sottostante `S` a `T` procede nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="3b24a-320">Evaluation of a nullable conversion based on an underlying conversion from `S` to `T` proceeds as follows:</span></span>

*  <span data-ttu-id="3b24a-321">Se la conversione che ammette valori null dal `S?` a `T?`:</span><span class="sxs-lookup"><span data-stu-id="3b24a-321">If the nullable conversion is from `S?` to `T?`:</span></span>
    * <span data-ttu-id="3b24a-322">Se il valore di origine è null (`HasValue` proprietà è false), il risultato è il valore null di tipo `T?`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-322">If the source value is null (`HasValue` property is false), the result is the null value of type `T?`.</span></span>
    * <span data-ttu-id="3b24a-323">In caso contrario, la conversione viene valutata come un annullamento del wrapping da `S?` al `S`, seguita dalla conversione sottostante da `S` al `T`, seguito da un ritorno a capo da `T` a `T?`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-323">Otherwise, the conversion is evaluated as an unwrapping from `S?` to `S`, followed by the underlying conversion from `S` to `T`, followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="3b24a-324">Se la conversione che ammette valori null è da `S` al `T?`, la conversione viene valutata come la conversione da sottostante `S` a `T` seguita da un ritorno a capo da `T` per `T?`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-324">If the nullable conversion is from `S` to `T?`, the conversion is evaluated as the underlying conversion from `S` to `T` followed by a wrapping from `T` to `T?`.</span></span>
*  <span data-ttu-id="3b24a-325">Se la conversione che ammette valori null è da `S?` al `T`, la conversione viene valutata come un annullamento del wrapping dalla `S?` a `S` seguita dalla conversione sottostante da `S` a `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-325">If the nullable conversion is from `S?` to `T`, the conversion is evaluated as an unwrapping from `S?` to `S` followed by the underlying conversion from `S` to `T`.</span></span>

<span data-ttu-id="3b24a-326">Si noti che un tentativo di annullare il wrapping di un valore nullable genererà un'eccezione se il valore è `null`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-326">Note that an attempt to unwrap a nullable value will throw an exception if the value is `null`.</span></span>

### <a name="explicit-reference-conversions"></a><span data-ttu-id="3b24a-327">Conversioni dei riferimenti espliciti</span><span class="sxs-lookup"><span data-stu-id="3b24a-327">Explicit reference conversions</span></span>

<span data-ttu-id="3b24a-328">Le conversioni di riferimenti espliciti sono:</span><span class="sxs-lookup"><span data-stu-id="3b24a-328">The explicit reference conversions are:</span></span>

*  <span data-ttu-id="3b24a-329">Dal `object` e `dynamic` a qualsiasi altra *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="3b24a-329">From `object` and `dynamic` to any other *reference_type*.</span></span>
*  <span data-ttu-id="3b24a-330">Da qualsiasi *class_type* `S` a qualsiasi *class_type* `T`, fornito `S` è una classe di base di `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-330">From any *class_type* `S` to any *class_type* `T`, provided `S` is a base class of `T`.</span></span>
*  <span data-ttu-id="3b24a-331">Da qualsiasi *class_type* `S` a qualsiasi *interface_type* `T`, fornito `S` non sia sealed e forniti `S` neimplementuje metodu `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-331">From any *class_type* `S` to any *interface_type* `T`, provided `S` is not sealed and provided `S` does not implement `T`.</span></span>
*  <span data-ttu-id="3b24a-332">Da qualsiasi *interface_type* `S` a qualsiasi *class_type* `T`, fornito `T` non è sealed o fornito `T` implementa `S`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-332">From any *interface_type* `S` to any *class_type* `T`, provided `T` is not sealed or provided `T` implements `S`.</span></span>
*  <span data-ttu-id="3b24a-333">Da qualsiasi *interface_type* `S` a qualsiasi *interface_type* `T`, fornito `S` non è derivato da `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-333">From any *interface_type* `S` to any *interface_type* `T`, provided `S` is not derived from `T`.</span></span>
*  <span data-ttu-id="3b24a-334">Da un *array_type* `S` con un tipo di elemento `SE` a un *array_type* `T` con un tipo di elemento `TE`, purché tutti gli elementi seguenti sono vere:</span><span class="sxs-lookup"><span data-stu-id="3b24a-334">From an *array_type* `S` with an element type `SE` to an *array_type* `T` with an element type `TE`, provided all of the following are true:</span></span>
    * <span data-ttu-id="3b24a-335">`S` e `T` differiscono solo nel tipo di elemento.</span><span class="sxs-lookup"><span data-stu-id="3b24a-335">`S` and `T` differ only in element type.</span></span> <span data-ttu-id="3b24a-336">In altre parole, `S` e `T` hanno lo stesso numero di dimensioni.</span><span class="sxs-lookup"><span data-stu-id="3b24a-336">In other words, `S` and `T` have the same number of dimensions.</span></span>
    * <span data-ttu-id="3b24a-337">Entrambe `SE` e `TE` vengono *reference_type*s.</span><span class="sxs-lookup"><span data-stu-id="3b24a-337">Both `SE` and `TE` are *reference_type*s.</span></span>
    * <span data-ttu-id="3b24a-338">Esiste una conversione esplicita di riferimenti dal `SE` a `TE`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-338">An explicit reference conversion exists from `SE` to `TE`.</span></span>
*  <span data-ttu-id="3b24a-339">Dal `System.Array` e le interfacce implementate in qualsiasi *array_type*.</span><span class="sxs-lookup"><span data-stu-id="3b24a-339">From `System.Array` and the interfaces it implements to any *array_type*.</span></span>
*  <span data-ttu-id="3b24a-340">Da un tipo di matrice unidimensionale `S[]` al `System.Collections.Generic.IList<T>` e le relative interfacce di base, purché esista una conversione esplicita di riferimenti dal `S` a `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-340">From a single-dimensional array type `S[]` to `System.Collections.Generic.IList<T>` and its base interfaces, provided that there is an explicit reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="3b24a-341">Dal `System.Collections.Generic.IList<S>` e interfacce di base a un tipo di matrice unidimensionale `T[]`, a condizione che vi è una conversione esplicita di identità o un riferimento dal `S` a `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-341">From `System.Collections.Generic.IList<S>` and its base interfaces to a single-dimensional array type `T[]`, provided that there is an explicit identity or reference conversion from `S` to `T`.</span></span>
*  <span data-ttu-id="3b24a-342">Dal `System.Delegate` e le interfacce implementate in qualsiasi *delegate_type*.</span><span class="sxs-lookup"><span data-stu-id="3b24a-342">From `System.Delegate` and the interfaces it implements to any *delegate_type*.</span></span>
*  <span data-ttu-id="3b24a-343">Da un tipo di riferimento a un tipo riferimento `T` se dispone di una conversione esplicita di riferimenti a un tipo riferimento `T0` e `T0` dispone di una conversione di identità `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-343">From a reference type to a reference type `T` if it has an explicit reference conversion to a reference type `T0` and `T0` has an identity conversion `T`.</span></span>
*  <span data-ttu-id="3b24a-344">Da un tipo di riferimento a un tipo interfaccia o delegato `T` se dispone di una conversione esplicita di riferimenti a un tipo interfaccia o delegato `T0` e il valore `T0` è convertibile la varianza per `T` o `T` è convertibile la varianza per `T0` ([conversione della varianza](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-344">From a reference type to an interface or delegate type `T` if it has an explicit reference conversion to an interface or delegate type `T0` and either `T0` is variance-convertible to `T` or `T` is variance-convertible to `T0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>
*  <span data-ttu-id="3b24a-345">Dal `D<S1...Sn>` al `D<T1...Tn>` in cui `D<X1...Xn>` è un tipo delegato generico, `D<S1...Sn>` non è compatibile con o identico al `D<T1...Tn>`e per ogni parametro di tipo `Xi` di `D` contenuti nelle seguenti:</span><span class="sxs-lookup"><span data-stu-id="3b24a-345">From `D<S1...Sn>` to `D<T1...Tn>` where `D<X1...Xn>` is a generic delegate type, `D<S1...Sn>` is not compatible with or identical to `D<T1...Tn>`, and for each type parameter `Xi` of `D` the following holds:</span></span>
    * <span data-ttu-id="3b24a-346">Se `Xi` è invariabile, quindi `Si` è identica alla `Ti`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-346">If `Xi` is invariant, then `Si` is identical to `Ti`.</span></span>
    * <span data-ttu-id="3b24a-347">Se `Xi` è covariante, non vi è una conversione di identità o un riferimento implicita o esplicita da `Si` a `Ti`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-347">If `Xi` is covariant, then there is an implicit or explicit identity or reference conversion from `Si` to `Ti`.</span></span>
    * <span data-ttu-id="3b24a-348">Se `Xi` è controvariante, quindi `Si` e `Ti` sono identici o entrambi i tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="3b24a-348">If `Xi` is contravariant, then `Si` and `Ti` are either identical or both reference types.</span></span>
*  <span data-ttu-id="3b24a-349">Conversioni esplicite che includono parametri di tipo che sono noti come tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="3b24a-349">Explicit conversions involving type parameters that are known to be reference types.</span></span> <span data-ttu-id="3b24a-350">Per altre informazioni dettagliate sulle conversioni esplicite con i parametri di tipo, vedere [conversioni esplicite con i parametri di tipo](conversions.md#explicit-conversions-involving-type-parameters).</span><span class="sxs-lookup"><span data-stu-id="3b24a-350">For more details on explicit conversions involving type parameters, see [Explicit conversions involving type parameters](conversions.md#explicit-conversions-involving-type-parameters).</span></span>

<span data-ttu-id="3b24a-351">Le conversioni di riferimenti espliciti sono conversioni tra tipi di riferimento che richiedono controlli in fase di esecuzione per assicurarsi che siano corretti.</span><span class="sxs-lookup"><span data-stu-id="3b24a-351">The explicit reference conversions are those conversions between reference-types that require run-time checks to ensure they are correct.</span></span>

<span data-ttu-id="3b24a-352">Per una conversione esplicita di riferimento abbia esito positivo in fase di esecuzione, il valore dell'operando di origine deve essere `null`, o il tipo effettivo dell'oggetto a cui fa riferimento l'operando di origine deve essere un tipo che può essere convertito nel tipo di destinazione da un riferimento implicito conversione ([le conversioni dei riferimenti implicita](conversions.md#implicit-reference-conversions)) o una conversione boxing ([conversioni Boxing](conversions.md#boxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-352">For an explicit reference conversion to succeed at run-time, the value of the source operand must be `null`, or the actual type of the object referenced by the source operand must be a type that can be converted to the destination type by an implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions)) or boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)).</span></span> <span data-ttu-id="3b24a-353">Se una conversione esplicita di riferimento non riesce, un `System.InvalidCastException` viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-353">If an explicit reference conversion fails, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="3b24a-354">Le conversioni dei riferimenti, implicite o esplicite, non modificano mai l'identità referenziale dell'oggetto da convertire.</span><span class="sxs-lookup"><span data-stu-id="3b24a-354">Reference conversions, implicit or explicit, never change the referential identity of the object being converted.</span></span> <span data-ttu-id="3b24a-355">In altre parole, mentre la conversione di un riferimento può modificare il tipo del riferimento, non modifica mai il tipo o il valore dell'oggetto a cui si fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="3b24a-355">In other words, while a reference conversion may change the type of the reference, it never changes the type or value of the object being referred to.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="3b24a-356">Conversione unboxing</span><span class="sxs-lookup"><span data-stu-id="3b24a-356">Unboxing conversions</span></span>

<span data-ttu-id="3b24a-357">Una conversione unboxing consente un tipo di riferimento da convertire in modo esplicito in una *value_type*.</span><span class="sxs-lookup"><span data-stu-id="3b24a-357">An unboxing conversion permits a reference type to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="3b24a-358">Esiste una conversione unboxing dai tipi `object`, `dynamic` e `System.ValueType` a qualsiasi *non_nullable_value_type*e da qualsiasi *interface_type* a qualsiasi *non_ nullable_value_type* che implementa le *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="3b24a-358">An unboxing conversion exists from the types `object`, `dynamic` and `System.ValueType` to any *non_nullable_value_type*, and from any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span> <span data-ttu-id="3b24a-359">Inoltre digitare `System.Enum` possono essere boxed a qualsiasi *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="3b24a-359">Furthermore type `System.Enum` can be unboxed to any *enum_type*.</span></span>

<span data-ttu-id="3b24a-360">Esiste una conversione unboxing da un tipo di riferimento a un *nullable_type* se esiste una conversione unboxing dal tipo di riferimento sottostante *non_nullable_value_type* del  *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="3b24a-360">An unboxing conversion exists from a reference type to a *nullable_type* if an unboxing conversion exists from the reference type to the underlying *non_nullable_value_type* of the *nullable_type*.</span></span>

<span data-ttu-id="3b24a-361">Un tipo di valore `S` dispone di una conversione unboxing di un tipo di interfaccia `I` se dispone di una conversione unboxing di un tipo di interfaccia `I0` e `I0` dispone di una conversione di identità per `I`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-361">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface type `I0` and `I0` has an identity conversion to `I`.</span></span>

<span data-ttu-id="3b24a-362">Un tipo di valore `S` dispone di una conversione unboxing di un tipo di interfaccia `I` se dispone di una conversione unboxing di un tipo interfaccia o delegato `I0` e il valore `I0` è convertibile la varianza per `I` o`I`sia convertibile la varianza per `I0` ([conversione della varianza](interfaces.md#variance-conversion)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-362">A value type `S` has an unboxing conversion from an interface type `I` if it has an unboxing conversion from an interface or delegate type `I0` and either `I0` is variance-convertible to `I` or `I` is variance-convertible to `I0` ([Variance conversion](interfaces.md#variance-conversion)).</span></span>

<span data-ttu-id="3b24a-363">Un'operazione unboxing prevede di verificare prima che l'istanza dell'oggetto è un valore boxed di dato *value_type*e quindi copiando il valore all'esterno dell'istanza.</span><span class="sxs-lookup"><span data-stu-id="3b24a-363">An unboxing operation consists of first checking that the object instance is a boxed value of the given *value_type*, and then copying the value out of the instance.</span></span> <span data-ttu-id="3b24a-364">Conversione unboxing di un riferimento null a un *nullable_type* produce il valore null delle *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="3b24a-364">Unboxing a null reference to a *nullable_type* produces the null value of the *nullable_type*.</span></span> <span data-ttu-id="3b24a-365">Uno struct può essere boxed dal tipo `System.ValueType`, dal momento che è una classe base per tutti gli struct ([ereditarietà](structs.md#inheritance)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-365">A struct can be unboxed from the type `System.ValueType`, since that is a base class for all structs ([Inheritance](structs.md#inheritance)).</span></span>

<span data-ttu-id="3b24a-366">Vengono descritte dettagliatamente nella conversione unboxing [conversioni di Unboxing](types.md#unboxing-conversions).</span><span class="sxs-lookup"><span data-stu-id="3b24a-366">Unboxing conversions are described further in [Unboxing conversions](types.md#unboxing-conversions).</span></span>

### <a name="explicit-dynamic-conversions"></a><span data-ttu-id="3b24a-367">Conversioni esplicite dinamiche</span><span class="sxs-lookup"><span data-stu-id="3b24a-367">Explicit dynamic conversions</span></span>

<span data-ttu-id="3b24a-368">Esiste una conversione dinamica esplicita da un'espressione di tipo `dynamic` a qualsiasi tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-368">An explicit dynamic conversion exists from an expression of type `dynamic` to any type `T`.</span></span> <span data-ttu-id="3b24a-369">La conversione in modo dinamico è associata ([binding dinamico](expressions.md#dynamic-binding)), il che significa che una conversione esplicita verrà cercata in fase di esecuzione dal tipo di fase di esecuzione dell'espressione a `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-369">The conversion is dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)), which means that an explicit conversion will be sought at run-time from the run-time type of the expression to `T`.</span></span> <span data-ttu-id="3b24a-370">Se non viene trovata alcuna conversione, viene generata un'eccezione in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-370">If no conversion is found, a run-time exception is thrown.</span></span>

<span data-ttu-id="3b24a-371">Se non si desidera l'associazione dinamica della conversione, l'espressione può essere convertita prima di tutto a `object`e quindi al tipo desiderato.</span><span class="sxs-lookup"><span data-stu-id="3b24a-371">If dynamic binding of the conversion is not desired, the expression can be first converted to `object`, and then to the desired type.</span></span>

<span data-ttu-id="3b24a-372">Si supponga che è definita la classe seguente:</span><span class="sxs-lookup"><span data-stu-id="3b24a-372">Assume the following class is defined:</span></span>
```csharp
class C
{
    int i;

    public C(int i) { this.i = i; }

    public static explicit operator C(string s) 
    {
        return new C(int.Parse(s));
    }
}
```

<span data-ttu-id="3b24a-373">L'esempio seguente illustra le conversioni esplicite di dinamiche:</span><span class="sxs-lookup"><span data-stu-id="3b24a-373">The following example illustrates explicit dynamic conversions:</span></span>
```csharp
object o  = "1";
dynamic d = "2";

var c1 = (C)o; // Compiles, but explicit reference conversion fails
var c2 = (C)d; // Compiles and user defined conversion succeeds
```

<span data-ttu-id="3b24a-374">La conversione dei migliori `o` a `C` viene trovato in fase di compilazione per essere eseguita una conversione esplicita di riferimenti.</span><span class="sxs-lookup"><span data-stu-id="3b24a-374">The best conversion of `o` to `C` is found at compile-time to be an explicit reference conversion.</span></span> <span data-ttu-id="3b24a-375">L'operazione non riesce in fase di esecuzione, in quanto `"1"` non è in effetti un `C`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-375">This fails at run-time, because `"1"` is not in fact a `C`.</span></span> <span data-ttu-id="3b24a-376">La conversione di `d` al `C` tuttavia, come una conversione esplicita dinamica, viene sospesa alla fase di esecuzione, in cui un utente definito conversione dal tipo di runtime del `d`  --  `string` , ovvero a `C` viene trovato, e ha esito positivo.</span><span class="sxs-lookup"><span data-stu-id="3b24a-376">The conversion of `d` to `C` however, as an explicit dynamic conversion, is suspended to run-time, where a user defined conversion from the run-time type of `d` -- `string` -- to `C` is found, and succeeds.</span></span>

### <a name="explicit-conversions-involving-type-parameters"></a><span data-ttu-id="3b24a-377">Conversioni esplicite che includono parametri di tipo</span><span class="sxs-lookup"><span data-stu-id="3b24a-377">Explicit conversions involving type parameters</span></span>

<span data-ttu-id="3b24a-378">Per un parametro di tipo specificato esistono le seguenti conversioni esplicite `T`:</span><span class="sxs-lookup"><span data-stu-id="3b24a-378">The following explicit conversions exist for a given type parameter `T`:</span></span>

*  <span data-ttu-id="3b24a-379">Dalla classe di base efficace `C` dei `T` a `T` e da qualsiasi classe di base di `C` a `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-379">From the effective base class `C` of `T` to `T` and from any base class of `C` to `T`.</span></span> <span data-ttu-id="3b24a-380">Se in fase di esecuzione, at `T` è un tipo di valore, la conversione viene eseguita come una conversione unboxing.</span><span class="sxs-lookup"><span data-stu-id="3b24a-380">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="3b24a-381">In caso contrario, la conversione viene eseguita come un riferimento esplicito o conversione di identità.</span><span class="sxs-lookup"><span data-stu-id="3b24a-381">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="3b24a-382">Da qualsiasi tipo di interfaccia a `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-382">From any interface type to `T`.</span></span> <span data-ttu-id="3b24a-383">Se in fase di esecuzione, at `T` è un tipo di valore, la conversione viene eseguita come una conversione unboxing.</span><span class="sxs-lookup"><span data-stu-id="3b24a-383">At run-time, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="3b24a-384">In caso contrario, la conversione viene eseguita come un riferimento esplicito o conversione di identità.</span><span class="sxs-lookup"><span data-stu-id="3b24a-384">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="3b24a-385">Dal `T` a qualsiasi *interface_type* `I` fornito non esiste già una conversione implicita da `T` a `I`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-385">From `T` to any *interface_type* `I` provided there is not already an implicit conversion from `T` to `I`.</span></span> <span data-ttu-id="3b24a-386">Se in fase di esecuzione, at `T` è un tipo di valore, la conversione viene eseguita la conversione boxing seguita da una conversione esplicita di riferimento.</span><span class="sxs-lookup"><span data-stu-id="3b24a-386">At run-time, if `T` is a value type, the conversion is executed as a boxing conversion followed by an explicit reference conversion.</span></span> <span data-ttu-id="3b24a-387">In caso contrario, la conversione viene eseguita come un riferimento esplicito o conversione di identità.</span><span class="sxs-lookup"><span data-stu-id="3b24a-387">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>
*  <span data-ttu-id="3b24a-388">Da un parametro di tipo `U` al `T`, specificato `T` dipende `U` ([digitare i vincoli del parametro](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-388">From a type parameter `U` to `T`, provided `T` depends on `U` ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="3b24a-389">Se in fase di esecuzione, at `U` è un tipo di valore, quindi `T` e `U` sono necessariamente dello stesso tipo e viene eseguita alcuna conversione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-389">At run-time, if `U` is a value type, then `T` and `U` are necessarily the same type and no conversion is performed.</span></span> <span data-ttu-id="3b24a-390">In caso contrario, se `T` è un tipo di valore, la conversione viene eseguita come una conversione unboxing.</span><span class="sxs-lookup"><span data-stu-id="3b24a-390">Otherwise, if `T` is a value type, the conversion is executed as an unboxing conversion.</span></span> <span data-ttu-id="3b24a-391">In caso contrario, la conversione viene eseguita come un riferimento esplicito o conversione di identità.</span><span class="sxs-lookup"><span data-stu-id="3b24a-391">Otherwise, the conversion is executed as an explicit reference conversion or identity conversion.</span></span>

<span data-ttu-id="3b24a-392">Se `T` è destinata a essere un tipo riferimento, tutte le conversioni sopra sono classificate come le conversioni dei riferimenti espliciti ([le conversioni dei riferimenti espliciti](conversions.md#explicit-reference-conversions)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-392">If `T` is known to be a reference type, the conversions above are all classified as explicit reference conversions ([Explicit reference conversions](conversions.md#explicit-reference-conversions)).</span></span> <span data-ttu-id="3b24a-393">Se `T` non è noto per essere un tipo riferimento, le conversioni sopra sono classificate come unboxing conversioni ([conversione Unboxing](conversions.md#unboxing-conversions)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-393">If `T` is not known to be a reference type, the conversions above are classified as unboxing conversions ([Unboxing conversions](conversions.md#unboxing-conversions)).</span></span>

<span data-ttu-id="3b24a-394">Le regole precedenti non permettono una conversione esplicita diretta da un parametro di tipo senza vincoli in un tipo non di interfaccia, che potrebbe essere sorprendente.</span><span class="sxs-lookup"><span data-stu-id="3b24a-394">The above rules do not permit a direct explicit conversion from an unconstrained type parameter to a non-interface type, which might be surprising.</span></span> <span data-ttu-id="3b24a-395">Il motivo di questa regola è per evitare confusione e rendere la semantica di tali conversioni.</span><span class="sxs-lookup"><span data-stu-id="3b24a-395">The reason for this rule is to prevent confusion and make the semantics of such conversions clear.</span></span> <span data-ttu-id="3b24a-396">Si consideri ad esempio la seguente dichiarazione:</span><span class="sxs-lookup"><span data-stu-id="3b24a-396">For example, consider the following declaration:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)t;                // Error 
    }
}
```

<span data-ttu-id="3b24a-397">Se la conversione esplicita di direct `t` a `int` fosse consentito, ci si aspetterebbe facilmente che `X<int>.F(7)` restituirebbe `7L`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-397">If the direct explicit conversion of `t` to `int` were permitted, one might easily expect that `X<int>.F(7)` would return `7L`.</span></span> <span data-ttu-id="3b24a-398">Tuttavia, non lo avrebbe, poiché le conversioni numeriche standard vengono considerate solo quando i tipi sono noti per essere un valore numerico in fase di associazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-398">However, it would not, because the standard numeric conversions are only considered when the types are known to be numeric at binding-time.</span></span> <span data-ttu-id="3b24a-399">Per rendere la semantica chiari, nell'esempio precedente sarà necessario scrivere:</span><span class="sxs-lookup"><span data-stu-id="3b24a-399">In order to make the semantics clear, the above example must instead be written:</span></span>
```csharp
class X<T>
{
    public static long F(T t) {
        return (long)(object)t;        // Ok, but will only work when T is long
    }
}
```

<span data-ttu-id="3b24a-400">Questo codice verrà quindi compilato ma l'esecuzione `X<int>.F(7)` genererà un'eccezione in fase di esecuzione, poiché boxed `int` non può essere convertito direttamente in un `long`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-400">This code will now compile but executing `X<int>.F(7)` would then throw an exception at run-time, since a boxed `int` cannot be converted directly to a `long`.</span></span>

### <a name="user-defined-explicit-conversions"></a><span data-ttu-id="3b24a-401">Conversioni esplicite definite dall'utente</span><span class="sxs-lookup"><span data-stu-id="3b24a-401">User-defined explicit conversions</span></span>

<span data-ttu-id="3b24a-402">Una conversione esplicita definita dall'utente è costituito da una conversione esplicita standard facoltativa, seguita dall'esecuzione di un operatore di conversione implicita o esplicita definita dall'utente, seguito da un'altra conversione esplicita standard facoltativa.</span><span class="sxs-lookup"><span data-stu-id="3b24a-402">A user-defined explicit conversion consists of an optional standard explicit conversion, followed by execution of a user-defined implicit or explicit conversion operator, followed by another optional standard explicit conversion.</span></span> <span data-ttu-id="3b24a-403">Le regole precise per la valutazione di conversioni esplicite definite dall'utente sono descritti [elaborazione di conversioni esplicite definite dall'utente](conversions.md#processing-of-user-defined-explicit-conversions).</span><span class="sxs-lookup"><span data-stu-id="3b24a-403">The exact rules for evaluating user-defined explicit conversions are described in [Processing of user-defined explicit conversions](conversions.md#processing-of-user-defined-explicit-conversions).</span></span>

## <a name="standard-conversions"></a><span data-ttu-id="3b24a-404">Conversioni standard</span><span class="sxs-lookup"><span data-stu-id="3b24a-404">Standard conversions</span></span>

<span data-ttu-id="3b24a-405">Le conversioni standard sono conversioni predefinite che possono verificarsi come parte di una conversione definita dall'utente.</span><span class="sxs-lookup"><span data-stu-id="3b24a-405">The standard conversions are those pre-defined conversions that can occur as part of a user-defined conversion.</span></span>

### <a name="standard-implicit-conversions"></a><span data-ttu-id="3b24a-406">Conversioni implicite</span><span class="sxs-lookup"><span data-stu-id="3b24a-406">Standard implicit conversions</span></span>

<span data-ttu-id="3b24a-407">Le seguenti conversioni implicite sono classificate come le conversioni implicite standard:</span><span class="sxs-lookup"><span data-stu-id="3b24a-407">The following implicit conversions are classified as standard implicit conversions:</span></span>

*  <span data-ttu-id="3b24a-408">Conversioni di identità ([conversione di identità](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="3b24a-408">Identity conversions ([Identity conversion](conversions.md#identity-conversion))</span></span>
*  <span data-ttu-id="3b24a-409">Conversioni numeriche implicite ([conversioni numeriche implicite](conversions.md#implicit-numeric-conversions))</span><span class="sxs-lookup"><span data-stu-id="3b24a-409">Implicit numeric conversions ([Implicit numeric conversions](conversions.md#implicit-numeric-conversions))</span></span>
*  <span data-ttu-id="3b24a-410">Conversioni implicite che ammette valori null ([conversioni implicite nullable](conversions.md#implicit-nullable-conversions))</span><span class="sxs-lookup"><span data-stu-id="3b24a-410">Implicit nullable conversions ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions))</span></span>
*  <span data-ttu-id="3b24a-411">Le conversioni dei riferimenti impliciti ([le conversioni dei riferimenti implicita](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="3b24a-411">Implicit reference conversions ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
*  <span data-ttu-id="3b24a-412">Le conversioni boxing ([conversioni Boxing](conversions.md#boxing-conversions))</span><span class="sxs-lookup"><span data-stu-id="3b24a-412">Boxing conversions ([Boxing conversions](conversions.md#boxing-conversions))</span></span>
*  <span data-ttu-id="3b24a-413">Le conversioni implicite di espressioni costanti ([conversioni implicite dinamiche](conversions.md#implicit-dynamic-conversions))</span><span class="sxs-lookup"><span data-stu-id="3b24a-413">Implicit constant expression conversions ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions))</span></span>
*  <span data-ttu-id="3b24a-414">Conversioni implicite con i parametri di tipo ([conversioni implicite con i parametri di tipo](conversions.md#implicit-conversions-involving-type-parameters))</span><span class="sxs-lookup"><span data-stu-id="3b24a-414">Implicit conversions involving type parameters ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters))</span></span>

<span data-ttu-id="3b24a-415">Le conversioni implicite standard escludere specificamente le conversioni implicite definite dall'utente.</span><span class="sxs-lookup"><span data-stu-id="3b24a-415">The standard implicit conversions specifically exclude user-defined implicit conversions.</span></span>

### <a name="standard-explicit-conversions"></a><span data-ttu-id="3b24a-416">Conversioni esplicite standard</span><span class="sxs-lookup"><span data-stu-id="3b24a-416">Standard explicit conversions</span></span>

<span data-ttu-id="3b24a-417">Le conversioni esplicite standard sono tutte le conversioni implicite standard oltre il subset di conversioni esplicite per il quale esiste una conversione implicita standard opposta.</span><span class="sxs-lookup"><span data-stu-id="3b24a-417">The standard explicit conversions are all standard implicit conversions plus the subset of the explicit conversions for which an opposite standard implicit conversion exists.</span></span> <span data-ttu-id="3b24a-418">In altre parole, se uno standard implicito non esiste conversione da un tipo `A` a un tipo `B`, quindi esiste una conversione esplicita standard dal tipo `A` per digitare `B` e dal tipo `B` al tipo `A`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-418">In other words, if a standard implicit conversion exists from a type `A` to a type `B`, then a standard explicit conversion exists from type `A` to type `B` and from type `B` to type `A`.</span></span>

## <a name="user-defined-conversions"></a><span data-ttu-id="3b24a-419">Conversioni definite dall'utente</span><span class="sxs-lookup"><span data-stu-id="3b24a-419">User-defined conversions</span></span>

<span data-ttu-id="3b24a-420">C# consente le conversioni implicite ed esplicite predefinite essere integrati con ***conversioni definite dall'utente***.</span><span class="sxs-lookup"><span data-stu-id="3b24a-420">C# allows the pre-defined implicit and explicit conversions to be augmented by ***user-defined conversions***.</span></span> <span data-ttu-id="3b24a-421">Conversioni definite dall'utente vengono introdotti con la dichiarazione di operatori di conversione ([gli operatori di conversione](classes.md#conversion-operators)) nei tipi di classi e struct.</span><span class="sxs-lookup"><span data-stu-id="3b24a-421">User-defined conversions are introduced by declaring conversion operators ([Conversion operators](classes.md#conversion-operators)) in class and struct types.</span></span>

### <a name="permitted-user-defined-conversions"></a><span data-ttu-id="3b24a-422">Consentite conversioni definite dall'utente</span><span class="sxs-lookup"><span data-stu-id="3b24a-422">Permitted user-defined conversions</span></span>

<span data-ttu-id="3b24a-423">C# consente solo alcune conversioni definite dall'utente da dichiarare.</span><span class="sxs-lookup"><span data-stu-id="3b24a-423">C# permits only certain user-defined conversions to be declared.</span></span> <span data-ttu-id="3b24a-424">In particolare, non è possibile ridefinire una conversione implicita o esplicita già esistente.</span><span class="sxs-lookup"><span data-stu-id="3b24a-424">In particular, it is not possible to redefine an already existing implicit or explicit conversion.</span></span>

<span data-ttu-id="3b24a-425">Per un tipo di origine specificato `S` e tipo di destinazione `T`, se `S` oppure `T` sono i tipi nullable, consentire `S0` e `T0` fanno riferimento ai tipi sottostanti, in caso contrario `S0` e `T0` sono uguale a `S` e `T` rispettivamente.</span><span class="sxs-lookup"><span data-stu-id="3b24a-425">For a given source type `S` and target type `T`, if `S` or `T` are nullable types, let `S0` and `T0` refer to their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span> <span data-ttu-id="3b24a-426">Una classe o struct è possibile dichiarare una conversione da un tipo di origine `S` a un tipo di destinazione `T` solo se tutte le operazioni seguenti sono vere:</span><span class="sxs-lookup"><span data-stu-id="3b24a-426">A class or struct is permitted to declare a conversion from a source type `S` to a target type `T` only if all of the following are true:</span></span>

*  <span data-ttu-id="3b24a-427">`S0` e `T0` sono tipi diversi.</span><span class="sxs-lookup"><span data-stu-id="3b24a-427">`S0` and `T0` are different types.</span></span>
*  <span data-ttu-id="3b24a-428">Sia `S0` o `T0` è il tipo di classe o struct in cui viene eseguita la dichiarazione di operatore.</span><span class="sxs-lookup"><span data-stu-id="3b24a-428">Either `S0` or `T0` is the class or struct type in which the operator declaration takes place.</span></span>
*  <span data-ttu-id="3b24a-429">Né `S0` né `T0` è un *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="3b24a-429">Neither `S0` nor `T0` is an *interface_type*.</span></span>
*  <span data-ttu-id="3b24a-430">Escludendo le conversioni definite dall'utente, che non esiste una conversione da `S` al `T` o da `T` a `S`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-430">Excluding user-defined conversions, a conversion does not exist from `S` to `T` or from `T` to `S`.</span></span>

<span data-ttu-id="3b24a-431">Le restrizioni relative alle conversioni definite dall'utente sono illustrate dettagliatamente nella [gli operatori di conversione](classes.md#conversion-operators).</span><span class="sxs-lookup"><span data-stu-id="3b24a-431">The restrictions that apply to user-defined conversions are discussed further in [Conversion operators](classes.md#conversion-operators).</span></span>

### <a name="lifted-conversion-operators"></a><span data-ttu-id="3b24a-432">Operatori di conversione elevata</span><span class="sxs-lookup"><span data-stu-id="3b24a-432">Lifted conversion operators</span></span>

<span data-ttu-id="3b24a-433">Dato un operatore di conversione definita dall'utente che esegue la conversione da un tipo di valore non nullable `S` a un tipo di valore non nullable `T`, un ***operatore di conversione è elevato*** esiste che converte da `S?` alla `T?`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-433">Given a user-defined conversion operator that converts from a non-nullable value type `S` to a non-nullable value type `T`, a ***lifted conversion operator*** exists that converts from `S?` to `T?`.</span></span> <span data-ttu-id="3b24a-434">Questo operatore di conversione lift esegue un annullamento del wrapping da `S?` al `S` seguita dalla conversione definita dall'utente da `S` al `T` seguita da un ritorno a capo da `T` a `T?`, ad eccezione del fatto che un valore null Valued `S?` viene convertito direttamente in un valore null con valori di `T?`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-434">This lifted conversion operator performs an unwrapping from `S?` to `S` followed by the user-defined conversion from `S` to `T` followed by a wrapping from `T` to `T?`, except that a null valued `S?` converts directly to a null valued `T?`.</span></span>

<span data-ttu-id="3b24a-435">Un operatore di conversione lift ha la stessa classificazione implicita o esplicita come proprio operatore di conversione definita dall'utente sottostante.</span><span class="sxs-lookup"><span data-stu-id="3b24a-435">A lifted conversion operator has the same implicit or explicit classification as its underlying user-defined conversion operator.</span></span> <span data-ttu-id="3b24a-436">Il termine "conversione definita dall'utente" si applica all'utilizzo di entrambi gli operatori di conversione è elevato e definite dall'utente.</span><span class="sxs-lookup"><span data-stu-id="3b24a-436">The term "user-defined conversion" applies to the use of both user-defined and lifted conversion operators.</span></span>

### <a name="evaluation-of-user-defined-conversions"></a><span data-ttu-id="3b24a-437">Valutazione delle conversioni definite dall'utente</span><span class="sxs-lookup"><span data-stu-id="3b24a-437">Evaluation of user-defined conversions</span></span>

<span data-ttu-id="3b24a-438">Una conversione definita dall'utente consente di convertire un valore dal relativo tipo, denominato il ***tipo di origine***, a un altro tipo, chiamato il ***tipo di destinazione***.</span><span class="sxs-lookup"><span data-stu-id="3b24a-438">A user-defined conversion converts a value from its type, called the ***source type***, to another type, called the ***target type***.</span></span> <span data-ttu-id="3b24a-439">Interfacce di valutazione di una conversione definita dall'utente su come trovare i ***più specifica*** operatore di conversione definita dall'utente per i tipi di origine e destinazione particolari.</span><span class="sxs-lookup"><span data-stu-id="3b24a-439">Evaluation of a user-defined conversion centers on finding the ***most specific*** user-defined conversion operator for the particular source and target types.</span></span> <span data-ttu-id="3b24a-440">Questo aspetto è suddiviso in diversi passaggi:</span><span class="sxs-lookup"><span data-stu-id="3b24a-440">This determination is broken into several steps:</span></span>

*  <span data-ttu-id="3b24a-441">Trovare il set di classi e struct da cui gli operatori di conversione definita dall'utente verranno considerati.</span><span class="sxs-lookup"><span data-stu-id="3b24a-441">Finding the set of classes and structs from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="3b24a-442">Questo set include il tipo di origine e le relative classi base e il tipo di destinazione e le relative classi base (con il presupposto che solo le classi e struct possono dichiarare gli operatori definiti dall'utente, e che i tipi non classe presentano classi base).</span><span class="sxs-lookup"><span data-stu-id="3b24a-442">This set consists of the source type and its base classes and the target type and its base classes (with the implicit assumptions that only classes and structs can declare user-defined operators, and that non-class types have no base classes).</span></span> <span data-ttu-id="3b24a-443">Ai fini di questo passaggio, se il tipo di origine o di destinazione è un *nullable_type*, il tipo sottostante viene invece usato.</span><span class="sxs-lookup"><span data-stu-id="3b24a-443">For the purposes of this step, if either the source or target type is a *nullable_type*, their underlying type is used instead.</span></span>
*  <span data-ttu-id="3b24a-444">Da tale set di tipi, sono applicabili per determinare quale definite dall'utente e gli operatori di conversione è elevato.</span><span class="sxs-lookup"><span data-stu-id="3b24a-444">From that set of types, determining which user-defined and lifted conversion operators are applicable.</span></span> <span data-ttu-id="3b24a-445">Per un operatore di conversione sia applicabile, deve essere possibile eseguire una conversione standard ([conversioni Standard](conversions.md#standard-conversions)) dal tipo di origine all'operando di tipo di operatore che deve essere possibile eseguire una conversione standard del tipo di risultato dell'operatore a cui il tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-445">For a conversion operator to be applicable, it must be possible to perform a standard conversion ([Standard conversions](conversions.md#standard-conversions)) from the source type to the operand type of the operator, and it must be possible to perform a standard conversion from the result type of the operator to the target type.</span></span>
*  <span data-ttu-id="3b24a-446">Dal set di operatori definiti dall'utente applicabili, individuazione dell'operatore in modo non ambiguo di più specifico.</span><span class="sxs-lookup"><span data-stu-id="3b24a-446">From the set of applicable user-defined operators, determining which operator is unambiguously the most specific.</span></span> <span data-ttu-id="3b24a-447">In termini generali, l'operatore più specifico è l'operatore il cui tipo di operando "più vicino" al tipo di origine e il cui tipo di risultato è "più vicino" al tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-447">In general terms, the most specific operator is the operator whose operand type is "closest" to the source type and whose result type is "closest" to the target type.</span></span> <span data-ttu-id="3b24a-448">Gli operatori di conversione definita dall'utente sono preferibili rispetto agli operatori di conversione elevata.</span><span class="sxs-lookup"><span data-stu-id="3b24a-448">User-defined conversion operators are preferred over lifted conversion operators.</span></span> <span data-ttu-id="3b24a-449">Nelle sezioni seguenti sono definite esattamente le regole per la definizione dell'operatore di conversione definita dall'utente più specifico.</span><span class="sxs-lookup"><span data-stu-id="3b24a-449">The exact rules for establishing the most specific user-defined conversion operator are defined in the following sections.</span></span>

<span data-ttu-id="3b24a-450">Dopo aver identificato un operatore di conversione definita dall'utente più specifico, l'esecuzione effettiva della conversione definita dall'utente include fino a tre passaggi:</span><span class="sxs-lookup"><span data-stu-id="3b24a-450">Once a most specific user-defined conversion operator has been identified, the actual execution of the user-defined conversion involves up to three steps:</span></span>

*  <span data-ttu-id="3b24a-451">In primo luogo, se necessario, eseguire una conversione standard dal tipo di origine al tipo di operando dell'operatore di conversione definita dall'utente o elevata.</span><span class="sxs-lookup"><span data-stu-id="3b24a-451">First, if required, performing a standard conversion from the source type to the operand type of the user-defined or lifted conversion operator.</span></span>
*  <span data-ttu-id="3b24a-452">Successivamente, richiamando l'operatore di conversione definita dall'utente o elevata per eseguire la conversione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-452">Next, invoking the user-defined or lifted conversion operator to perform the conversion.</span></span>
*  <span data-ttu-id="3b24a-453">Infine, se necessario, eseguire una conversione standard dal tipo di risultato dell'operatore di conversione definita dall'utente o lift per il tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-453">Finally, if required, performing a standard conversion from the result type of the user-defined or lifted conversion operator to the target type.</span></span>

<span data-ttu-id="3b24a-454">Valutazione di una conversione definita dall'utente non comporta più di un operatore di conversione definita dall'utente o elevata.</span><span class="sxs-lookup"><span data-stu-id="3b24a-454">Evaluation of a user-defined conversion never involves more than one user-defined or lifted conversion operator.</span></span> <span data-ttu-id="3b24a-455">In altre parole, una conversione dal tipo `S` al tipo `T` mai prima di tutto verrà eseguita una conversione definita dall'utente da `S` al `X` e quindi eseguire una conversione definita dall'utente da `X` a `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-455">In other words, a conversion from type `S` to type `T` will never first execute a user-defined conversion from `S` to `X` and then execute a user-defined conversion from `X` to `T`.</span></span>

<span data-ttu-id="3b24a-456">Le definizioni esatte di valutazione delle conversioni implicite o esplicite definite dall'utente vengono fornite nelle sezioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="3b24a-456">Exact definitions of evaluation of user-defined implicit or explicit conversions are given in the following sections.</span></span> <span data-ttu-id="3b24a-457">Apportare le definizioni di utilizzare le seguenti condizioni:</span><span class="sxs-lookup"><span data-stu-id="3b24a-457">The definitions make use of the following terms:</span></span>

*  <span data-ttu-id="3b24a-458">Se la conversione implicita standard ([conversioni implicite](conversions.md#standard-implicit-conversions)) esistente da un tipo `A` a un tipo `B`e se nessuno di essi `A` né `B` sono *interface_type*s, quindi `A` è detto ***incluse nel*** `B`, e `B` è detto ***encompass*** `A`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-458">If a standard implicit conversion ([Standard implicit conversions](conversions.md#standard-implicit-conversions)) exists from a type `A` to a type `B`, and if neither `A` nor `B` are *interface_type*s, then `A` is said to be ***encompassed by*** `B`, and `B` is said to ***encompass*** `A`.</span></span>
*  <span data-ttu-id="3b24a-459">Il ***tipo più inclusivo*** in un set di tipi è il tipo che comprende tutti gli altri tipi nel set.</span><span class="sxs-lookup"><span data-stu-id="3b24a-459">The ***most encompassing type*** in a set of types is the one type that encompasses all other types in the set.</span></span> <span data-ttu-id="3b24a-460">Se nessun singolo tipo comprende tutti gli altri tipi, il set non dispone di alcun tipo di portata più ampia.</span><span class="sxs-lookup"><span data-stu-id="3b24a-460">If no single type encompasses all other types, then the set has no most encompassing type.</span></span> <span data-ttu-id="3b24a-461">In altre parole, il tipo più inclusivo è il tipo "massimo" nel set, ovvero il tipo in cui ciascuno degli altri tipi può essere convertito in modo implicito.</span><span class="sxs-lookup"><span data-stu-id="3b24a-461">In more intuitive terms, the most encompassing type is the "largest" type in the set—the one type to which each of the other types can be implicitly converted.</span></span>
*  <span data-ttu-id="3b24a-462">Il ***tipo maggiormente*** in un set di tipi è il tipo incluso in tutti gli altri tipi nel set.</span><span class="sxs-lookup"><span data-stu-id="3b24a-462">The ***most encompassed type*** in a set of types is the one type that is encompassed by all other types in the set.</span></span> <span data-ttu-id="3b24a-463">Se nessun singolo tipo incluso in tutti gli altri tipi, quindi il set non presenta maggiormente tipo.</span><span class="sxs-lookup"><span data-stu-id="3b24a-463">If no single type is encompassed by all other types, then the set has no most encompassed type.</span></span> <span data-ttu-id="3b24a-464">In altre parole, il tipo maggiormente è il tipo "minimo" nel set, ovvero il tipo che può essere convertito in modo implicito in ognuno degli altri tipi.</span><span class="sxs-lookup"><span data-stu-id="3b24a-464">In more intuitive terms, the most encompassed type is the "smallest" type in the set—the one type that can be implicitly converted to each of the other types.</span></span>

### <a name="processing-of-user-defined-implicit-conversions"></a><span data-ttu-id="3b24a-465">Elaborazione delle conversioni implicite definite dall'utente</span><span class="sxs-lookup"><span data-stu-id="3b24a-465">Processing of user-defined implicit conversions</span></span>

<span data-ttu-id="3b24a-466">Una conversione implicita dal tipo definito dall'utente `S` al tipo `T` viene elaborato come segue:</span><span class="sxs-lookup"><span data-stu-id="3b24a-466">A user-defined implicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="3b24a-467">Determinare i tipi `S0` e `T0`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-467">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="3b24a-468">Se `S` oppure `T` sono tipi nullable, `S0` e `T0` sono i tipi sottostanti, in caso contrario `S0` e `T0` sono uguali a `S` e `T` rispettivamente.</span><span class="sxs-lookup"><span data-stu-id="3b24a-468">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="3b24a-469">Trovare il set di tipi, `D`, da quali conversione definita dall'utente verranno considerati operatori.</span><span class="sxs-lookup"><span data-stu-id="3b24a-469">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="3b24a-470">Questo set è costituito `S0` (se `S0` è una classe o struct), le classi di base di `S0` (se `S0` è una classe), e `T0` (se `T0` è una classe o struct).</span><span class="sxs-lookup"><span data-stu-id="3b24a-470">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), and `T0` (if `T0` is a class or struct).</span></span>
*  <span data-ttu-id="3b24a-471">Trovare il set di operatori di conversione definita dall'utente e lift applicabili `U`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-471">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="3b24a-472">Questo set è costituito dagli operatori di conversione implicita definite dall'utente e lift dichiarati nelle classi o struct in `D` che esegue la conversione da un tipo che include `S` a un tipo incluso in `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-472">This set consists of the user-defined and lifted implicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing `S` to a type encompassed by `T`.</span></span> <span data-ttu-id="3b24a-473">Se `U` è vuoto, la conversione è indefinita e si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-473">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="3b24a-474">Trovare il tipo di origine più specifico `SX`, degli operatori in `U`:</span><span class="sxs-lookup"><span data-stu-id="3b24a-474">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="3b24a-475">Se uno qualsiasi degli operatori in `U` convertire `S`, quindi `SX` è `S`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-475">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="3b24a-476">In caso contrario, `SX` è il tipo maggiormente nel set combinato dei tipi di origine degli operatori in `U`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-476">Otherwise, `SX` is the most encompassed type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="3b24a-477">Se esattamente uno maggiormente tipo non viene trovato, quindi la conversione è ambigua e si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-477">If exactly one most encompassed type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="3b24a-478">Trovare il tipo di destinazione più specifico `TX`, degli operatori in `U`:</span><span class="sxs-lookup"><span data-stu-id="3b24a-478">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="3b24a-479">Se uno qualsiasi degli operatori in `U` convertire `T`, quindi `TX` è `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-479">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="3b24a-480">In caso contrario, `TX` è il tipo più inclusivo nel set combinato dei tipi di destinazione degli operatori in `U`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-480">Otherwise, `TX` is the most encompassing type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="3b24a-481">Se non viene trovato un tipo più inclusivo, quindi la conversione è ambigua e si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-481">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="3b24a-482">Trovare l'operatore di conversione più specifico:</span><span class="sxs-lookup"><span data-stu-id="3b24a-482">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="3b24a-483">Se `U` contiene esattamente un operatore di conversione definita dall'utente che esegue la conversione da `SX` a `TX`, il valore è l'operatore di conversione più specifico.</span><span class="sxs-lookup"><span data-stu-id="3b24a-483">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="3b24a-484">In caso contrario, se `U` contiene esattamente un operatore di conversione elevata che consente di conversione `SX` a `TX`, il valore è l'operatore di conversione più specifico.</span><span class="sxs-lookup"><span data-stu-id="3b24a-484">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="3b24a-485">In caso contrario, la conversione è ambigua e si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-485">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="3b24a-486">Infine, applicare la conversione:</span><span class="sxs-lookup"><span data-stu-id="3b24a-486">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="3b24a-487">Se `S` non è `SX`, quindi è una conversione implicita standard da `S` a `SX` viene eseguita.</span><span class="sxs-lookup"><span data-stu-id="3b24a-487">If `S` is not `SX`, then a standard implicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="3b24a-488">L'operatore di conversione più specifico viene richiamata per convertire `SX` a `TX`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-488">The most specific conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="3b24a-489">Se `TX` non è `T`, quindi è una conversione implicita standard da `TX` a `T` viene eseguita.</span><span class="sxs-lookup"><span data-stu-id="3b24a-489">If `TX` is not `T`, then a standard implicit conversion from `TX` to `T` is performed.</span></span>

### <a name="processing-of-user-defined-explicit-conversions"></a><span data-ttu-id="3b24a-490">Elaborazione di conversioni esplicite definite dall'utente</span><span class="sxs-lookup"><span data-stu-id="3b24a-490">Processing of user-defined explicit conversions</span></span>

<span data-ttu-id="3b24a-491">Una conversione esplicita dal tipo definito dall'utente `S` al tipo `T` viene elaborato come segue:</span><span class="sxs-lookup"><span data-stu-id="3b24a-491">A user-defined explicit conversion from type `S` to type `T` is processed as follows:</span></span>

*  <span data-ttu-id="3b24a-492">Determinare i tipi `S0` e `T0`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-492">Determine the types `S0` and `T0`.</span></span> <span data-ttu-id="3b24a-493">Se `S` oppure `T` sono tipi nullable, `S0` e `T0` sono i tipi sottostanti, in caso contrario `S0` e `T0` sono uguali a `S` e `T` rispettivamente.</span><span class="sxs-lookup"><span data-stu-id="3b24a-493">If `S` or `T` are nullable types, `S0` and `T0` are their underlying types, otherwise `S0` and `T0` are equal to `S` and `T` respectively.</span></span>
*  <span data-ttu-id="3b24a-494">Trovare il set di tipi, `D`, da quali conversione definita dall'utente verranno considerati operatori.</span><span class="sxs-lookup"><span data-stu-id="3b24a-494">Find the set of types, `D`, from which user-defined conversion operators will be considered.</span></span> <span data-ttu-id="3b24a-495">Questo set è costituito `S0` (se `S0` è una classe o struct), le classi di base di `S0` (se `S0` è una classe), `T0` (se `T0` è una classe o struct) e le classi di base di `T0` (se `T0`è una classe).</span><span class="sxs-lookup"><span data-stu-id="3b24a-495">This set consists of `S0` (if `S0` is a class or struct), the base classes of `S0` (if `S0` is a class), `T0` (if `T0` is a class or struct), and the base classes of `T0` (if `T0` is a class).</span></span>
*  <span data-ttu-id="3b24a-496">Trovare il set di operatori di conversione definita dall'utente e lift applicabili `U`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-496">Find the set of applicable user-defined and lifted conversion operators, `U`.</span></span> <span data-ttu-id="3b24a-497">Questo set è costituita dall'utente e lift implicita o operatori di conversione espliciti dichiarate nelle classi o struct in `D` cui eseguire la conversione da un tipo che include o è incluso in `S` a un tipo che comprende o è incluso in `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-497">This set consists of the user-defined and lifted implicit or explicit conversion operators declared by the classes or structs in `D` that convert from a type encompassing or encompassed by `S` to a type encompassing or encompassed by `T`.</span></span> <span data-ttu-id="3b24a-498">Se `U` è vuoto, la conversione è indefinita e si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-498">If `U` is empty, the conversion is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="3b24a-499">Trovare il tipo di origine più specifico `SX`, degli operatori in `U`:</span><span class="sxs-lookup"><span data-stu-id="3b24a-499">Find the most specific source type, `SX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="3b24a-500">Se uno qualsiasi degli operatori in `U` convertire `S`, quindi `SX` è `S`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-500">If any of the operators in `U` convert from `S`, then `SX` is `S`.</span></span>
    * <span data-ttu-id="3b24a-501">In caso contrario, se uno qualsiasi degli operatori in `U` eseguire la conversione da tipi che includono `S`, quindi `SX` è il tipo maggiormente nel set combinato dei tipi di origine di tali operatori.</span><span class="sxs-lookup"><span data-stu-id="3b24a-501">Otherwise, if any of the operators in `U` convert from types that encompass `S`, then `SX` is the most encompassed type in the combined set of source types of those operators.</span></span> <span data-ttu-id="3b24a-502">Se nessun maggiormente tipo possa essere disponibile, quindi la conversione è ambigua e si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-502">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="3b24a-503">In caso contrario, `SX` è il tipo più inclusivo nel set combinato dei tipi di origine degli operatori in `U`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-503">Otherwise, `SX` is the most encompassing type in the combined set of source types of the operators in `U`.</span></span> <span data-ttu-id="3b24a-504">Se non viene trovato un tipo più inclusivo, quindi la conversione è ambigua e si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-504">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="3b24a-505">Trovare il tipo di destinazione più specifico `TX`, degli operatori in `U`:</span><span class="sxs-lookup"><span data-stu-id="3b24a-505">Find the most specific target type, `TX`, of the operators in `U`:</span></span>
    * <span data-ttu-id="3b24a-506">Se uno qualsiasi degli operatori in `U` convertire `T`, quindi `TX` è `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-506">If any of the operators in `U` convert to `T`, then `TX` is `T`.</span></span>
    * <span data-ttu-id="3b24a-507">In caso contrario, se uno qualsiasi degli operatori in `U` convertire tipi che sono inclusi `T`, quindi `TX` è il tipo più inclusivo nel set combinato dei tipi di destinazione di tali operatori.</span><span class="sxs-lookup"><span data-stu-id="3b24a-507">Otherwise, if any of the operators in `U` convert to types that are encompassed by `T`, then `TX` is the most encompassing type in the combined set of target types of those operators.</span></span> <span data-ttu-id="3b24a-508">Se non viene trovato un tipo più inclusivo, quindi la conversione è ambigua e si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-508">If exactly one most encompassing type cannot be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
    * <span data-ttu-id="3b24a-509">In caso contrario, `TX` è il tipo maggiormente nel set combinato dei tipi di destinazione degli operatori in `U`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-509">Otherwise, `TX` is the most encompassed type in the combined set of target types of the operators in `U`.</span></span> <span data-ttu-id="3b24a-510">Se nessun maggiormente tipo possa essere disponibile, quindi la conversione è ambigua e si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-510">If no most encompassed type can be found, then the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="3b24a-511">Trovare l'operatore di conversione più specifico:</span><span class="sxs-lookup"><span data-stu-id="3b24a-511">Find the most specific conversion operator:</span></span>
    * <span data-ttu-id="3b24a-512">Se `U` contiene esattamente un operatore di conversione definita dall'utente che esegue la conversione da `SX` a `TX`, il valore è l'operatore di conversione più specifico.</span><span class="sxs-lookup"><span data-stu-id="3b24a-512">If `U` contains exactly one user-defined conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="3b24a-513">In caso contrario, se `U` contiene esattamente un operatore di conversione elevata che consente di conversione `SX` a `TX`, il valore è l'operatore di conversione più specifico.</span><span class="sxs-lookup"><span data-stu-id="3b24a-513">Otherwise, if `U` contains exactly one lifted conversion operator that converts from `SX` to `TX`, then this is the most specific conversion operator.</span></span>
    * <span data-ttu-id="3b24a-514">In caso contrario, la conversione è ambigua e si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-514">Otherwise, the conversion is ambiguous and a compile-time error occurs.</span></span>
*  <span data-ttu-id="3b24a-515">Infine, applicare la conversione:</span><span class="sxs-lookup"><span data-stu-id="3b24a-515">Finally, apply the conversion:</span></span>
    * <span data-ttu-id="3b24a-516">Se `S` non è `SX`, quindi una conversione standard esplicita da `S` a `SX` viene eseguita.</span><span class="sxs-lookup"><span data-stu-id="3b24a-516">If `S` is not `SX`, then a standard explicit conversion from `S` to `SX` is performed.</span></span>
    * <span data-ttu-id="3b24a-517">L'operatore di conversione definita dall'utente più specifico viene richiamata per convertire `SX` a `TX`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-517">The most specific user-defined conversion operator is invoked to convert from `SX` to `TX`.</span></span>
    * <span data-ttu-id="3b24a-518">Se `TX` non è `T`, quindi una conversione standard esplicita da `TX` a `T` viene eseguita.</span><span class="sxs-lookup"><span data-stu-id="3b24a-518">If `TX` is not `T`, then a standard explicit conversion from `TX` to `T` is performed.</span></span>

## <a name="anonymous-function-conversions"></a><span data-ttu-id="3b24a-519">Conversioni delle funzioni anonime</span><span class="sxs-lookup"><span data-stu-id="3b24a-519">Anonymous function conversions</span></span>

<span data-ttu-id="3b24a-520">Un' *anonymous_method_expression* oppure *lambda_expression* viene classificato come una funzione anonima ([espressioni di funzioni anonime](expressions.md#anonymous-function-expressions)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-520">An *anonymous_method_expression* or *lambda_expression* is classified as an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)).</span></span> <span data-ttu-id="3b24a-521">L'espressione non dispone di un tipo ma può essere convertito in modo implicito in un tipo delegato compatibile o un tipo di albero delle espressioni.</span><span class="sxs-lookup"><span data-stu-id="3b24a-521">The expression does not have a type but can be implicitly converted to a compatible delegate type or expression tree type.</span></span> <span data-ttu-id="3b24a-522">In particolare, una funzione anonima `F` è compatibile con un tipo delegato `D` fornito:</span><span class="sxs-lookup"><span data-stu-id="3b24a-522">Specifically, an anonymous function `F` is compatible with a delegate type `D` provided:</span></span>

*  <span data-ttu-id="3b24a-523">Se `F` contiene un *anonymous_function_signature*, quindi `D` e `F` hanno lo stesso numero di parametri.</span><span class="sxs-lookup"><span data-stu-id="3b24a-523">If `F` contains an *anonymous_function_signature*, then `D` and `F` have the same number of parameters.</span></span>
*  <span data-ttu-id="3b24a-524">Se `F` non contiene un *anonymous_function_signature*, quindi `D` può avere zero o più parametri di qualsiasi tipo, purché nessun parametro con `D` ha la `out` modificatore di parametro.</span><span class="sxs-lookup"><span data-stu-id="3b24a-524">If `F` does not contain an *anonymous_function_signature*, then `D` may have zero or more parameters of any type, as long as no parameter of `D` has the `out` parameter modifier.</span></span>
*  <span data-ttu-id="3b24a-525">Se `F` presenta un elenco di parametri tipizzati in modo esplicito, ogni parametro nel `D` ha lo stesso tipo e modificatori del parametro corrispondente nel `F`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-525">If `F` has an explicitly typed parameter list, each parameter in `D` has the same type and modifiers as the corresponding parameter in `F`.</span></span>
*  <span data-ttu-id="3b24a-526">Se `F` è un elenco di un parametro tipizzato in modo implicito `D` non ha alcun `ref` o `out` parametri.</span><span class="sxs-lookup"><span data-stu-id="3b24a-526">If `F` has an implicitly typed parameter list, `D` has no `ref` or `out` parameters.</span></span>
*  <span data-ttu-id="3b24a-527">Se il corpo della `F` è un'espressione e `D` ha una `void` tipo restituito o `F` è asincrono e `D` presenta il tipo restituito `Task`, quindi quando ogni parametro di `F` viene assegnato il tipo del parametro corrispondente nel `D`, il corpo del `F` è un'espressione valida (wrt [espressioni](expressions.md)) che potrebbe essere consentito, come un *statement_expression* ([Istruzioni di espressione](statements.md#expression-statements)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-527">If the body of `F` is an expression, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that would be permitted as a *statement_expression* ([Expression statements](statements.md#expression-statements)).</span></span>
*  <span data-ttu-id="3b24a-528">Se il corpo della `F` è un blocco di istruzioni e `D` ha una `void` tipo restituito o `F` è asincrono e `D` presenta il tipo restituito `Task`, quindi quando ogni parametro di `F` viene assegnato il tipo di il parametro corrispondente nel `D`, il corpo del `F` è un blocco di istruzioni valido (wrt [blocchi](statements.md#blocks)) in cui nessun `return` istruzione specifica un'espressione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-528">If the body of `F` is a statement block, and either `D` has a `void` return type or `F` is async and `D` has the return type `Task`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) in which no `return` statement specifies an expression.</span></span>
*  <span data-ttu-id="3b24a-529">Se il corpo della `F` è un'espressione, e *entrambi* `F` è non asincrone e `D` presenta un tipo restituito non void `T`, *oppure* `F` è asincrono e `D` ha un tipo restituito `Task<T>`, quindi quando ogni parametro dello `F` viene assegnato il tipo del parametro corrispondente nel `D`, il corpo della `F` è un'espressione valida (wrt [ Le espressioni](expressions.md)) che è implicitamente convertibile in `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-529">If the body of `F` is an expression, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid expression (wrt [Expressions](expressions.md)) that is implicitly convertible to `T`.</span></span>
*  <span data-ttu-id="3b24a-530">Se il corpo della `F` è un blocco di istruzioni, e *entrambi* `F` è non asincrone e `D` presenta un tipo restituito non void `T`, *oppure* `F` è asincrono e `D` ha un tipo restituito `Task<T>`, quindi quando ogni parametro del `F` viene assegnato il tipo del parametro corrispondente nella `D`, il corpo della `F` è un blocco di istruzioni valido (wrt [blocchi ](statements.md#blocks)) con un punto di fine non raggiungibile in cui ciascun `return` istruzione specifica un'espressione che è implicitamente convertibile in `T`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-530">If the body of `F` is a statement block, and *either* `F` is non-async and `D` has a non-void return type `T`, *or* `F` is async and `D` has a return type `Task<T>`, then when each parameter of `F` is given the type of the corresponding parameter in `D`, the body of `F` is a valid statement block (wrt [Blocks](statements.md#blocks)) with a non-reachable end point in which each `return` statement specifies an expression that is implicitly convertible to `T`.</span></span>

<span data-ttu-id="3b24a-531">Ai fini della brevità, in questa sezione Usa la versione abbreviata per i tipi di attività `Task` e `Task<T>` ([funzioni asincrone](classes.md#async-functions)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-531">For the purpose of brevity, this section uses the short form for the task types `Task` and `Task<T>` ([Async functions](classes.md#async-functions)).</span></span>

<span data-ttu-id="3b24a-532">Un'espressione lambda `F` è compatibile con un tipo di albero delle espressioni `Expression<D>` se `F` compatibile con il tipo di delegato `D`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-532">A lambda expression `F` is compatible with an expression tree type `Expression<D>` if `F` is compatible with the delegate type `D`.</span></span> <span data-ttu-id="3b24a-533">Si noti che questo non è applicabile ai metodi anonimi, solo le espressioni lambda.</span><span class="sxs-lookup"><span data-stu-id="3b24a-533">Note that this does not apply to anonymous methods, only lambda expressions.</span></span>

<span data-ttu-id="3b24a-534">Alcune espressioni lambda non possono essere convertiti in tipi di albero delle espressioni: Anche se la conversione *esiste*, ha esito negativo in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-534">Certain lambda expressions cannot be converted to expression tree types: Even though the conversion *exists*, it fails at compile-time.</span></span> <span data-ttu-id="3b24a-535">Ciò si verifica quando l'espressione lambda:</span><span class="sxs-lookup"><span data-stu-id="3b24a-535">This is the case if the lambda expression:</span></span>

*  <span data-ttu-id="3b24a-536">È un *blocco* corpo</span><span class="sxs-lookup"><span data-stu-id="3b24a-536">Has a *block* body</span></span>
*  <span data-ttu-id="3b24a-537">Contiene gli operatori di assegnazione semplice o composta</span><span class="sxs-lookup"><span data-stu-id="3b24a-537">Contains simple or compound assignment operators</span></span>
*  <span data-ttu-id="3b24a-538">Contiene un'espressione MDX associata in modo dinamico</span><span class="sxs-lookup"><span data-stu-id="3b24a-538">Contains a dynamically bound expression</span></span>
*  <span data-ttu-id="3b24a-539">È asincrono</span><span class="sxs-lookup"><span data-stu-id="3b24a-539">Is async</span></span>

<span data-ttu-id="3b24a-540">Gli esempi seguenti usano un tipo delegato generico `Func<A,R>` che rappresenta una funzione che accetta un argomento di tipo `A` e restituisce un valore di tipo `R`:</span><span class="sxs-lookup"><span data-stu-id="3b24a-540">The examples that follow use a generic delegate type `Func<A,R>` which represents a function that takes an argument of type `A` and returns a value of type `R`:</span></span>
```csharp
delegate R Func<A,R>(A arg);
```

<span data-ttu-id="3b24a-541">Nelle assegnazioni</span><span class="sxs-lookup"><span data-stu-id="3b24a-541">In the assignments</span></span>
```csharp
Func<int,int> f1 = x => x + 1;                 // Ok

Func<int,double> f2 = x => x + 1;              // Ok

Func<double,int> f3 = x => x + 1;              // Error

Func<int, Task<int>> f4 = async x => x + 1;    // Ok
```
<span data-ttu-id="3b24a-542">il parametro e tipo restituito di ogni funzione anonima dipendono dal tipo della variabile a cui è assegnata alla funzione anonima.</span><span class="sxs-lookup"><span data-stu-id="3b24a-542">the parameter and return types of each anonymous function are determined from the type of the variable to which the anonymous function is assigned.</span></span>

<span data-ttu-id="3b24a-543">La prima assegnazione converte correttamente la funzione anonima per il tipo delegato `Func<int,int>` perché, quando `x` è di tipo dato `int`, `x+1` è un'espressione valida che è implicitamente convertibile nel tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-543">The first assignment successfully converts the anonymous function to the delegate type `Func<int,int>` because, when `x` is given type `int`, `x+1` is a valid expression that is implicitly convertible to type `int`.</span></span>

<span data-ttu-id="3b24a-544">Analogamente, la seconda assegnazione converte correttamente la funzione anonima per il tipo delegato `Func<int,double>` perché il risultato del `x+1` (di tipo `int`) è implicitamente convertibile nel tipo `double`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-544">Likewise, the second assignment successfully converts the anonymous function to the delegate type `Func<int,double>` because the result of `x+1` (of type `int`) is implicitly convertible to type `double`.</span></span>

<span data-ttu-id="3b24a-545">Tuttavia, l'assegnazione del terzo è un errore in fase di compilazione perché, quando `x` ha tipo `double`, il risultato del `x+1` (di tipo `double`) non è convertibile in modo implicito nel tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-545">However, the third assignment is a compile-time error because, when `x` is given type `double`, the result of `x+1` (of type `double`) is not implicitly convertible to type `int`.</span></span>

<span data-ttu-id="3b24a-546">L'assegnazione del quarto converte correttamente la funzione async anonimi nel tipo delegato `Func<int, Task<int>>` perché il risultato del `x+1` (di tipo `int`) è implicitamente convertibile nel tipo di risultato `int` del tipo di attività `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-546">The fourth assignment successfully converts the anonymous async function to the delegate type `Func<int, Task<int>>` because the result of `x+1` (of type `int`) is implicitly convertible to the result type `int` of the task type `Task<int>`.</span></span>

<span data-ttu-id="3b24a-547">Funzioni anonime possono influenzare la risoluzione dell'overload e partecipare all'inferenza del tipo.</span><span class="sxs-lookup"><span data-stu-id="3b24a-547">Anonymous functions may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="3b24a-548">Visualizzare [membri funzione](expressions.md#function-members) per altri dettagli.</span><span class="sxs-lookup"><span data-stu-id="3b24a-548">See [Function members](expressions.md#function-members) for further details.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-delegate-types"></a><span data-ttu-id="3b24a-549">Valutazione delle conversioni di tipi delegati funzioni anonime</span><span class="sxs-lookup"><span data-stu-id="3b24a-549">Evaluation of anonymous function conversions to delegate types</span></span>

<span data-ttu-id="3b24a-550">Conversione di una funzione anonima in un tipo delegato produce un'istanza di delegato che fa riferimento alla funzione anonima e il set di variabili esterne acquisite che sono attive al momento della valutazione (eventualmente vuoto).</span><span class="sxs-lookup"><span data-stu-id="3b24a-550">Conversion of an anonymous function to a delegate type produces a delegate instance which references the anonymous function and the (possibly empty) set of captured outer variables that are active at the time of the evaluation.</span></span> <span data-ttu-id="3b24a-551">Quando il delegato viene richiamato, il corpo della funzione anonima viene eseguito.</span><span class="sxs-lookup"><span data-stu-id="3b24a-551">When the delegate is invoked, the body of the anonymous function is executed.</span></span> <span data-ttu-id="3b24a-552">Il codice nel corpo viene eseguito utilizzando il set di variabili esterne acquisite fa riferimento il delegato.</span><span class="sxs-lookup"><span data-stu-id="3b24a-552">The code in the body is executed using the set of captured outer variables referenced by the delegate.</span></span>

<span data-ttu-id="3b24a-553">L'elenco chiamate di un delegato generato da una funzione anonima contiene una singola voce.</span><span class="sxs-lookup"><span data-stu-id="3b24a-553">The invocation list of a delegate produced from an anonymous function contains a single entry.</span></span> <span data-ttu-id="3b24a-554">L'oggetto di destinazione e metodo di destinazione del delegato non sono state specificate.</span><span class="sxs-lookup"><span data-stu-id="3b24a-554">The exact target object and target method of the delegate are unspecified.</span></span> <span data-ttu-id="3b24a-555">In particolare, non viene specificato se è l'oggetto di destinazione del delegato `null`, il `this` valore del membro di funzione che lo contiene, o un altro oggetto.</span><span class="sxs-lookup"><span data-stu-id="3b24a-555">In particular, it is unspecified whether the target object of the delegate is `null`, the `this` value of the enclosing function member, or some other object.</span></span>

<span data-ttu-id="3b24a-556">Le conversioni delle funzioni anonime semanticamente identiche con lo stesso set (eventualmente vuota) di istanze di variabili esterne acquisiti per gli stessi tipi di delegato sono consentite (ma non obbligatorio) per restituire la stessa istanza di delegato.</span><span class="sxs-lookup"><span data-stu-id="3b24a-556">Conversions of semantically identical anonymous functions with the same (possibly empty) set of captured outer variable instances to the same delegate types are permitted (but not required) to return the same delegate instance.</span></span> <span data-ttu-id="3b24a-557">Il termine semanticamente identico viene usato qui per indicare che l'esecuzione delle funzioni anonime, in tutti i casi, produce gli stessi effetti ha gli stessi argomenti.</span><span class="sxs-lookup"><span data-stu-id="3b24a-557">The term semantically identical is used here to mean that execution of the anonymous functions will, in all cases, produce the same effects given the same arguments.</span></span> <span data-ttu-id="3b24a-558">Questa regola consente al codice, ad esempio il comando seguente per essere ottimizzato.</span><span class="sxs-lookup"><span data-stu-id="3b24a-558">This rule permits code such as the following to be optimized.</span></span>

```csharp
delegate double Function(double x);

class Test
{
    static double[] Apply(double[] a, Function f) {
        double[] result = new double[a.Length];
        for (int i = 0; i < a.Length; i++) result[i] = f(a[i]);
        return result;
    }

    static void F(double[] a, double[] b) {
        a = Apply(a, (double x) => Math.Sin(x));
        b = Apply(b, (double y) => Math.Sin(y));
        ...
    }
}
```

<span data-ttu-id="3b24a-559">Poiché i due delegati di funzione anonima dispongono dello stesso (vuoto) set di variabili esterne acquisite e poiché le funzioni anonime sono semanticamente identiche, il compilatore è consentito utilizzare i delegati per fare riferimento allo stesso metodo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-559">Since the two anonymous function delegates have the same (empty) set of captured outer variables, and since the anonymous functions are semantically identical, the compiler is permitted to have the delegates refer to the same target method.</span></span> <span data-ttu-id="3b24a-560">In effetti, il compilatore può restituire la stessa istanza di delegato da entrambe le espressioni di funzione anonima.</span><span class="sxs-lookup"><span data-stu-id="3b24a-560">Indeed, the compiler is permitted to return the very same delegate instance from both anonymous function expressions.</span></span>

### <a name="evaluation-of-anonymous-function-conversions-to-expression-tree-types"></a><span data-ttu-id="3b24a-561">Valutazione delle conversioni di tipi di albero delle espressioni funzioni anonime</span><span class="sxs-lookup"><span data-stu-id="3b24a-561">Evaluation of anonymous function conversions to expression tree types</span></span>

<span data-ttu-id="3b24a-562">Conversione di una funzione anonima in un tipo di albero delle espressioni produce un albero delle espressioni ([tipi di albero delle espressioni](types.md#expression-tree-types)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-562">Conversion of an anonymous function to an expression tree type produces an expression tree ([Expression tree types](types.md#expression-tree-types)).</span></span> <span data-ttu-id="3b24a-563">Più precisamente, valutazione della conversione funzione anonima comporta la costruzione di una struttura oggetto che rappresenta la struttura della funzione anonima se stesso.</span><span class="sxs-lookup"><span data-stu-id="3b24a-563">More precisely, evaluation of the anonymous function conversion leads to the construction of an object structure that represents the structure of the anonymous function itself.</span></span> <span data-ttu-id="3b24a-564">La struttura esatta dell'albero delle espressioni, nonché il relativo processo di creazione, sono di tipo definito dall'implementazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-564">The precise structure of the expression tree, as well as the exact process for creating it, are implementation defined.</span></span>

### <a name="implementation-example"></a><span data-ttu-id="3b24a-565">Esempio di implementazione</span><span class="sxs-lookup"><span data-stu-id="3b24a-565">Implementation example</span></span>

<span data-ttu-id="3b24a-566">Questa sezione illustra una possibile implementazione di conversioni delle funzioni anonime in termini di altri costrutti in c#.</span><span class="sxs-lookup"><span data-stu-id="3b24a-566">This section describes a possible implementation of anonymous function conversions in terms of other C# constructs.</span></span> <span data-ttu-id="3b24a-567">L'implementazione descritta di seguito si basa sugli stessi principi usati dal compilatore Microsoft C#, ma è in alcun modo un'implementazione obbligatoria e non è l'unica possibile.</span><span class="sxs-lookup"><span data-stu-id="3b24a-567">The implementation described here is based on the same principles used by the Microsoft C# compiler, but it is by no means a mandated implementation, nor is it the only one possible.</span></span> <span data-ttu-id="3b24a-568">Solo brevemente sono indicate le conversioni in alberi delle espressioni, come la semantica esatta esulano dall'ambito di questa specifica.</span><span class="sxs-lookup"><span data-stu-id="3b24a-568">It only briefly mentions conversions to expression trees, as their exact semantics are outside the scope of this specification.</span></span>

<span data-ttu-id="3b24a-569">Il resto di questa sezione vengono forniti vari esempi di codice che contiene funzioni anonime con caratteristiche diverse.</span><span class="sxs-lookup"><span data-stu-id="3b24a-569">The remainder of this section gives several examples of code that contains anonymous functions with different characteristics.</span></span> <span data-ttu-id="3b24a-570">Per ogni esempio, viene fornita una traduzione corrispondente al codice che usa solo altri costrutti in c#.</span><span class="sxs-lookup"><span data-stu-id="3b24a-570">For each example, a corresponding translation to code that uses only other C# constructs is provided.</span></span> <span data-ttu-id="3b24a-571">Negli esempi, l'identificatore `D` viene assunto da rappresentano il tipo delegato seguenti:</span><span class="sxs-lookup"><span data-stu-id="3b24a-571">In the examples, the identifier `D` is assumed by represent the following delegate type:</span></span>
```csharp
public delegate void D();
```

<span data-ttu-id="3b24a-572">La forma più semplice di una funzione anonima è uno che non acquisisce alcun variabili esterne:</span><span class="sxs-lookup"><span data-stu-id="3b24a-572">The simplest form of an anonymous function is one that captures no outer variables:</span></span>
```csharp
class Test
{
    static void F() {
        D d = () => { Console.WriteLine("test"); };
    }
}
```

<span data-ttu-id="3b24a-573">Ciò può essere convertito in un'istanza di delegato che fa riferimento a un metodo statico generato dal compilatore in cui viene inserito il codice della funzione anonima:</span><span class="sxs-lookup"><span data-stu-id="3b24a-573">This can be translated to a delegate instantiation that references a compiler generated static method in which the code of the anonymous function is placed:</span></span>
```csharp
class Test
{
    static void F() {
        D d = new D(__Method1);
    }

    static void __Method1() {
        Console.WriteLine("test");
    }
}
```

<span data-ttu-id="3b24a-574">Nell'esempio seguente, la funzione anonima, fa riferimento a membri di istanza di `this`:</span><span class="sxs-lookup"><span data-stu-id="3b24a-574">In the following example, the anonymous function references instance members of `this`:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = () => { Console.WriteLine(x); };
    }
}
```

<span data-ttu-id="3b24a-575">Ciò può essere convertito in un metodo di istanza generato dal compilatore che contiene il codice della funzione anonima:</span><span class="sxs-lookup"><span data-stu-id="3b24a-575">This can be translated to a compiler generated instance method containing the code of the anonymous function:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        D d = new D(__Method1);
    }

    void __Method1() {
        Console.WriteLine(x);
    }
}
```

<span data-ttu-id="3b24a-576">In questo esempio, la funzione anonima consente di acquisire una variabile locale:</span><span class="sxs-lookup"><span data-stu-id="3b24a-576">In this example, the anonymous function captures a local variable:</span></span>
```csharp
class Test
{
    void F() {
        int y = 123;
        D d = () => { Console.WriteLine(y); };
    }
}
```

<span data-ttu-id="3b24a-577">La durata della variabile locale deve ora essere estesi almeno la durata del delegato di funzione anonima.</span><span class="sxs-lookup"><span data-stu-id="3b24a-577">The lifetime of the local variable must now be extended to at least the lifetime of the anonymous function delegate.</span></span> <span data-ttu-id="3b24a-578">Ciò può essere ottenuto da "sottraendo" della variabile locale in un campo di una classe generata dal compilatore.</span><span class="sxs-lookup"><span data-stu-id="3b24a-578">This can be achieved by "hoisting" the local variable into a field of a compiler generated class.</span></span> <span data-ttu-id="3b24a-579">Creazione di un'istanza della variabile locale ([creazione di un'istanza delle variabili locali](expressions.md#instantiation-of-local-variables)) corrisponde quindi alla creazione di un'istanza di classe generato dal compilatore e l'accesso alla variabile locale corrisponde all'accesso a un campo nell'istanza di la classe generata dal compilatore.</span><span class="sxs-lookup"><span data-stu-id="3b24a-579">Instantiation of the local variable ([Instantiation of local variables](expressions.md#instantiation-of-local-variables)) then corresponds to creating an instance of the compiler generated class, and accessing the local variable corresponds to accessing a field in the instance of the compiler generated class.</span></span> <span data-ttu-id="3b24a-580">Inoltre, la funzione anonima diventa un metodo di istanza della classe generata dal compilatore:</span><span class="sxs-lookup"><span data-stu-id="3b24a-580">Furthermore, the anonymous function becomes an instance method of the compiler generated class:</span></span>
```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.y = 123;
        D d = new D(__locals1.__Method1);
    }

    class __Locals1
    {
        public int y;

        public void __Method1() {
            Console.WriteLine(y);
        }
    }
}
```

<span data-ttu-id="3b24a-581">Infine, l'anonimi funzione seguente acquisisce `this` , nonché due variabili locali con durate diverse:</span><span class="sxs-lookup"><span data-stu-id="3b24a-581">Finally, the following anonymous function captures `this` as well as two local variables with different lifetimes:</span></span>
```csharp
class Test
{
    int x;

    void F() {
        int y = 123;
        for (int i = 0; i < 10; i++) {
            int z = i * 2;
            D d = () => { Console.WriteLine(x + y + z); };
        }
    }
}
```

<span data-ttu-id="3b24a-582">In questo caso, viene creata una classe di generato dal compilatore per ogni istruzione blocco in cui variabili locali vengono acquisite in modo che le variabili locali nei blocchi di diversi possono avere durate indipendenti.</span><span class="sxs-lookup"><span data-stu-id="3b24a-582">Here, a compiler generated class is created for each statement block in which locals are captured such that the locals in the different blocks can have independent lifetimes.</span></span> <span data-ttu-id="3b24a-583">Un'istanza di `__Locals2`, la classe generata dal compilatore per il blocco di istruzione interna, contiene la variabile locale `z` e un campo che fa riferimento a un'istanza di `__Locals1`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-583">An instance of `__Locals2`, the compiler generated class for the inner statement block, contains the local variable `z` and a field that references an instance of `__Locals1`.</span></span>  <span data-ttu-id="3b24a-584">Un'istanza di `__Locals1`, la classe generata dal compilatore per il blocco di istruzione esterna, contiene la variabile locale `y` e un campo che fa riferimento a `this` del membro funzione contenitore.</span><span class="sxs-lookup"><span data-stu-id="3b24a-584">An instance of `__Locals1`, the compiler generated class for the outer statement block, contains the local variable `y` and a field that references `this` of the enclosing function member.</span></span> <span data-ttu-id="3b24a-585">Con queste strutture di dati è possibile raggiungere tutte acquisite le variabili esterne tramite un'istanza di `__Local2`, e il codice della funzione anonima in questo modo può essere implementato come metodo di istanza di tale classe.</span><span class="sxs-lookup"><span data-stu-id="3b24a-585">With these data structures it is possible to reach all captured outer variables through an instance of `__Local2`, and the code of the anonymous function can thus be implemented as an instance method of that class.</span></span>

```csharp
class Test
{
    void F() {
        __Locals1 __locals1 = new __Locals1();
        __locals1.__this = this;
        __locals1.y = 123;
        for (int i = 0; i < 10; i++) {
            __Locals2 __locals2 = new __Locals2();
            __locals2.__locals1 = __locals1;
            __locals2.z = i * 2;
            D d = new D(__locals2.__Method1);
        }
    }

    class __Locals1
    {
        public Test __this;
        public int y;
    }

    class __Locals2
    {
        public __Locals1 __locals1;
        public int z;

        public void __Method1() {
            Console.WriteLine(__locals1.__this.x + __locals1.y + z);
        }
    }
}
```

<span data-ttu-id="3b24a-586">La stessa tecnica applicata qui per acquisire le variabili locali può essere usata anche la conversione di funzioni anonime in alberi delle espressioni: Riferimenti agli oggetti generato dal compilatore possono essere archiviati nell'albero delle espressioni e l'accesso alle variabili locali può essere rappresentata come campo accede su tali oggetti.</span><span class="sxs-lookup"><span data-stu-id="3b24a-586">The same technique applied here to capture local variables can also be used when converting anonymous functions to expression trees: References to the compiler generated objects can be stored in the expression tree, and access to the local variables can be represented as field accesses on these objects.</span></span> <span data-ttu-id="3b24a-587">Il vantaggio di questo approccio è che consente le variabili locali "elevate" devono essere condivisi tra i delegati e gli alberi delle espressioni.</span><span class="sxs-lookup"><span data-stu-id="3b24a-587">The advantage of this approach is that it allows the "lifted" local variables to be shared between delegates and expression trees.</span></span>

## <a name="method-group-conversions"></a><span data-ttu-id="3b24a-588">Conversioni dei metodi di gruppo</span><span class="sxs-lookup"><span data-stu-id="3b24a-588">Method group conversions</span></span>

<span data-ttu-id="3b24a-589">Una conversione implicita ([conversioni implicite](conversions.md#implicit-conversions)) esistente da un gruppo di metodi ([classificazioni delle espressioni](expressions.md#expression-classifications)) a un tipo delegato compatibile.</span><span class="sxs-lookup"><span data-stu-id="3b24a-589">An implicit conversion ([Implicit conversions](conversions.md#implicit-conversions)) exists from a method group ([Expression classifications](expressions.md#expression-classifications)) to a compatible delegate type.</span></span> <span data-ttu-id="3b24a-590">Dato un tipo delegato `D` e un'espressione `E` che viene classificato come un gruppo di metodi, esiste una conversione implicita dal `E` al `D` se `E` contiene almeno un metodo che è applicabile nel relativo (forma normale [Membro di funzione applicabile](expressions.md#applicable-function-member)) per un elenco di argomenti costruito mediante l'uso dei tipi di parametro e modificatori di `D`, come descritto di seguito.</span><span class="sxs-lookup"><span data-stu-id="3b24a-590">Given a delegate type `D` and an expression `E` that is classified as a method group, an implicit conversion exists from `E` to `D` if `E` contains at least one method that is applicable in its normal form ([Applicable function member](expressions.md#applicable-function-member)) to an argument list constructed by use of the parameter types and modifiers of `D`, as described in the following.</span></span>

<span data-ttu-id="3b24a-591">L'applicazione in fase di compilazione di una conversione da un gruppo di metodi `E` a un tipo delegato `D` è descritta di seguito.</span><span class="sxs-lookup"><span data-stu-id="3b24a-591">The compile-time application of a conversion from a method group `E` to a delegate type `D` is described in the following.</span></span> <span data-ttu-id="3b24a-592">Si noti che l'esistenza di una conversione implicita da `E` a `D` non garantisce che l'applicazione in fase di compilazione della conversione verrà completata senza errori.</span><span class="sxs-lookup"><span data-stu-id="3b24a-592">Note that the existence of an implicit conversion from `E` to `D` does not guarantee that the compile-time application of the conversion will succeed without error.</span></span>

*  <span data-ttu-id="3b24a-593">Un singolo metodo `M` sia selezionata corrispondente a una chiamata al metodo ([chiamate al metodo](expressions.md#method-invocations)) nel formato `E(A)`, con le modifiche seguenti:</span><span class="sxs-lookup"><span data-stu-id="3b24a-593">A single method `M` is selected corresponding to a method invocation ([Method invocations](expressions.md#method-invocations)) of the form `E(A)`, with the following modifications:</span></span>
    * <span data-ttu-id="3b24a-594">L'elenco di argomenti `A` è riportato un elenco di espressioni, ognuno classificate come una variabile e con il tipo e il modificatore (`ref` oppure `out`) del parametro corrispondente nel *formal_parameter_list* del `D`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-594">The argument list `A` is a list of expressions, each classified as a variable and with the type and modifier (`ref` or `out`) of the corresponding parameter in the *formal_parameter_list* of `D`.</span></span>
    * <span data-ttu-id="3b24a-595">I metodi candidato considerati sono solo quelli che sono applicabili in base al formato normale ([membro di funzione applicabile](expressions.md#applicable-function-member)), non quelle applicabili solo in forma espansa.</span><span class="sxs-lookup"><span data-stu-id="3b24a-595">The candidate methods considered are only those methods that are applicable in their normal form ([Applicable function member](expressions.md#applicable-function-member)), not those applicable only in their expanded form.</span></span>
*  <span data-ttu-id="3b24a-596">Se l'algoritmo di [chiamate al metodo](expressions.md#method-invocations) genera un errore, quindi si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-596">If the algorithm of [Method invocations](expressions.md#method-invocations) produces an error, then a compile-time error occurs.</span></span> <span data-ttu-id="3b24a-597">In caso contrario, l'algoritmo produce un singolo metodo ottimo `M` aventi lo stesso numero di parametri come `D` e la conversione è considerata presente.</span><span class="sxs-lookup"><span data-stu-id="3b24a-597">Otherwise the algorithm produces a single best method `M` having the same number of parameters as `D` and the conversion is considered to exist.</span></span>
*  <span data-ttu-id="3b24a-598">Il metodo selezionato `M` devono essere compatibili ([compatibilità dei delegati](delegates.md#delegate-compatibility)) con il tipo di delegato `D`, oppure in caso contrario, si è verificato un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-598">The selected method `M` must be compatible ([Delegate compatibility](delegates.md#delegate-compatibility)) with the delegate type `D`, or otherwise, a compile-time error occurs.</span></span>
*  <span data-ttu-id="3b24a-599">Se il metodo selezionato `M` è un metodo di istanza, l'espressione dell'istanza associata `E` determina l'oggetto di destinazione del delegato.</span><span class="sxs-lookup"><span data-stu-id="3b24a-599">If the selected method `M` is an instance method, the instance expression associated with `E` determines the target object of the delegate.</span></span>
*  <span data-ttu-id="3b24a-600">Se il metodo selezionato M è un metodo di estensione che è identificato per mezzo di un accesso ai membri in un'espressione dell'istanza, tale espressione dell'istanza determina l'oggetto di destinazione del delegato.</span><span class="sxs-lookup"><span data-stu-id="3b24a-600">If the selected method M is an extension method which is denoted by means of a member access on an instance expression, that instance expression determines the target object of the delegate.</span></span>
*  <span data-ttu-id="3b24a-601">Il risultato della conversione è un valore di tipo `D`, vale a dire un delegato appena creato che fa riferimento all'oggetto di destinazione e metodo selezionato.</span><span class="sxs-lookup"><span data-stu-id="3b24a-601">The result of the conversion is a value of type `D`, namely a newly created delegate that refers to the selected method and target object.</span></span>
*  <span data-ttu-id="3b24a-602">Si noti che questo processo può portare alla creazione di un delegato a un metodo di estensione, se l'algoritmo di [chiamate al metodo](expressions.md#method-invocations) non riesce a trovare un metodo di istanza, ma ha esito positivo nell'elaborazione della chiamata di `E(A)` come un'estensione chiamata al metodo ([chiamate al metodo di estensione](expressions.md#extension-method-invocations)).</span><span class="sxs-lookup"><span data-stu-id="3b24a-602">Note that this process can lead to the creation of a delegate to an extension method, if the algorithm of [Method invocations](expressions.md#method-invocations) fails to find an instance method but succeeds in processing the invocation of `E(A)` as an extension method invocation ([Extension method invocations](expressions.md#extension-method-invocations)).</span></span> <span data-ttu-id="3b24a-603">Consente di acquisire un delegato creato in questo modo il metodo di estensione così come primo argomento.</span><span class="sxs-lookup"><span data-stu-id="3b24a-603">A delegate thus created captures the extension method as well as its first argument.</span></span>

<span data-ttu-id="3b24a-604">L'esempio seguente illustra le conversioni dei gruppi di metodo:</span><span class="sxs-lookup"><span data-stu-id="3b24a-604">The following example demonstrates method group conversions:</span></span>
```csharp
delegate string D1(object o);

delegate object D2(string s);

delegate object D3();

delegate string D4(object o, params object[] a);

delegate string D5(int i);

class Test
{
    static string F(object o) {...}

    static void G() {
        D1 d1 = F;            // Ok
        D2 d2 = F;            // Ok
        D3 d3 = F;            // Error -- not applicable
        D4 d4 = F;            // Error -- not applicable in normal form
        D5 d5 = F;            // Error -- applicable but not compatible

    }
}
```

<span data-ttu-id="3b24a-605">L'assegnazione al `d1` converte in modo implicito il gruppo di metodi `F` su un valore di tipo `D1`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-605">The assignment to `d1` implicitly converts the method group `F` to a value of type `D1`.</span></span>

<span data-ttu-id="3b24a-606">L'assegnazione al `d2` Mostra come è possibile creare un delegato a un metodo che dispone di tipi di parametro meno derivati (controvarianti) e un tipo più derivato (covariante restituito).</span><span class="sxs-lookup"><span data-stu-id="3b24a-606">The assignment to `d2` shows how it is possible to create a delegate to a method that has less derived (contravariant) parameter types and a more derived (covariant) return type.</span></span>

<span data-ttu-id="3b24a-607">L'assegnazione al `d3` Mostra come non esiste alcuna conversione se il metodo non è applicabile.</span><span class="sxs-lookup"><span data-stu-id="3b24a-607">The assignment to `d3` shows how no conversion exists if the method is not applicable.</span></span>

<span data-ttu-id="3b24a-608">L'assegnazione al `d4` viene illustrato come il metodo deve essere applicabile in forma normale.</span><span class="sxs-lookup"><span data-stu-id="3b24a-608">The assignment to `d4` shows how the method must be applicable in its normal form.</span></span>

<span data-ttu-id="3b24a-609">L'assegnazione al `d5` Mostra come parametro e tipo restituito del metodo del delegato è consentiti a differire solo per i tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="3b24a-609">The assignment to `d5` shows how parameter and return types of the delegate and method are allowed to differ only for reference types.</span></span>

<span data-ttu-id="3b24a-610">Come con tutte le altre conversioni implicite ed esplicite, l'operatore di cast è utilizzabile per eseguire in modo esplicito la conversione di un gruppo di metodi.</span><span class="sxs-lookup"><span data-stu-id="3b24a-610">As with all other implicit and explicit conversions, the cast operator can be used to explicitly perform a method group conversion.</span></span> <span data-ttu-id="3b24a-611">Di conseguenza, l'esempio</span><span class="sxs-lookup"><span data-stu-id="3b24a-611">Thus, the example</span></span>
```csharp
object obj = new EventHandler(myDialog.OkClick);
```
<span data-ttu-id="3b24a-612">è invece possibile scrivere</span><span class="sxs-lookup"><span data-stu-id="3b24a-612">could instead be written</span></span>
```csharp
object obj = (EventHandler)myDialog.OkClick;
```

<span data-ttu-id="3b24a-613">I gruppi di metodi potrebbero influenzare la risoluzione dell'overload e partecipare all'inferenza del tipo.</span><span class="sxs-lookup"><span data-stu-id="3b24a-613">Method groups may influence overload resolution, and participate in type inference.</span></span> <span data-ttu-id="3b24a-614">Visualizzare [membri funzione](expressions.md#function-members) per altri dettagli.</span><span class="sxs-lookup"><span data-stu-id="3b24a-614">See [Function members](expressions.md#function-members) for further details.</span></span>

<span data-ttu-id="3b24a-615">La valutazione in fase di esecuzione della conversione di un gruppo di metodi procede nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="3b24a-615">The run-time evaluation of a method group conversion proceeds as follows:</span></span>

*  <span data-ttu-id="3b24a-616">Se il metodo selezionato in fase di compilazione è un metodo di istanza o è un metodo di estensione che viene eseguito come un metodo di istanza, l'oggetto di destinazione del delegato è determinato dall'espressione dell'istanza associata `E`:</span><span class="sxs-lookup"><span data-stu-id="3b24a-616">If the method selected at compile-time is an instance method, or it is an extension method which is accessed as an instance method, the target object of the delegate is determined from the instance expression associated with `E`:</span></span>
    * <span data-ttu-id="3b24a-617">Viene valutata l'espressione dell'istanza.</span><span class="sxs-lookup"><span data-stu-id="3b24a-617">The instance expression is evaluated.</span></span> <span data-ttu-id="3b24a-618">Se questa versione di valutazione causa un'eccezione, non verrà eseguito alcun ulteriore passaggio.</span><span class="sxs-lookup"><span data-stu-id="3b24a-618">If this evaluation causes an exception, no further steps are executed.</span></span>
    * <span data-ttu-id="3b24a-619">Se l'espressione dell'istanza di un *reference_type*, il valore calcolato per l'espressione dell'istanza diventa l'oggetto di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-619">If the instance expression is of a *reference_type*, the value computed by the instance expression becomes the target object.</span></span> <span data-ttu-id="3b24a-620">Se il metodo selezionato è un metodo di istanza e l'oggetto di destinazione è `null`, un `System.NullReferenceException` viene generata un'eccezione e non viene eseguito alcun ulteriore passaggio.</span><span class="sxs-lookup"><span data-stu-id="3b24a-620">If the selected method is an instance method and the target object is `null`, a `System.NullReferenceException` is thrown and no further steps are executed.</span></span>
    * <span data-ttu-id="3b24a-621">Se l'espressione dell'istanza di un *value_type*, un'operazione di conversione boxing ([conversioni Boxing](types.md#boxing-conversions)) viene eseguita per convertire il valore in un oggetto, e tale oggetto diventa l'oggetto di destinazione.</span><span class="sxs-lookup"><span data-stu-id="3b24a-621">If the instance expression is of a *value_type*, a boxing operation ([Boxing conversions](types.md#boxing-conversions)) is performed to convert the value to an object, and this object becomes the target object.</span></span>
*  <span data-ttu-id="3b24a-622">In caso contrario, il metodo selezionato fa parte di una chiamata al metodo statico e l'oggetto di destinazione del delegato è `null`.</span><span class="sxs-lookup"><span data-stu-id="3b24a-622">Otherwise the selected method is part of a static method call, and the target object of the delegate is `null`.</span></span>
*  <span data-ttu-id="3b24a-623">Una nuova istanza del tipo delegato `D` viene allocato.</span><span class="sxs-lookup"><span data-stu-id="3b24a-623">A new instance of the delegate type `D` is allocated.</span></span> <span data-ttu-id="3b24a-624">Se non è disponibile memoria sufficiente per allocare la nuova istanza, una `System.OutOfMemoryException` viene generata un'eccezione e non viene eseguito alcun ulteriore passaggio.</span><span class="sxs-lookup"><span data-stu-id="3b24a-624">If there is not enough memory available to allocate the new instance, a `System.OutOfMemoryException` is thrown and no further steps are executed.</span></span>
*  <span data-ttu-id="3b24a-625">La nuova istanza di delegato viene inizializzata con un riferimento al metodo che è stato determinato in fase di compilazione e un riferimento all'oggetto di destinazione viene calcolato in precedenza.</span><span class="sxs-lookup"><span data-stu-id="3b24a-625">The new delegate instance is initialized with a reference to the method that was determined at compile-time and a reference to the target object computed above.</span></span>
