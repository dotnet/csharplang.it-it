---
ms.openlocfilehash: a01cf9387b8dc47de036bf0bd1496c19a441d81c
ms.sourcegitcommit: 7f7fc6e9e195e51b7ff8229aeaa70aa9fbbb63cb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/10/2019
ms.locfileid: "70876804"
---
# <a name="variables"></a><span data-ttu-id="6aa6a-101">Variabili</span><span class="sxs-lookup"><span data-stu-id="6aa6a-101">Variables</span></span>

<span data-ttu-id="6aa6a-102">Le variabili rappresentano i percorsi di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-102">Variables represent storage locations.</span></span> <span data-ttu-id="6aa6a-103">Ogni variabile dispone di un tipo che determina quali valori possono essere archiviati nella variabile.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-103">Every variable has a type that determines what values can be stored in the variable.</span></span> <span data-ttu-id="6aa6a-104">C#è un linguaggio indipendente dai tipi e il C# compilatore garantisce che i valori archiviati nelle variabili siano sempre del tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-104">C# is a type-safe language, and the C# compiler guarantees that values stored in variables are always of the appropriate type.</span></span> <span data-ttu-id="6aa6a-105">Il valore di una variabile può essere modificato tramite l'assegnazione o l' `++` uso degli operatori e. `--`</span><span class="sxs-lookup"><span data-stu-id="6aa6a-105">The value of a variable can be changed through assignment or through use of the `++` and `--` operators.</span></span>

<span data-ttu-id="6aa6a-106">Una variabile deve essere ***assegnata definitivamente*** ([assegnazione definita](variables.md#definite-assignment)) prima di poter ottenere il relativo valore.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-106">A variable must be ***definitely assigned*** ([Definite assignment](variables.md#definite-assignment)) before its value can be obtained.</span></span>

<span data-ttu-id="6aa6a-107">Come descritto nelle sezioni seguenti, le variabili vengono ***inizialmente assegnate*** o ***inizialmente non assegnate***.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-107">As described in the following sections, variables are either ***initially assigned*** or ***initially unassigned***.</span></span> <span data-ttu-id="6aa6a-108">Una variabile inizialmente assegnata ha un valore iniziale ben definito ed è sempre considerata assegnata definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-108">An initially assigned variable has a well-defined initial value and is always considered definitely assigned.</span></span> <span data-ttu-id="6aa6a-109">Una variabile inizialmente non assegnata non ha un valore iniziale.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-109">An initially unassigned variable has no initial value.</span></span> <span data-ttu-id="6aa6a-110">Affinché una variabile inizialmente non assegnata venga considerata definitivamente assegnata in una determinata posizione, un'assegnazione alla variabile deve essere eseguita in ogni percorso di esecuzione possibile che conduce a tale posizione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-110">For an initially unassigned variable to be considered definitely assigned at a certain location, an assignment to the variable must occur in every possible execution path leading to that location.</span></span>

## <a name="variable-categories"></a><span data-ttu-id="6aa6a-111">Categorie di variabili</span><span class="sxs-lookup"><span data-stu-id="6aa6a-111">Variable categories</span></span>

<span data-ttu-id="6aa6a-112">C#definisce sette categorie di variabili: variabili statiche, variabili di istanza, elementi di matrice, parametri di valore, parametri di riferimento, parametri di output e variabili locali.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-112">C# defines seven categories of variables: static variables, instance variables, array elements, value parameters, reference parameters, output parameters, and local variables.</span></span> <span data-ttu-id="6aa6a-113">Le sezioni seguenti descrivono ognuna di queste categorie.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-113">The sections that follow describe each of these categories.</span></span>

<span data-ttu-id="6aa6a-114">Nell'esempio</span><span class="sxs-lookup"><span data-stu-id="6aa6a-114">In the example</span></span>
```csharp
class A
{
    public static int x;
    int y;

    void F(int[] v, int a, ref int b, out int c) {
        int i = 1;
        c = a + b++;
    }
}
```
<span data-ttu-id="6aa6a-115">`x`è una variabile statica, `y` è una variabile di istanza `v[0]` , è un elemento di `a` matrice, è un parametro `b` di valore, è un `c` parametro di riferimento, è un `i` parametro di output e è una variabile locale .</span><span class="sxs-lookup"><span data-stu-id="6aa6a-115">`x` is a static variable, `y` is an instance variable, `v[0]` is an array element, `a` is a value parameter, `b` is a reference parameter, `c` is an output parameter, and `i` is a local variable.</span></span>

### <a name="static-variables"></a><span data-ttu-id="6aa6a-116">Variabili statiche</span><span class="sxs-lookup"><span data-stu-id="6aa6a-116">Static variables</span></span>

<span data-ttu-id="6aa6a-117">Un campo dichiarato con il `static` modificatore è denominato ***variabile statica***.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-117">A field declared with the `static` modifier is called a ***static variable***.</span></span> <span data-ttu-id="6aa6a-118">Una variabile statica è presente prima dell'esecuzione del costruttore statico ([costruttori statici](classes.md#static-constructors)) per il tipo che lo contiene e cessa di esistere quando il dominio applicazione associato cessa di esistere.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-118">A static variable comes into existence before execution of the static constructor ([Static constructors](classes.md#static-constructors)) for its containing type, and ceases to exist when the associated application domain ceases to exist.</span></span>

<span data-ttu-id="6aa6a-119">Il valore iniziale di una variabile statica è il valore predefinito ([valori predefiniti](variables.md#default-values)) del tipo della variabile.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-119">The initial value of a static variable is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="6aa6a-120">Ai fini del controllo di assegnazione definito, una variabile statica viene considerata inizialmente assegnata.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-120">For purposes of definite assignment checking, a static variable is considered initially assigned.</span></span>

### <a name="instance-variables"></a><span data-ttu-id="6aa6a-121">Variabili di istanza</span><span class="sxs-lookup"><span data-stu-id="6aa6a-121">Instance variables</span></span>

<span data-ttu-id="6aa6a-122">Un campo dichiarato senza il `static` modificatore viene chiamato ***variabile di istanza***.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-122">A field declared without the `static` modifier is called an ***instance variable***.</span></span>

#### <a name="instance-variables-in-classes"></a><span data-ttu-id="6aa6a-123">Variabili di istanza nelle classi</span><span class="sxs-lookup"><span data-stu-id="6aa6a-123">Instance variables in classes</span></span>

<span data-ttu-id="6aa6a-124">Una variabile di istanza di una classe diventa disponibile quando viene creata una nuova istanza di tale classe e cessa di esistere quando non vi sono riferimenti a tale istanza e il distruttore dell'istanza, se presente, è stato eseguito.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-124">An instance variable of a class comes into existence when a new instance of that class is created, and ceases to exist when there are no references to that instance and the instance's destructor (if any) has executed.</span></span>

<span data-ttu-id="6aa6a-125">Il valore iniziale di una variabile di istanza di una classe è il valore predefinito ([valori predefiniti](variables.md#default-values)) del tipo della variabile.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-125">The initial value of an instance variable of a class is the default value ([Default values](variables.md#default-values)) of the variable's type.</span></span>

<span data-ttu-id="6aa6a-126">Ai fini del controllo di assegnazione definito, una variabile di istanza di una classe viene considerata inizialmente assegnata.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-126">For the purpose of definite assignment checking, an instance variable of a class is considered initially assigned.</span></span>

#### <a name="instance-variables-in-structs"></a><span data-ttu-id="6aa6a-127">Variabili di istanza negli struct</span><span class="sxs-lookup"><span data-stu-id="6aa6a-127">Instance variables in structs</span></span>

<span data-ttu-id="6aa6a-128">Una variabile di istanza di uno struct ha esattamente la stessa durata della variabile struct a cui appartiene.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-128">An instance variable of a struct has exactly the same lifetime as the struct variable to which it belongs.</span></span> <span data-ttu-id="6aa6a-129">In altre parole, quando una variabile di un tipo struct entra in vigore o cessa di esistere, è necessario eseguire anche le variabili di istanza dello struct.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-129">In other words, when a variable of a struct type comes into existence or ceases to exist, so too do the instance variables of the struct.</span></span>

<span data-ttu-id="6aa6a-130">Lo stato di assegnazione iniziale di una variabile di istanza di uno struct è identico a quello della variabile struct che lo contiene.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-130">The initial assignment state of an instance variable of a struct is the same as that of the containing struct variable.</span></span> <span data-ttu-id="6aa6a-131">In altre parole, quando una variabile struct viene considerata inizialmente assegnata, anch ' essa sono variabili di istanza e, quando una variabile struct viene considerata inizialmente non assegnata, le variabili di istanza non vengono assegnate in modo analogo.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-131">In other words, when a struct variable is considered initially assigned, so too are its instance variables, and when a struct variable is considered initially unassigned, its instance variables are likewise unassigned.</span></span>

### <a name="array-elements"></a><span data-ttu-id="6aa6a-132">Elementi di matrice</span><span class="sxs-lookup"><span data-stu-id="6aa6a-132">Array elements</span></span>

<span data-ttu-id="6aa6a-133">Gli elementi di una matrice entrano in vigore quando viene creata un'istanza di matrice e smettono di esistere quando non vi sono riferimenti a tale istanza di matrice.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-133">The elements of an array come into existence when an array instance is created, and cease to exist when there are no references to that array instance.</span></span>

<span data-ttu-id="6aa6a-134">Il valore iniziale di ogni elemento di una matrice è il valore predefinito ([valori predefiniti](variables.md#default-values)) del tipo degli elementi della matrice.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-134">The initial value of each of the elements of an array is the default value ([Default values](variables.md#default-values)) of the type of the array elements.</span></span>

<span data-ttu-id="6aa6a-135">Ai fini del controllo di assegnazione definito, viene considerato inizialmente assegnato un elemento di matrice.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-135">For the purpose of definite assignment checking, an array element is considered initially assigned.</span></span>

### <a name="value-parameters"></a><span data-ttu-id="6aa6a-136">Parametri valore</span><span class="sxs-lookup"><span data-stu-id="6aa6a-136">Value parameters</span></span>

<span data-ttu-id="6aa6a-137">Un parametro dichiarato senza un `ref` modificatore o `out` è un ***parametro di valore***.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-137">A parameter declared without a `ref` or `out` modifier is a ***value parameter***.</span></span>

<span data-ttu-id="6aa6a-138">Un parametro di valore entra in vigore alla chiamata del membro della funzione (metodo, costruttore di istanza, funzione di accesso o operatore) o funzione anonima a cui appartiene il parametro e viene inizializzato con il valore dell'argomento fornito nella chiamata.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-138">A value parameter comes into existence upon invocation of the function member (method, instance constructor, accessor, or operator) or anonymous function to which the parameter belongs, and is initialized with the value of the argument given in the invocation.</span></span> <span data-ttu-id="6aa6a-139">Un parametro di valore in genere smette di esistere al ritorno del membro della funzione o della funzione anonima.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-139">A value parameter normally ceases to exist upon return of the function member or anonymous function.</span></span> <span data-ttu-id="6aa6a-140">Tuttavia, se il parametro value viene acquisito da una funzione anonima ([espressioni di funzione anonima](expressions.md#anonymous-function-expressions)), la durata si estende almeno finché il delegato o l'albero delle espressioni creato da tale funzione anonima non sarà idoneo per Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-140">However, if the value parameter is captured by an anonymous function ([Anonymous function expressions](expressions.md#anonymous-function-expressions)), its life time extends at least until the delegate or expression tree created from that anonymous function is eligible for garbage collection.</span></span>

<span data-ttu-id="6aa6a-141">Ai fini del controllo di assegnazione definito, un parametro di valore viene considerato inizialmente assegnato.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-141">For the purpose of definite assignment checking, a value parameter is considered initially assigned.</span></span>

### <a name="reference-parameters"></a><span data-ttu-id="6aa6a-142">Parametri per riferimento</span><span class="sxs-lookup"><span data-stu-id="6aa6a-142">Reference parameters</span></span>

<span data-ttu-id="6aa6a-143">Un parametro dichiarato con un `ref` modificatore è un ***parametro di riferimento***.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-143">A parameter declared with a `ref` modifier is a ***reference parameter***.</span></span>

<span data-ttu-id="6aa6a-144">Un parametro di riferimento non crea un nuovo percorso di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-144">A reference parameter does not create a new storage location.</span></span> <span data-ttu-id="6aa6a-145">Un parametro Reference rappresenta invece lo stesso percorso di archiviazione della variabile specificata come argomento nel membro della funzione o in una chiamata di funzione anonima.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-145">Instead, a reference parameter represents the same storage location as the variable given as the argument in the function member or anonymous function invocation.</span></span> <span data-ttu-id="6aa6a-146">Pertanto, il valore di un parametro di riferimento è sempre lo stesso della variabile sottostante.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-146">Thus, the value of a reference parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="6aa6a-147">Le seguenti regole di assegnazione definite si applicano ai parametri di riferimento.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-147">The following definite assignment rules apply to reference parameters.</span></span> <span data-ttu-id="6aa6a-148">Si notino le diverse regole per i parametri di output descritti in [parametri di output](variables.md#output-parameters).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-148">Note the different rules for output parameters described in [Output parameters](variables.md#output-parameters).</span></span>

*  <span data-ttu-id="6aa6a-149">Una variabile deve essere assegnata definitivamente ([assegnazione definita](variables.md#definite-assignment)) prima di poter essere passata come parametro di riferimento in una chiamata a un membro di funzione o a un delegato.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-149">A variable must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before it can be passed as a reference parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="6aa6a-150">All'interno di un membro di funzione o di una funzione anonima, viene considerato inizialmente assegnato un parametro di riferimento.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-150">Within a function member or anonymous function, a reference parameter is considered initially assigned.</span></span>

<span data-ttu-id="6aa6a-151">All'interno di un metodo di istanza o di una funzione di accesso `this` dell'istanza di un tipo struct, la parola chiave si comporta esattamente come un parametro di riferimento del tipo struct ([questo accesso](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-151">Within an instance method or instance accessor of a struct type, the `this` keyword behaves exactly as a reference parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="output-parameters"></a><span data-ttu-id="6aa6a-152">Parametri di output</span><span class="sxs-lookup"><span data-stu-id="6aa6a-152">Output parameters</span></span>

<span data-ttu-id="6aa6a-153">Un parametro dichiarato con un `out` modificatore è un ***parametro di output***.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-153">A parameter declared with an `out` modifier is an ***output parameter***.</span></span>

<span data-ttu-id="6aa6a-154">Un parametro di output non crea un nuovo percorso di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-154">An output parameter does not create a new storage location.</span></span> <span data-ttu-id="6aa6a-155">Un parametro di output rappresenta invece lo stesso percorso di archiviazione della variabile specificata come argomento nel membro della funzione o nella chiamata al delegato.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-155">Instead, an output parameter represents the same storage location as the variable given as the argument in the function member or delegate invocation.</span></span> <span data-ttu-id="6aa6a-156">Pertanto, il valore di un parametro di output corrisponde sempre alla variabile sottostante.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-156">Thus, the value of an output parameter is always the same as the underlying variable.</span></span>

<span data-ttu-id="6aa6a-157">Le seguenti regole di assegnazione definite si applicano ai parametri di output.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-157">The following definite assignment rules apply to output parameters.</span></span> <span data-ttu-id="6aa6a-158">Si notino le diverse regole per i parametri di riferimento descritti in [parametri di riferimento](variables.md#reference-parameters).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-158">Note the different rules for reference parameters described in [Reference parameters](variables.md#reference-parameters).</span></span>

*  <span data-ttu-id="6aa6a-159">Una variabile non deve essere definitivamente assegnata prima di poter essere passata come parametro di output in una chiamata a un membro di funzione o a un delegato.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-159">A variable need not be definitely assigned before it can be passed as an output parameter in a function member or delegate invocation.</span></span>
*  <span data-ttu-id="6aa6a-160">Dopo il normale completamento di un membro di funzione o di una chiamata a un delegato, ogni variabile passata come parametro di output viene considerata assegnata in tale percorso di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-160">Following the normal completion of a function member or delegate invocation, each variable that was passed as an output parameter is considered assigned in that execution path.</span></span>
*  <span data-ttu-id="6aa6a-161">All'interno di un membro di funzione o di una funzione anonima, un parametro di output viene considerato inizialmente non assegnato.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-161">Within a function member or anonymous function, an output parameter is considered initially unassigned.</span></span>
*  <span data-ttu-id="6aa6a-162">Ogni parametro di output di un membro di funzione o di una funzione anonima deve essere assegnato definitivamente ([assegnazione definita](variables.md#definite-assignment)) prima che il membro della funzione o la funzione anonima restituisca normalmente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-162">Every output parameter of a function member or anonymous function must be definitely assigned ([Definite assignment](variables.md#definite-assignment)) before the function member or anonymous function returns normally.</span></span>

<span data-ttu-id="6aa6a-163">All'interno di un costruttore di istanza di un tipo `this` struct, la parola chiave si comporta esattamente come un parametro di output del tipo struct ([questo accesso](expressions.md#this-access)).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-163">Within an instance constructor of a struct type, the `this` keyword behaves exactly as an output parameter of the struct type ([This access](expressions.md#this-access)).</span></span>

### <a name="local-variables"></a><span data-ttu-id="6aa6a-164">Variabili locali</span><span class="sxs-lookup"><span data-stu-id="6aa6a-164">Local variables</span></span>

<span data-ttu-id="6aa6a-165">Una ***variabile locale*** viene dichiarata da un *local_variable_declaration*, che può verificarsi in un *blocco*, un *for_Statement*, un *switch_Statement* o un *using_statement*; o da un *foreach_statement* o un *specific_catch_clause* per un *try_statement*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-165">A ***local variable*** is declared by a *local_variable_declaration*, which may occur in a *block*, a *for_statement*, a *switch_statement* or a *using_statement*; or by a *foreach_statement* or a *specific_catch_clause* for a *try_statement*.</span></span>

<span data-ttu-id="6aa6a-166">La durata di una variabile locale è la parte dell'esecuzione del programma durante la quale è garantita la riservatezza dell'archiviazione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-166">The lifetime of a local variable is the portion of program execution during which storage is guaranteed to be reserved for it.</span></span> <span data-ttu-id="6aa6a-167">Questa durata estende almeno dall'immissione nel *blocco*, *for_Statement*, *switch_Statement*, *using_statement*, *foreach_statement*o *specific_catch_clause* a cui è associato, fino a l'esecuzione di tale *blocco*, *for_Statement*, *switch_Statement*, *using_statement*, *foreach_statement*o *specific_catch_clause* termina in qualsiasi modo.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-167">This lifetime extends at least from entry into the *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* with which it is associated, until execution of that *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* ends in any way.</span></span> <span data-ttu-id="6aa6a-168">(L'immissione di un *blocco* racchiuso o la chiamata di un metodo viene sospesa, ma non termina, l'esecuzione del *blocco*corrente, *for_Statement*, *switch_Statement*, *using_statement*, *foreach_statement*o *specific_ catch_clause*.) Se la variabile locale viene acquisita da una funzione anonima ([variabili esterne acquisite](expressions.md#captured-outer-variables)), la durata si estende almeno fino a quando il delegato o l'albero delle espressioni creato dalla funzione anonima, insieme ad altri oggetti che fanno riferimento al la variabile acquisita è idonea per Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-168">(Entering an enclosed *block* or calling a method suspends, but does not end, execution of the current *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause*.) If the local variable is captured by an anonymous function ([Captured outer variables](expressions.md#captured-outer-variables)), its lifetime extends at least until the delegate or expression tree created from the anonymous function, along with any other objects that come to reference the captured variable, are eligible for garbage collection.</span></span>

<span data-ttu-id="6aa6a-169">Se il *blocco*padre, *for_Statement*, *switch_Statement*, *using_statement*, *foreach_statement*o *specific_catch_clause* viene immesso in modo ricorsivo, viene creata una nuova istanza della variabile locale Time e il relativo *local_variable_initializer*, se presente, viene valutato ogni volta.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-169">If the parent *block*, *for_statement*, *switch_statement*, *using_statement*, *foreach_statement*, or *specific_catch_clause* is entered recursively, a new instance of the local variable is created each time, and its *local_variable_initializer*, if any, is evaluated each time.</span></span>

<span data-ttu-id="6aa6a-170">Una variabile locale introdotta da un *local_variable_declaration* non viene inizializzata automaticamente e pertanto non ha alcun valore predefinito.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-170">A local variable introduced by a *local_variable_declaration* is not automatically initialized and thus has no default value.</span></span> <span data-ttu-id="6aa6a-171">Ai fini del controllo di assegnazione definito, una variabile locale introdotta da un *local_variable_declaration* viene considerata inizialmente non assegnata.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-171">For the purpose of definite assignment checking, a local variable introduced by a *local_variable_declaration* is considered initially unassigned.</span></span> <span data-ttu-id="6aa6a-172">Un *local_variable_declaration* può includere un *local_variable_initializer*, nel qual caso la variabile viene considerata assegnata definitivamente solo dopo l'espressione di inizializzazione ([istruzioni di dichiarazione](variables.md#declaration-statements)).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-172">A *local_variable_declaration* may include a *local_variable_initializer*, in which case the variable is considered definitely assigned only after the initializing expression ([Declaration statements](variables.md#declaration-statements)).</span></span>

<span data-ttu-id="6aa6a-173">Nell'ambito di una variabile locale introdotta da un *local_variable_declaration*, si tratta di un errore in fase di compilazione per fare riferimento a tale variabile locale in una posizione testuale che precede il *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-173">Within the scope of a local variable introduced by a *local_variable_declaration*, it is a compile-time error to refer to that local variable in a textual position that precedes its *local_variable_declarator*.</span></span> <span data-ttu-id="6aa6a-174">Se la dichiarazione di variabile locale è implicita ([dichiarazioni di variabili locali](statements.md#local-variable-declarations)), è anche un errore fare riferimento alla variabile all'interno di *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-174">If the local variable declaration is implicit ([Local variable declarations](statements.md#local-variable-declarations)), it is also an error to refer to the variable within its *local_variable_declarator*.</span></span>

<span data-ttu-id="6aa6a-175">Una variabile locale introdotta da un *foreach_statement* o un *specific_catch_clause* viene considerata definitivamente assegnata nell'intero ambito.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-175">A local variable introduced by a *foreach_statement* or a *specific_catch_clause* is considered definitely assigned in its entire scope.</span></span>

<span data-ttu-id="6aa6a-176">La durata effettiva di una variabile locale è dipendente dall'implementazione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-176">The actual lifetime of a local variable is implementation-dependent.</span></span> <span data-ttu-id="6aa6a-177">Un compilatore, ad esempio, potrebbe determinare in modo statico che una variabile locale in un blocco viene utilizzata solo per una piccola parte di tale blocco.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-177">For example, a compiler might statically determine that a local variable in a block is only used for a small portion of that block.</span></span> <span data-ttu-id="6aa6a-178">Utilizzando questa analisi, il compilatore potrebbe generare codice che comportano una durata più breve del relativo spazio di archiviazione della variabile rispetto al blocco che lo contiene.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-178">Using this analysis, the compiler could generate code that results in the variable's storage having a shorter lifetime than its containing block.</span></span>

<span data-ttu-id="6aa6a-179">Lo spazio di archiviazione a cui fa riferimento una variabile di riferimento locale viene recuperato indipendentemente dalla durata della variabile di riferimento locale ([gestione automatica della memoria](basic-concepts.md#automatic-memory-management)).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-179">The storage referred to by a local reference variable is reclaimed independently of the lifetime of that local reference variable ([Automatic memory management](basic-concepts.md#automatic-memory-management)).</span></span>

## <a name="default-values"></a><span data-ttu-id="6aa6a-180">Valori predefiniti</span><span class="sxs-lookup"><span data-stu-id="6aa6a-180">Default values</span></span>

<span data-ttu-id="6aa6a-181">Le seguenti categorie di variabili vengono inizializzate automaticamente sui rispettivi valori predefiniti:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-181">The following categories of variables are automatically initialized to their default values:</span></span>

*  <span data-ttu-id="6aa6a-182">Variabili statiche.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-182">Static variables.</span></span>
*  <span data-ttu-id="6aa6a-183">Variabili di istanza delle istanze della classe.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-183">Instance variables of class instances.</span></span>
*  <span data-ttu-id="6aa6a-184">Elementi di matrice.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-184">Array elements.</span></span>

<span data-ttu-id="6aa6a-185">Il valore predefinito di una variabile dipende dal tipo della variabile e viene determinato nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-185">The default value of a variable depends on the type of the variable and is determined as follows:</span></span>

*  <span data-ttu-id="6aa6a-186">Per una variabile di un *value_type*, il valore predefinito è lo stesso del valore calcolato dal costruttore predefinito di *value_type*([costruttori predefiniti](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-186">For a variable of a *value_type*, the default value is the same as the value computed by the *value_type*'s default constructor ([Default constructors](types.md#default-constructors)).</span></span>
*  <span data-ttu-id="6aa6a-187">Per una variabile di un *reference_type*, il valore predefinito è `null`.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-187">For a variable of a *reference_type*, the default value is `null`.</span></span>

<span data-ttu-id="6aa6a-188">L'inizializzazione dei valori predefiniti viene in genere eseguita con il gestore della memoria o Garbage Collector inizializzare la memoria su tutti i bit-zero prima che venga allocato per l'utilizzo.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-188">Initialization to default values is typically done by having the memory manager or garbage collector initialize memory to all-bits-zero before it is allocated for use.</span></span> <span data-ttu-id="6aa6a-189">Per questo motivo, è consigliabile utilizzare All-bits-zero per rappresentare il riferimento null.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-189">For this reason, it is convenient to use all-bits-zero to represent the null reference.</span></span>

## <a name="definite-assignment"></a><span data-ttu-id="6aa6a-190">Assegnazione definita</span><span class="sxs-lookup"><span data-stu-id="6aa6a-190">Definite assignment</span></span>

<span data-ttu-id="6aa6a-191">In una determinata posizione nel codice eseguibile di un membro di funzione, una variabile viene ***definita definitivamente assegnata*** se il compilatore è in grado di dimostrare, da un'analisi di flusso statica specifica ([regole precise per determinare l'assegnazione definita](variables.md#precise-rules-for-determining-definite-assignment)), che la variabile è stata inizializzata automaticamente o è stata la destinazione di almeno un'assegnazione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-191">At a given location in the executable code of a function member, a variable is said to be ***definitely assigned*** if the compiler can prove, by a particular static flow analysis ([Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment)), that the variable has been automatically initialized or has been the target of at least one assignment.</span></span> <span data-ttu-id="6aa6a-192">Dichiarate in modo informale, le regole di assegnazione definitiva sono:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-192">Informally stated, the rules of definite assignment are:</span></span>

*  <span data-ttu-id="6aa6a-193">Una variabile inizialmente assegnata (le[variabili assegnate inizialmente](variables.md#initially-assigned-variables)) viene sempre considerata definitivamente assegnata.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-193">An initially assigned variable ([Initially assigned variables](variables.md#initially-assigned-variables)) is always considered definitely assigned.</span></span>
*  <span data-ttu-id="6aa6a-194">Una variabile inizialmente non assegnata ([inizialmente variabili non assegnate](variables.md#initially-unassigned-variables)) viene considerata definitivamente assegnata in una determinata posizione se tutti i possibili percorsi di esecuzione che portano a tale posizione contengono almeno uno degli elementi seguenti:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-194">An initially unassigned variable ([Initially unassigned variables](variables.md#initially-unassigned-variables)) is considered definitely assigned at a given location if all possible execution paths leading to that location contain at least one of the following:</span></span>
    * <span data-ttu-id="6aa6a-195">Assegnazione semplice ([assegnazione semplice](expressions.md#simple-assignment)) in cui la variabile è l'operando sinistro.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-195">A simple assignment ([Simple assignment](expressions.md#simple-assignment)) in which the variable is the left operand.</span></span>
    * <span data-ttu-id="6aa6a-196">Espressione di chiamata ([espressioni di chiamata](expressions.md#invocation-expressions)) o espressione di creazione di oggetti (espressioni di[creazione di oggetti](expressions.md#object-creation-expressions)) che passa la variabile come parametro di output.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-196">An invocation expression ([Invocation expressions](expressions.md#invocation-expressions)) or object creation expression ([Object creation expressions](expressions.md#object-creation-expressions)) that passes the variable as an output parameter.</span></span>
    * <span data-ttu-id="6aa6a-197">Per una variabile locale, una dichiarazione di variabile locale ([dichiarazioni di variabili locali](statements.md#local-variable-declarations)) che include un inizializzatore di variabile.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-197">For a local variable, a local variable declaration ([Local variable declarations](statements.md#local-variable-declarations)) that includes a variable initializer.</span></span>

<span data-ttu-id="6aa6a-198">La specifica formale sottostante le regole informali precedenti è descritta in [variabili inizialmente assegnate](variables.md#initially-assigned-variables), [variabili inizialmente non assegnate](variables.md#initially-unassigned-variables)e [regole precise per determinare l'assegnazione definita](variables.md#precise-rules-for-determining-definite-assignment).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-198">The formal specification underlying the above informal rules is described in [Initially assigned variables](variables.md#initially-assigned-variables), [Initially unassigned variables](variables.md#initially-unassigned-variables), and [Precise rules for determining definite assignment](variables.md#precise-rules-for-determining-definite-assignment).</span></span>

<span data-ttu-id="6aa6a-199">Gli Stati di assegnazione definiti delle variabili di istanza di una variabile *struct_type* vengono rilevati singolarmente e collettivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-199">The definite assignment states of instance variables of a *struct_type* variable are tracked individually as well as collectively.</span></span> <span data-ttu-id="6aa6a-200">Oltre alle regole precedenti, le regole seguenti si applicano alle variabili *struct_type* e alle relative variabili di istanza:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-200">In addition to the rules above, the following rules apply to *struct_type* variables and their instance variables:</span></span>

*  <span data-ttu-id="6aa6a-201">Una variabile di istanza viene considerata definitivamente assegnata se la variabile *struct_type* che lo contiene viene considerata definitivamente assegnata.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-201">An instance variable is considered definitely assigned if its containing *struct_type* variable is considered definitely assigned.</span></span>
*  <span data-ttu-id="6aa6a-202">Una variabile *struct_type* viene considerata definitivamente assegnata se ogni variabile di istanza viene considerata assegnata definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-202">A *struct_type* variable is considered definitely assigned if each of its instance variables is considered definitely assigned.</span></span>

<span data-ttu-id="6aa6a-203">L'assegnazione definita è un requisito nei contesti seguenti:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-203">Definite assignment is a requirement in the following contexts:</span></span>

*  <span data-ttu-id="6aa6a-204">Una variabile deve essere assegnata in modo sicuro in ogni posizione in cui viene ottenuto il relativo valore.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-204">A variable must be definitely assigned at each location where its value is obtained.</span></span> <span data-ttu-id="6aa6a-205">In questo modo si garantisce che non si verifichino mai valori non definiti.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-205">This ensures that undefined values never occur.</span></span> <span data-ttu-id="6aa6a-206">L'occorrenza di una variabile in un'espressione viene considerata come ottenere il valore della variabile, tranne quando</span><span class="sxs-lookup"><span data-stu-id="6aa6a-206">The occurrence of a variable in an expression is considered to obtain the value of the variable, except when</span></span>
    * <span data-ttu-id="6aa6a-207">la variabile è l'operando sinistro di un'assegnazione semplice,</span><span class="sxs-lookup"><span data-stu-id="6aa6a-207">the variable is the left operand of a simple assignment,</span></span>
    * <span data-ttu-id="6aa6a-208">la variabile viene passata come parametro di output o</span><span class="sxs-lookup"><span data-stu-id="6aa6a-208">the variable is passed as an output parameter, or</span></span>
    * <span data-ttu-id="6aa6a-209">la variabile è una variabile *struct_type* e si verifica come operando sinistro di un accesso ai membri.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-209">the variable is a *struct_type* variable and occurs as the left operand of a member access.</span></span>
*  <span data-ttu-id="6aa6a-210">Una variabile deve essere assegnata in modo sicuro in ogni posizione in cui viene passata come parametro di riferimento.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-210">A variable must be definitely assigned at each location where it is passed as a reference parameter.</span></span> <span data-ttu-id="6aa6a-211">In questo modo il membro della funzione richiamato può considerare il parametro di riferimento inizialmente assegnato.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-211">This ensures that the function member being invoked can consider the reference parameter initially assigned.</span></span>
*  <span data-ttu-id="6aa6a-212">Tutti i parametri di output di un membro di funzione devono essere assegnati in modo sicuro in ogni posizione in cui il `return` membro della funzione restituisce (tramite un'istruzione o tramite l'esecuzione che raggiunge la fine del corpo del membro della funzione).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-212">All output parameters of a function member must be definitely assigned at each location where the function member returns (through a `return` statement or through execution reaching the end of the function member body).</span></span> <span data-ttu-id="6aa6a-213">Ciò garantisce che i membri di funzione non restituiscano valori non definiti nei parametri di output, consentendo al compilatore di prendere in considerazione la chiamata di un membro di funzione che accetta una variabile come parametro di output equivalente a un'assegnazione alla variabile.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-213">This ensures that function members do not return undefined values in output parameters, thus enabling the compiler to consider a function member invocation that takes a variable as an output parameter equivalent to an assignment to the variable.</span></span>
*  <span data-ttu-id="6aa6a-214">La `this` variabile di un costruttore di istanza di *struct_type* deve essere assegnata in modo sicuro in ogni posizione in cui il costruttore dell'istanza restituisce.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-214">The `this` variable of a *struct_type* instance constructor must be definitely assigned at each location where that instance constructor returns.</span></span>

### <a name="initially-assigned-variables"></a><span data-ttu-id="6aa6a-215">Variabili assegnate inizialmente</span><span class="sxs-lookup"><span data-stu-id="6aa6a-215">Initially assigned variables</span></span>

<span data-ttu-id="6aa6a-216">Le categorie di variabili seguenti sono classificate inizialmente come assegnate:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-216">The following categories of variables are classified as initially assigned:</span></span>

*  <span data-ttu-id="6aa6a-217">Variabili statiche.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-217">Static variables.</span></span>
*  <span data-ttu-id="6aa6a-218">Variabili di istanza delle istanze della classe.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-218">Instance variables of class instances.</span></span>
*  <span data-ttu-id="6aa6a-219">Variabili di istanza delle variabili struct inizialmente assegnate.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-219">Instance variables of initially assigned struct variables.</span></span>
*  <span data-ttu-id="6aa6a-220">Elementi di matrice.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-220">Array elements.</span></span>
*  <span data-ttu-id="6aa6a-221">Parametri del valore.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-221">Value parameters.</span></span>
*  <span data-ttu-id="6aa6a-222">Parametri di riferimento.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-222">Reference parameters.</span></span>
*  <span data-ttu-id="6aa6a-223">Variabili dichiarate `catch` in una clausola `foreach` o in un'istruzione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-223">Variables declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="initially-unassigned-variables"></a><span data-ttu-id="6aa6a-224">Variabili inizialmente non assegnate</span><span class="sxs-lookup"><span data-stu-id="6aa6a-224">Initially unassigned variables</span></span>

<span data-ttu-id="6aa6a-225">Le categorie di variabili seguenti sono classificate inizialmente come non assegnate:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-225">The following categories of variables are classified as initially unassigned:</span></span>

*  <span data-ttu-id="6aa6a-226">Variabili di istanza di variabili struct inizialmente non assegnate.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-226">Instance variables of initially unassigned struct variables.</span></span>
*  <span data-ttu-id="6aa6a-227">Parametri di output, inclusa `this` la variabile dei costruttori di istanze struct.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-227">Output parameters, including the `this` variable of struct instance constructors.</span></span>
*  <span data-ttu-id="6aa6a-228">Variabili locali, ad eccezione di quelle dichiarate in `foreach` una `catch` clausola o in un'istruzione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-228">Local variables, except those declared in a `catch` clause or a `foreach` statement.</span></span>

### <a name="precise-rules-for-determining-definite-assignment"></a><span data-ttu-id="6aa6a-229">Regole precise per determinare l'assegnazione definitiva</span><span class="sxs-lookup"><span data-stu-id="6aa6a-229">Precise rules for determining definite assignment</span></span>

<span data-ttu-id="6aa6a-230">Per determinare che ogni variabile utilizzata è assegnata definitivamente, il compilatore deve usare un processo equivalente a quello descritto in questa sezione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-230">In order to determine that each used variable is definitely assigned, the compiler must use a process that is equivalent to the one described in this section.</span></span>

<span data-ttu-id="6aa6a-231">Il compilatore elabora il corpo di ogni membro di funzione che dispone di una o più variabili inizialmente non assegnate.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-231">The compiler processes the body of each function member that has one or more initially unassigned variables.</span></span> <span data-ttu-id="6aa6a-232">Per ogni variabile inizialmente non assegnata *v*, il compilatore determina uno ***stato di assegnazione definito*** per *v* in ognuno dei punti seguenti del membro della funzione:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-232">For each initially unassigned variable *v*, the compiler determines a ***definite assignment state*** for *v* at each of the following points in the function member:</span></span>

*  <span data-ttu-id="6aa6a-233">All'inizio di ogni istruzione</span><span class="sxs-lookup"><span data-stu-id="6aa6a-233">At the beginning of each statement</span></span>
*  <span data-ttu-id="6aa6a-234">Al punto finale ([punti finali e raggiungibilità](statements.md#end-points-and-reachability)) di ogni istruzione</span><span class="sxs-lookup"><span data-stu-id="6aa6a-234">At the end point ([End points and reachability](statements.md#end-points-and-reachability)) of each statement</span></span>
*  <span data-ttu-id="6aa6a-235">In ogni arco che trasferisce il controllo a un'altra istruzione o al punto finale di un'istruzione</span><span class="sxs-lookup"><span data-stu-id="6aa6a-235">On each arc which transfers control to another statement or to the end point of a statement</span></span>
*  <span data-ttu-id="6aa6a-236">All'inizio di ogni espressione</span><span class="sxs-lookup"><span data-stu-id="6aa6a-236">At the beginning of each expression</span></span>
*  <span data-ttu-id="6aa6a-237">Alla fine di ogni espressione</span><span class="sxs-lookup"><span data-stu-id="6aa6a-237">At the end of each expression</span></span>

<span data-ttu-id="6aa6a-238">Lo stato di assegnazione definito di *v* può essere uno dei seguenti:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-238">The definite assignment state of *v* can be either:</span></span>

*  <span data-ttu-id="6aa6a-239">Assegnato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-239">Definitely assigned.</span></span> <span data-ttu-id="6aa6a-240">Ciò indica che in tutti i flussi di controllo possibili fino a questo punto è stato assegnato un valore a *v* .</span><span class="sxs-lookup"><span data-stu-id="6aa6a-240">This indicates that on all possible control flows to this point, *v* has been assigned a value.</span></span>
*  <span data-ttu-id="6aa6a-241">Non assegnato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-241">Not definitely assigned.</span></span> <span data-ttu-id="6aa6a-242">Per lo stato di una variabile alla fine di un'espressione di tipo `bool`, lo stato di una variabile che non è assegnata definitivamente può (ma non necessariamente) rientrare in uno degli stati secondari seguenti:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-242">For the state of a variable at the end of an expression of type `bool`, the state of a variable that isn't definitely assigned may (but doesn't necessarily) fall into one of the following sub-states:</span></span>
    * <span data-ttu-id="6aa6a-243">Assegnato definitivamente dopo un'espressione true.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-243">Definitely assigned after true expression.</span></span> <span data-ttu-id="6aa6a-244">Questo stato indica che *v* viene assegnato definitivamente se l'espressione booleana è stata valutata come true, ma non è necessariamente assegnata se l'espressione booleana viene valutata come false.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-244">This state indicates that *v* is definitely assigned if the boolean expression evaluated as true, but is not necessarily assigned if the boolean expression evaluated as false.</span></span>
    * <span data-ttu-id="6aa6a-245">Assegnato definitivamente dopo un'espressione false.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-245">Definitely assigned after false expression.</span></span> <span data-ttu-id="6aa6a-246">Questo stato indica che *v* viene assegnato definitivamente se l'espressione booleana viene valutata come false, ma non viene necessariamente assegnata se l'espressione booleana restituisce true.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-246">This state indicates that *v* is definitely assigned if the boolean expression evaluated as false, but is not necessarily assigned if the boolean expression evaluated as true.</span></span>

<span data-ttu-id="6aa6a-247">Le regole seguenti determinano il modo in cui viene determinato lo stato di una variabile *v* in ogni posizione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-247">The following rules govern how the state of a variable *v* is determined at each location.</span></span>

#### <a name="general-rules-for-statements"></a><span data-ttu-id="6aa6a-248">Regole generali per le istruzioni</span><span class="sxs-lookup"><span data-stu-id="6aa6a-248">General rules for statements</span></span>

*  <span data-ttu-id="6aa6a-249">*v* non viene assegnato definitivamente all'inizio del corpo di un membro di funzione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-249">*v* is not definitely assigned at the beginning of a function member body.</span></span>
*  <span data-ttu-id="6aa6a-250">*v* viene assegnato definitivamente all'inizio di un'istruzione non raggiungibile.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-250">*v* is definitely assigned at the beginning of any unreachable statement.</span></span>
*  <span data-ttu-id="6aa6a-251">Lo stato di assegnazione definito di *v* all'inizio di qualsiasi altra istruzione è determinato dal controllo dello stato di assegnazione definito di *v* in tutti i trasferimenti di flusso di controllo destinati all'inizio dell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-251">The definite assignment state of *v* at the beginning of any other statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the beginning of that statement.</span></span> <span data-ttu-id="6aa6a-252">Se (e solo se) *v* viene assegnato in modo sicuro a tutti questi trasferimenti del flusso di controllo, *v* viene assegnato definitivamente all'inizio dell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-252">If (and only if) *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the beginning of the statement.</span></span> <span data-ttu-id="6aa6a-253">Il set di possibili trasferimenti del flusso di controllo viene determinato in modo analogo al controllo della raggiungibilità delle istruzioni ([punti finali e raggiungibilità](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-253">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>
*  <span data-ttu-id="6aa6a-254">Stato di assegnazione definito di *v* in corrispondenza del punto finale di un blocco `checked`, `unchecked` `do`, `if` `foreach` `for` `while`,,,,, `lock`, `using`, o `switch`l'istruzione viene determinata controllando lo stato di assegnazione definito di *v* in tutti i trasferimenti del flusso di controllo che hanno come destinazione il punto finale dell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-254">The definite assignment state of *v* at the end point of a block, `checked`, `unchecked`, `if`, `while`, `do`, `for`, `foreach`, `lock`, `using`, or `switch` statement is determined by checking the definite assignment state of *v* on all control flow transfers that target the end point of that statement.</span></span> <span data-ttu-id="6aa6a-255">Se *v* è assegnato definitivamente a tutti questi trasferimenti del flusso di controllo, *v* viene assegnato definitivamente al punto finale dell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-255">If *v* is definitely assigned on all such control flow transfers, then *v* is definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="6aa6a-256">In caso contrario *v* non è assegnato definitivamente al punto finale dell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-256">Otherwise; *v* is not definitely assigned at the end point of the statement.</span></span> <span data-ttu-id="6aa6a-257">Il set di possibili trasferimenti del flusso di controllo viene determinato in modo analogo al controllo della raggiungibilità delle istruzioni ([punti finali e raggiungibilità](statements.md#end-points-and-reachability)).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-257">The set of possible control flow transfers is determined in the same way as for checking statement reachability ([End points and reachability](statements.md#end-points-and-reachability)).</span></span>

#### <a name="block-statements-checked-and-unchecked-statements"></a><span data-ttu-id="6aa6a-258">Istruzioni Block, checked e unchecked</span><span class="sxs-lookup"><span data-stu-id="6aa6a-258">Block statements, checked, and unchecked statements</span></span>

<span data-ttu-id="6aa6a-259">Lo stato di assegnazione definito di *v* nel controllo viene trasferito alla prima istruzione dell'elenco di istruzioni nel blocco (o al punto finale del blocco, se l'elenco di istruzioni è vuoto) equivale all'istruzione di assegnazione definita di *v* prima del blocco istruzione `checked`, o `unchecked` .</span><span class="sxs-lookup"><span data-stu-id="6aa6a-259">The definite assignment state of *v* on the control transfer to the first statement of the statement list in the block (or to the end point of the block, if the statement list is empty) is the same as the definite assignment statement of *v* before the block, `checked`, or `unchecked` statement.</span></span>

#### <a name="expression-statements"></a><span data-ttu-id="6aa6a-260">Istruzioni di espressione</span><span class="sxs-lookup"><span data-stu-id="6aa6a-260">Expression statements</span></span>

<span data-ttu-id="6aa6a-261">Per un'istruzione di espressione *stmt* costituita dall'espressione *expr*:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-261">For an expression statement *stmt* that consists of the expression *expr*:</span></span>

*  <span data-ttu-id="6aa6a-262">*v* ha lo stesso stato di assegnazione definita all'inizio di *expr* come all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-262">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-263">Se *v* viene assegnato definitivamente alla fine di *expr*, viene assegnato definitivamente al punto finale di *stmt*; in caso contrario non viene assegnato definitivamente al punto finale di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-263">If *v* if definitely assigned at the end of *expr*, it is definitely assigned at the end point of *stmt*; otherwise; it is not definitely assigned at the end point of *stmt*.</span></span>

#### <a name="declaration-statements"></a><span data-ttu-id="6aa6a-264">Istruzioni di dichiarazione</span><span class="sxs-lookup"><span data-stu-id="6aa6a-264">Declaration statements</span></span>

*  <span data-ttu-id="6aa6a-265">Se *stmt* è un'istruzione di dichiarazione senza inizializzatori, *v* ha lo stesso stato di assegnazione definito al punto finale di *stmt* come all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-265">If *stmt* is a declaration statement without initializers, then *v* has the same definite assignment state at the end point of *stmt* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-266">Se *stmt* è un'istruzione di dichiarazione con inizializzatori, lo stato di assegnazione definito per *v* viene determinato come se *stmt* fosse un elenco di istruzioni, con un'istruzione di assegnazione per ogni dichiarazione con un inizializzatore (nell'ordine di Dichiarazione).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-266">If *stmt* is a declaration statement with initializers, then the definite assignment state for *v* is determined as if *stmt* were a statement list, with one assignment statement for each declaration with an initializer (in the order of declaration).</span></span>

#### <a name="if-statements"></a><span data-ttu-id="6aa6a-267">Istruzioni If</span><span class="sxs-lookup"><span data-stu-id="6aa6a-267">If statements</span></span>

<span data-ttu-id="6aa6a-268">Per un' `if` istruzione *stmt* nel formato:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-268">For an `if` statement *stmt* of the form:</span></span>
```csharp
if ( expr ) then_stmt else else_stmt
```

*  <span data-ttu-id="6aa6a-269">*v* ha lo stesso stato di assegnazione definita all'inizio di *expr* come all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-269">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-270">Se la *v* viene assegnata definitivamente alla fine di *expr*, viene definitivamente assegnata al trasferimento del flusso di controllo a *then_stmt* e a *else_stmt* o all'endpoint di *stmt* se non è presente alcuna clausola else.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-270">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt* and to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="6aa6a-271">Se *v* ha lo stato "assegnato definitivamente dopo l'espressione true" alla fine di *expr*, viene definitivamente assegnato al trasferimento del flusso di controllo a *then_stmt*e non è assegnato definitivamente al trasferimento del flusso di controllo a *else_ stmt* o all'endpoint di *stmt* se non è presente alcuna clausola else.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-271">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *then_stmt*, and not definitely assigned on the control flow transfer to either *else_stmt* or to the end-point of *stmt* if there is no else clause.</span></span>
*  <span data-ttu-id="6aa6a-272">Se *v* ha lo stato "assegnata in modo definitivo dopo false Expression" alla fine di *expr*, viene definitivamente assegnato al trasferimento del flusso di controllo a *else_stmt*e non assegnato definitivamente al trasferimento del flusso di controllo a *then_stmt* .</span><span class="sxs-lookup"><span data-stu-id="6aa6a-272">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *else_stmt*, and not definitely assigned on the control flow transfer to *then_stmt*.</span></span> <span data-ttu-id="6aa6a-273">Viene assegnato in modo sicuro all'endpoint di *stmt* , se e solo se viene assegnato definitivamente all'endpoint di *then_stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-273">It is definitely assigned at the end-point of *stmt* if and only if it is definitely assigned at the end-point of *then_stmt*.</span></span>
*  <span data-ttu-id="6aa6a-274">In caso contrario, *v* viene considerato non assegnato definitivamente al trasferimento del flusso di controllo a *then_stmt* o *else_stmt*oppure all'endpoint di *stmt* se non è presente alcuna clausola else.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-274">Otherwise, *v* is considered not definitely assigned on the control flow transfer to either the *then_stmt* or *else_stmt*, or to the end-point of *stmt* if there is no else clause.</span></span>

#### <a name="switch-statements"></a><span data-ttu-id="6aa6a-275">Istruzioni switch</span><span class="sxs-lookup"><span data-stu-id="6aa6a-275">Switch statements</span></span>

<span data-ttu-id="6aa6a-276">In un' `switch` istruzione *stmt* con un'espressione di controllo *expr*:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-276">In a `switch` statement *stmt* with a controlling expression *expr*:</span></span>

*  <span data-ttu-id="6aa6a-277">Lo stato di assegnazione definito di *v* all'inizio di *expr* corrisponde allo stato di *v* all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-277">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-278">Lo stato di assegnazione definito di *v* nel trasferimento del flusso di controllo a un elenco di istruzioni switch Block raggiungibili è identico allo stato di assegnazione definito di *v* alla fine di *expr*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-278">The definite assignment state of *v* on the control flow transfer to a reachable switch block statement list is the same as the definite assignment state of *v* at the end of *expr*.</span></span>

#### <a name="while-statements"></a><span data-ttu-id="6aa6a-279">Istruzioni while</span><span class="sxs-lookup"><span data-stu-id="6aa6a-279">While statements</span></span>

<span data-ttu-id="6aa6a-280">Per un' `while` istruzione *stmt* nel formato:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-280">For a `while` statement *stmt* of the form:</span></span>
```csharp
while ( expr ) while_body
```

*  <span data-ttu-id="6aa6a-281">*v* ha lo stesso stato di assegnazione definita all'inizio di *expr* come all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-281">*v* has the same definite assignment state at the beginning of *expr* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-282">Se la *v* viene assegnata definitivamente alla fine di *expr*, viene definitivamente assegnata al trasferimento del flusso di controllo a *while_body* e al punto finale di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-282">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body* and to the end point of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-283">Se *v* ha lo stato "assegnato definitivamente dopo l'espressione true" alla fine di *expr*, viene definitivamente assegnato al trasferimento del flusso di controllo a *while_body*, ma non assegnato definitivamente all'endpoint di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-283">If *v* has the state "definitely assigned after true expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to *while_body*, but not definitely assigned at the end-point of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-284">Se *v* ha lo stato "assegnata in modo definitivo dopo false Expression" alla fine di *expr*, viene definitivamente assegnato nel trasferimento del flusso di controllo al punto finale di *stmt*, ma non è stato assegnato in modo definitivo sul trasferimento del flusso di controllo a *while _body*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-284">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*, but not definitely assigned on the control flow transfer to *while_body*.</span></span>

#### <a name="do-statements"></a><span data-ttu-id="6aa6a-285">Istruzioni do</span><span class="sxs-lookup"><span data-stu-id="6aa6a-285">Do statements</span></span>

<span data-ttu-id="6aa6a-286">Per un' `do` istruzione *stmt* nel formato:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-286">For a `do` statement *stmt* of the form:</span></span>
```csharp
do do_body while ( expr ) ;
```

*  <span data-ttu-id="6aa6a-287">*v* ha lo stesso stato di assegnazione definito nel trasferimento del flusso di controllo dall'inizio di *stmt* a *do_body* come all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-287">*v* has the same definite assignment state on the control flow transfer from the beginning of *stmt* to *do_body* as at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-288">*v* ha lo stesso stato di assegnazione definita all'inizio di *expr* come nel punto finale di *do_body*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-288">*v* has the same definite assignment state at the beginning of *expr* as at the end point of *do_body*.</span></span>
*  <span data-ttu-id="6aa6a-289">Se la *v* viene assegnata definitivamente alla fine di *expr*, viene definitivamente assegnata al punto finale di *stmt*nel trasferimento del flusso di controllo.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-289">If *v* is definitely assigned at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-290">Se *v* ha lo stato "definitely Assigned after false Expression" alla fine di *expr*, viene assegnato definitivamente nel trasferimento del flusso di controllo al punto finale di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-290">If *v* has the state "definitely assigned after false expression" at the end of *expr*, then it is definitely assigned on the control flow transfer to the end point of *stmt*.</span></span>

#### <a name="for-statements"></a><span data-ttu-id="6aa6a-291">Istruzioni for</span><span class="sxs-lookup"><span data-stu-id="6aa6a-291">For statements</span></span>

<span data-ttu-id="6aa6a-292">Controllo di assegnazione definito per `for` un'istruzione nel formato:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-292">Definite assignment checking for a `for` statement of the form:</span></span>
```csharp
for ( for_initializer ; for_condition ; for_iterator ) embedded_statement
```
<span data-ttu-id="6aa6a-293">viene eseguita come se l'istruzione fosse scritta:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-293">is done as if the statement were written:</span></span>
```csharp
{
    for_initializer ;
    while ( for_condition ) {
        embedded_statement ;
        for_iterator ;
    }
}
```

<span data-ttu-id="6aa6a-294">Se *for_condition* viene omesso dall' `for` istruzione, la valutazione dell'assegnazione definita procede come se *for_condition* venisse sostituito con `true` nell'espansione precedente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-294">If the *for_condition* is omitted from the `for` statement, then evaluation of definite assignment proceeds as if *for_condition* were replaced with `true` in the above expansion.</span></span>

#### <a name="break-continue-and-goto-statements"></a><span data-ttu-id="6aa6a-295">Istruzioni break, continue e GOTO</span><span class="sxs-lookup"><span data-stu-id="6aa6a-295">Break, continue, and goto statements</span></span>

<span data-ttu-id="6aa6a-296">Lo stato di assegnazione definito di *v* nel trasferimento del flusso di controllo causato `break`da un'istruzione `goto` , `continue`o equivale allo stato di assegnazione definito di *v* all'inizio dell'istruzione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-296">The definite assignment state of *v* on the control flow transfer caused by a `break`, `continue`, or `goto` statement is the same as the definite assignment state of *v* at the beginning of the statement.</span></span>

#### <a name="throw-statements"></a><span data-ttu-id="6aa6a-297">Istruzioni throw</span><span class="sxs-lookup"><span data-stu-id="6aa6a-297">Throw statements</span></span>

<span data-ttu-id="6aa6a-298">Per un'istruzione *stmt* nel formato</span><span class="sxs-lookup"><span data-stu-id="6aa6a-298">For a statement *stmt* of the form</span></span>
```csharp
throw expr ;
```

<span data-ttu-id="6aa6a-299">Lo stato di assegnazione definito di *v* all'inizio di *expr* corrisponde allo stato di assegnazione definito di *v* all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-299">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>

#### <a name="return-statements"></a><span data-ttu-id="6aa6a-300">Istruzioni return</span><span class="sxs-lookup"><span data-stu-id="6aa6a-300">Return statements</span></span>

<span data-ttu-id="6aa6a-301">Per un'istruzione *stmt* nel formato</span><span class="sxs-lookup"><span data-stu-id="6aa6a-301">For a statement *stmt* of the form</span></span>
```csharp
return expr ;
```

*  <span data-ttu-id="6aa6a-302">Lo stato di assegnazione definito di *v* all'inizio di *expr* corrisponde allo stato di assegnazione definito di *v* all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-302">The definite assignment state of *v* at the beginning of *expr* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-303">Se *v* è un parametro di output, è necessario che sia assegnato definitivamente quanto segue:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-303">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="6aa6a-304">dopo *expr*</span><span class="sxs-lookup"><span data-stu-id="6aa6a-304">after *expr*</span></span>
    * <span data-ttu-id="6aa6a-305">o alla fine del `finally` blocco di un oggetto `try` - ocheracchiude`return` l'istruzione. `catch` `try` - `finally` - `finally`</span><span class="sxs-lookup"><span data-stu-id="6aa6a-305">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

<span data-ttu-id="6aa6a-306">Per un'istruzione stmt nel formato:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-306">For a statement stmt of the form:</span></span>
```csharp
return ;
```

*  <span data-ttu-id="6aa6a-307">Se *v* è un parametro di output, è necessario che sia assegnato definitivamente quanto segue:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-307">If *v* is an output parameter, then it must be definitely assigned either:</span></span>
    * <span data-ttu-id="6aa6a-308">prima di *stmt*</span><span class="sxs-lookup"><span data-stu-id="6aa6a-308">before *stmt*</span></span>
    * <span data-ttu-id="6aa6a-309">o alla fine del `finally` blocco di un oggetto `try` - ocheracchiude`return` l'istruzione. `catch` `try` - `finally` - `finally`</span><span class="sxs-lookup"><span data-stu-id="6aa6a-309">or at the end of the `finally` block of a `try`-`finally` or `try`-`catch`-`finally` that encloses the `return` statement.</span></span>

#### <a name="try-catch-statements"></a><span data-ttu-id="6aa6a-310">Istruzioni try-catch</span><span class="sxs-lookup"><span data-stu-id="6aa6a-310">Try-catch statements</span></span>

<span data-ttu-id="6aa6a-311">Per un'istruzione *stmt* nel formato:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-311">For a statement *stmt* of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
```

*  <span data-ttu-id="6aa6a-312">Lo stato di assegnazione definito di *v* all'inizio di *try_block* è lo stesso dello stato di assegnazione definito di *v* all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-312">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-313">Lo stato di assegnazione definito di *v* all'inizio di *catch_block_i* (per qualsiasi *i*) corrisponde allo stato di assegnazione definito di *v* all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-313">The definite assignment state of *v* at the beginning of *catch_block_i* (for any *i*) is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-314">Lo stato di assegnazione definito di *v* all'endpoint di *stmt* viene assegnato definitivamente se (e solo se) *v* viene assegnato definitivamente all'endpoint di *try_block* e ogni *catch_block_i* (per ogni *i* da 1 a *n* ).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-314">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) *v* is definitely assigned at the end-point of *try_block* and every *catch_block_i* (for every *i* from 1 to *n*).</span></span>

#### <a name="try-finally-statements"></a><span data-ttu-id="6aa6a-315">Istruzioni try-finally</span><span class="sxs-lookup"><span data-stu-id="6aa6a-315">Try-finally statements</span></span>

<span data-ttu-id="6aa6a-316">Per un' `try` istruzione *stmt* nel formato:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-316">For a `try` statement *stmt* of the form:</span></span>
```csharp
try try_block finally finally_block
```

*  <span data-ttu-id="6aa6a-317">Lo stato di assegnazione definito di *v* all'inizio di *try_block* è lo stesso dello stato di assegnazione definito di *v* all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-317">The definite assignment state of *v* at the beginning of *try_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-318">Lo stato di assegnazione definito di *v* all'inizio di *finally_block* è lo stesso dello stato di assegnazione definito di *v* all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-318">The definite assignment state of *v* at the beginning of *finally_block* is the same as the definite assignment state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-319">Lo stato di assegnazione definito di *v* all'endpoint di *stmt* viene assegnato definitivamente se (e solo se) viene soddisfatta almeno una delle condizioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-319">The definite assignment state of *v* at the end-point of *stmt* is definitely assigned if (and only if) at least one of the following is true:</span></span>
    * <span data-ttu-id="6aa6a-320">*v* viene assegnato definitivamente all'endpoint di *try_block*</span><span class="sxs-lookup"><span data-stu-id="6aa6a-320">*v* is definitely assigned at the end-point of *try_block*</span></span>
    * <span data-ttu-id="6aa6a-321">*v* viene assegnato definitivamente all'endpoint di *finally_block*</span><span class="sxs-lookup"><span data-stu-id="6aa6a-321">*v* is definitely assigned at the end-point of *finally_block*</span></span>

<span data-ttu-id="6aa6a-322">Se viene eseguito il trasferimento di un flusso di controllo `goto` (ad esempio, un'istruzione) che inizia all'interno di *try_block*e termina all'esterno di *try_block*, *v* viene anche considerato definitivamente assegnato a tale trasferimento del flusso di controllo se *v* è assegnato definitivamente all'endpoint di *finally_block*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-322">If a control flow transfer (for example, a `goto` statement) is made that begins within *try_block*, and ends outside of *try_block*, then *v* is also considered definitely assigned on that control flow transfer if *v* is definitely assigned at the end-point of *finally_block*.</span></span> <span data-ttu-id="6aa6a-323">(Non si tratta di un solo se, se *v* è assegnato definitivamente per un altro motivo in questo trasferimento del flusso di controllo, viene comunque considerato assegnato definitivamente).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-323">(This is not an only if—if *v* is definitely assigned for another reason on this control flow transfer, then it is still considered definitely assigned.)</span></span>

#### <a name="try-catch-finally-statements"></a><span data-ttu-id="6aa6a-324">Istruzioni try-catch-finally</span><span class="sxs-lookup"><span data-stu-id="6aa6a-324">Try-catch-finally statements</span></span>

<span data-ttu-id="6aa6a-325">Analisi di assegnazione definita per `try` un' - `catch` - istruzione nelformato:`finally`</span><span class="sxs-lookup"><span data-stu-id="6aa6a-325">Definite assignment analysis for a `try`-`catch`-`finally` statement of the form:</span></span>
```csharp
try try_block
catch(...) catch_block_1
...
catch(...) catch_block_n
finally *finally_block*
```
<span data-ttu-id="6aa6a-326">viene eseguita come se l'istruzione fosse un' `try` - `try` - `finally` istruzione che include un' `catch` istruzione:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-326">is done as if the statement were a `try`-`finally` statement enclosing a `try`-`catch` statement:</span></span>
```csharp
try {
    try try_block
    catch(...) catch_block_1
    ...
    catch(...) catch_block_n
}
finally finally_block
```

<span data-ttu-id="6aa6a-327">Nell'esempio seguente viene illustrato il modo in cui i `try` diversi blocchi di un'istruzione ([istruzione try](statements.md#the-try-statement)) influiscono sull'assegnazione definita.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-327">The following example demonstrates how the different blocks of a `try` statement ([The try statement](statements.md#the-try-statement)) affect definite assignment.</span></span>
```csharp
class A
{
    static void F() {
        int i, j;
        try {
            goto LABEL;
            // neither i nor j definitely assigned
            i = 1;
            // i definitely assigned
        }

        catch {
            // neither i nor j definitely assigned
            i = 3;
            // i definitely assigned
        }

        finally {
            // neither i nor j definitely assigned
            j = 5;
            // j definitely assigned
            }
        // i and j definitely assigned
        LABEL:;
        // j definitely assigned

    }
}
```

#### <a name="foreach-statements"></a><span data-ttu-id="6aa6a-328">Istruzioni foreach</span><span class="sxs-lookup"><span data-stu-id="6aa6a-328">Foreach statements</span></span>

<span data-ttu-id="6aa6a-329">Per un' `foreach` istruzione *stmt* nel formato:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-329">For a `foreach` statement *stmt* of the form:</span></span>
```csharp
foreach ( type identifier in expr ) embedded_statement
```

*  <span data-ttu-id="6aa6a-330">Lo stato di assegnazione definito di *v* all'inizio di *expr* corrisponde allo stato di *v* all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-330">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-331">Lo stato di assegnazione definito di *v* nel trasferimento del flusso di controllo a *embedded_statement* o al punto finale di *stmt* è uguale allo stato di *v* alla fine di *expr*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-331">The definite assignment state of *v* on the control flow transfer to *embedded_statement* or to the end point of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="using-statements"></a><span data-ttu-id="6aa6a-332">Istruzioni using</span><span class="sxs-lookup"><span data-stu-id="6aa6a-332">Using statements</span></span>

<span data-ttu-id="6aa6a-333">Per un' `using` istruzione *stmt* nel formato:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-333">For a `using` statement *stmt* of the form:</span></span>
```csharp
using ( resource_acquisition ) embedded_statement
```

*  <span data-ttu-id="6aa6a-334">Lo stato di assegnazione definito di *v* all'inizio di *resource_acquisition* è uguale allo stato di *v* all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-334">The definite assignment state of *v* at the beginning of *resource_acquisition* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-335">Lo stato di assegnazione definito di *v* nel trasferimento del flusso di controllo a *embedded_statement* è lo stesso dello stato *v* alla fine di *resource_acquisition*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-335">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *resource_acquisition*.</span></span>

#### <a name="lock-statements"></a><span data-ttu-id="6aa6a-336">Istruzioni lock</span><span class="sxs-lookup"><span data-stu-id="6aa6a-336">Lock statements</span></span>

<span data-ttu-id="6aa6a-337">Per un' `lock` istruzione *stmt* nel formato:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-337">For a `lock` statement *stmt* of the form:</span></span>
```csharp
lock ( expr ) embedded_statement
```

*  <span data-ttu-id="6aa6a-338">Lo stato di assegnazione definito di *v* all'inizio di *expr* corrisponde allo stato di *v* all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-338">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-339">Lo stato di assegnazione definito di *v* nel trasferimento del flusso di controllo a *embedded_statement* corrisponde allo stato di *v* alla fine di *expr*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-339">The definite assignment state of *v* on the control flow transfer to *embedded_statement* is the same as the state of *v* at the end of *expr*.</span></span>

#### <a name="yield-statements"></a><span data-ttu-id="6aa6a-340">Istruzioni yield</span><span class="sxs-lookup"><span data-stu-id="6aa6a-340">Yield statements</span></span>

<span data-ttu-id="6aa6a-341">Per un' `yield return` istruzione *stmt* nel formato:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-341">For a `yield return` statement *stmt* of the form:</span></span>
```csharp
yield return expr ;
```

*  <span data-ttu-id="6aa6a-342">Lo stato di assegnazione definito di *v* all'inizio di *expr* corrisponde allo stato di *v* all'inizio di *stmt*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-342">The definite assignment state of *v* at the beginning of *expr* is the same as the state of *v* at the beginning of *stmt*.</span></span>
*  <span data-ttu-id="6aa6a-343">Lo stato di assegnazione definito di *v* alla fine di *stmt* è uguale a quello di *v* alla fine di *expr*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-343">The definite assignment state of *v* at the end of *stmt* is the same as the state of *v* at the end of *expr*.</span></span>
*  <span data-ttu-id="6aa6a-344">Un' `yield break` istruzione non ha alcun effetto sullo stato di assegnazione definito.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-344">A `yield break` statement has no effect on the definite assignment state.</span></span>

#### <a name="general-rules-for-simple-expressions"></a><span data-ttu-id="6aa6a-345">Regole generali per le espressioni semplici</span><span class="sxs-lookup"><span data-stu-id="6aa6a-345">General rules for simple expressions</span></span>

<span data-ttu-id="6aa6a-346">La regola seguente si applica a questi tipi di espressioni: i valori letterali ([valori letterali](expressions.md#literals)), i nomi semplici ([nomi semplici](expressions.md#simple-names)), le espressioni di accesso ai membri ([accesso ai membri](expressions.md#member-access)), le espressioni di accesso di base non indicizzate ([accesso di base](expressions.md#base-access)), `typeof`espressioni ([operatore typeof](expressions.md#the-typeof-operator)), espressioni con valore predefinito ([espressioni con valore predefinito](expressions.md#default-value-expressions)) `nameof` ed espressioni ([espressioni NameOf](expressions.md#nameof-expressions)).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-346">The following rule applies to these kinds of expressions: literals ([Literals](expressions.md#literals)), simple names ([Simple names](expressions.md#simple-names)), member access expressions ([Member access](expressions.md#member-access)), non-indexed base access expressions ([Base access](expressions.md#base-access)), `typeof` expressions ([The typeof operator](expressions.md#the-typeof-operator)), default value expressions ([Default value expressions](expressions.md#default-value-expressions)) and `nameof` expressions ([Nameof expressions](expressions.md#nameof-expressions)).</span></span>

*  <span data-ttu-id="6aa6a-347">Lo stato di assegnazione definito di *v* alla fine di tale espressione corrisponde allo stato di assegnazione definito di *v* all'inizio dell'espressione.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-347">The definite assignment state of *v* at the end of such an expression is the same as the definite assignment state of *v* at the beginning of the expression.</span></span>

#### <a name="general-rules-for-expressions-with-embedded-expressions"></a><span data-ttu-id="6aa6a-348">Regole generali per le espressioni con espressioni incorporate</span><span class="sxs-lookup"><span data-stu-id="6aa6a-348">General rules for expressions with embedded expressions</span></span>

<span data-ttu-id="6aa6a-349">Le regole seguenti si applicano a questi tipi di espressioni: espressioni tra parentesi ([espressioni racchiuse tra parentesi](expressions.md#parenthesized-expressions)), espressioni di accesso agli elementi ([accesso agli elementi](expressions.md#element-access)), espressioni di accesso di base con indicizzazione ([accesso di base](expressions.md#base-access)), incremento e espressioni di decremento ([operatori di incremento e decremento suffisso](expressions.md#postfix-increment-and-decrement-operators), [operatori di incremento e decremento di prefisso](expressions.md#prefix-increment-and-decrement-operators)), espressioni cast ([espressioni cast](expressions.md#cast-expressions)), unario `+`, `-`, `~`, `*` espressioni, Binary `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` espressioni ([operatori aritmetici](expressions.md#arithmetic-operators), [operatori Shift](expressions.md#shift-operators), [relazionali e test di tipo operatori](expressions.md#relational-and-type-testing-operators), [operatori logici](expressions.md#logical-operators)), espressioni di assegnazione composta ([assegnazione composta](expressions.md#compound-assignment)), `checked` ed `unchecked` espressioni ([operatori checked e unchecked](expressions.md#the-checked-and-unchecked-operators)), più matrici e Delegate espressioni di creazione ([nuovo operatore](expressions.md#the-new-operator)).</span><span class="sxs-lookup"><span data-stu-id="6aa6a-349">The following rules apply to these kinds of expressions: parenthesized expressions ([Parenthesized expressions](expressions.md#parenthesized-expressions)), element access expressions ([Element access](expressions.md#element-access)), base access expressions with indexing ([Base access](expressions.md#base-access)), increment and decrement expressions ([Postfix increment and decrement operators](expressions.md#postfix-increment-and-decrement-operators), [Prefix increment and decrement operators](expressions.md#prefix-increment-and-decrement-operators)), cast expressions ([Cast expressions](expressions.md#cast-expressions)), unary `+`, `-`, `~`, `*` expressions, binary `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `<`, `<=`, `>`, `>=`, `==`, `!=`, `is`, `as`, `&`, `|`, `^` expressions ([Arithmetic operators](expressions.md#arithmetic-operators), [Shift operators](expressions.md#shift-operators), [Relational and type-testing operators](expressions.md#relational-and-type-testing-operators), [Logical operators](expressions.md#logical-operators)), compound assignment expressions ([Compound assignment](expressions.md#compound-assignment)), `checked` and `unchecked` expressions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)), plus array and delegate creation expressions ([The new operator](expressions.md#the-new-operator)).</span></span>

<span data-ttu-id="6aa6a-350">Ognuna di queste espressioni ha una o più sottoespressioni che vengono valutate in modo non condizionale in un ordine fisso.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-350">Each of these expressions has one or more sub-expressions that are unconditionally evaluated in a fixed order.</span></span> <span data-ttu-id="6aa6a-351">Ad esempio, l'operatore `%` binario valuta il lato sinistro dell'operatore, quindi la parte destra.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-351">For example, the binary `%` operator evaluates the left hand side of the operator, then the right hand side.</span></span> <span data-ttu-id="6aa6a-352">Un'operazione di indicizzazione valuta l'espressione indicizzata, quindi valuta ognuna delle espressioni di indice, in ordine da sinistra a destra.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-352">An indexing operation evaluates the indexed expression, and then evaluates each of the index expressions, in order from left to right.</span></span> <span data-ttu-id="6aa6a-353">Per un'espressione *expr*, che include sottoespressioni *E1, E2,..., en*, valutate nell'ordine seguente:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-353">For an expression *expr*, which has sub-expressions *e1, e2, ..., eN*, evaluated in that order:</span></span>

*  <span data-ttu-id="6aa6a-354">Lo stato di assegnazione definito di *v* all'inizio di *E1* corrisponde allo stato di assegnazione definito all'inizio di *expr*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-354">The definite assignment state of *v* at the beginning of *e1* is the same as the definite assignment state at the beginning of *expr*.</span></span>
*  <span data-ttu-id="6aa6a-355">Lo stato di assegnazione definito di *v* all'inizio di *ei* (*maggiore* di uno) corrisponde allo stato di assegnazione definito alla fine della sottoespressione precedente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-355">The definite assignment state of *v* at the beginning of *ei* (*i* greater than one) is the same as the definite assignment state at the end of the previous sub-expression.</span></span>
*  <span data-ttu-id="6aa6a-356">Lo stato di assegnazione definito di *v* alla fine di *expr* corrisponde allo stato di assegnazione definito alla fine di *en*</span><span class="sxs-lookup"><span data-stu-id="6aa6a-356">The definite assignment state of *v* at the end of *expr* is the same as the definite assignment state at the end of *eN*</span></span>

#### <a name="invocation-expressions-and-object-creation-expressions"></a><span data-ttu-id="6aa6a-357">Espressioni di chiamata ed espressioni di creazione di oggetti</span><span class="sxs-lookup"><span data-stu-id="6aa6a-357">Invocation expressions and object creation expressions</span></span>

<span data-ttu-id="6aa6a-358">Per un'espressione di chiamata *expr* nel formato:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-358">For an invocation expression *expr* of the form:</span></span>
```csharp
primary_expression ( arg1 , arg2 , ... , argN )
```
<span data-ttu-id="6aa6a-359">o un'espressione di creazione di oggetti nel formato seguente:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-359">or an object creation expression of the form:</span></span>
```csharp
new type ( arg1 , arg2 , ... , argN )
```

*  <span data-ttu-id="6aa6a-360">Per un'espressione di chiamata, lo stato di assegnazione definito di *v* prima di *primary_expression* è lo stesso dello stato *v* prima di *expr*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-360">For an invocation expression, the definite assignment state of *v* before *primary_expression* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6aa6a-361">Per un'espressione di chiamata, lo stato di assegnazione definito di *v* prima di *arg1* è lo stesso dello stato *v* dopo *primary_expression*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-361">For an invocation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* after *primary_expression*.</span></span>
*  <span data-ttu-id="6aa6a-362">Per un'espressione di creazione di un oggetto, lo stato di assegnazione definito di *v* prima di *arg1* è lo stesso dello stato *v* prima di *expr*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-362">For an object creation expression, the definite assignment state of *v* before *arg1* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6aa6a-363">Per ogni argomento *Argi*, lo stato di assegnazione definito di *v* dopo *Argi* è determinato dalle regole di espressione normali, ignorando `ref` eventuali `out` modificatori o.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-363">For each argument *argi*, the definite assignment state of *v* after *argi* is determined by the normal expression rules, ignoring any `ref` or `out` modifiers.</span></span>
*  <span data-ttu-id="6aa6a-364">Per ogni argomento *Argi* per i *maggiori di* uno, lo stato di assegnazione definito di *v* prima di *Argi* è lo stesso dello stato *v* dopo l' *arg*precedente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-364">For each argument *argi* for any *i* greater than one, the definite assignment state of *v* before *argi* is the same as the state of *v* after the previous *arg*.</span></span>
*  <span data-ttu-id="6aa6a-365">Se la variabile *v* `out` viene passata come argomento (ad esempio, un argomento del `out v`form) in uno degli argomenti, lo stato di *v* dopo *expr* viene assegnato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-365">If the variable *v* is passed as an `out` argument (i.e., an argument of the form `out v`) in any of the arguments, then the state of *v* after *expr* is definitely assigned.</span></span> <span data-ttu-id="6aa6a-366">In caso contrario lo stato *v* dopo *expr* corrisponde allo stato di *v* dopo *argN*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-366">Otherwise; the state of *v* after *expr* is the same as the state of *v* after *argN*.</span></span>
*  <span data-ttu-id="6aa6a-367">Per gli inizializzatori di matrice ([espressioni di creazione di matrici](expressions.md#array-creation-expressions)), inizializzatori di oggetto ([inizializzatori di oggetto](expressions.md#object-initializers)), inizializzatori di insieme ([inizializzatori di insieme](expressions.md#collection-initializers)) e inizializzatori di oggetti anonimi (creazione di[oggetti anonimi espressioni](expressions.md#anonymous-object-creation-expressions)), lo stato di assegnazione definito è determinato dall'espansione che questi costrutti sono definiti in termini di.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-367">For array initializers ([Array creation expressions](expressions.md#array-creation-expressions)), object initializers ([Object initializers](expressions.md#object-initializers)), collection initializers ([Collection initializers](expressions.md#collection-initializers)) and anonymous object initializers ([Anonymous object creation expressions](expressions.md#anonymous-object-creation-expressions)), the definite assignment state is determined by the expansion that these constructs are defined in terms of.</span></span>

#### <a name="simple-assignment-expressions"></a><span data-ttu-id="6aa6a-368">Espressioni di assegnazione semplici</span><span class="sxs-lookup"><span data-stu-id="6aa6a-368">Simple assignment expressions</span></span>

<span data-ttu-id="6aa6a-369">Per un'espressione *expr* nel formato `w = expr_rhs`:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-369">For an expression *expr* of the form `w = expr_rhs`:</span></span>

*  <span data-ttu-id="6aa6a-370">Lo stato di assegnazione definito di *v* prima di *expr_rhs* è lo stesso dello stato di assegnazione definito di *v* prima di *expr*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-370">The definite assignment state of *v* before *expr_rhs* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6aa6a-371">Lo stato di assegnazione definito di *v* dopo *expr* è determinato da:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-371">The definite assignment state of *v* after *expr* is determined by:</span></span>
   * <span data-ttu-id="6aa6a-372">Se *w* è la stessa variabile di *v*, lo stato di assegnazione definito di *v* dopo *expr* viene assegnato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-372">If *w* is the same variable as *v*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="6aa6a-373">In caso contrario, se l'assegnazione si verifica all'interno del costruttore di istanza di un tipo struct, se *w* è un accesso alla proprietà che designa una proprietà implementata automaticamente *P* nell'istanza da costruire e *v* è il campo sottostante nascosto di *P*, lo stato di assegnazione definito di *v* dopo *expr* viene assegnato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-373">Otherwise, if the assignment occurs within the instance constructor of a struct type, if *w* is a property access designating an automatically implemented property *P* on the instance being constructed and *v* is the hidden backing field of *P*, then the definite assignment state of *v* after *expr* is definitely assigned.</span></span>
   * <span data-ttu-id="6aa6a-374">In caso contrario, lo stato di assegnazione definito di *v* dopo *expr* corrisponde allo stato di assegnazione definito di *v* dopo *expr_rhs*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-374">Otherwise, the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_rhs*.</span></span>

#### <a name="-conditional-and-expressions"></a><span data-ttu-id="6aa6a-375">espressioni & & (condizionale e)</span><span class="sxs-lookup"><span data-stu-id="6aa6a-375">&& (conditional AND) expressions</span></span>

<span data-ttu-id="6aa6a-376">Per un'espressione *expr* nel formato `expr_first && expr_second`:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-376">For an expression *expr* of the form `expr_first && expr_second`:</span></span>

*  <span data-ttu-id="6aa6a-377">Lo stato di assegnazione definito di *v* prima di *expr_first* è lo stesso dello stato di assegnazione definito di *v* prima di *expr*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-377">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6aa6a-378">Lo stato di assegnazione definito di *v* prima di *expr_second* viene assegnato definitivamente se lo stato di *v* dopo *expr_first* è definitivamente assegnato o "assegnato definitivamente dopo l'espressione true".</span><span class="sxs-lookup"><span data-stu-id="6aa6a-378">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after true expression".</span></span> <span data-ttu-id="6aa6a-379">In caso contrario, non viene assegnato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-379">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="6aa6a-380">Lo stato di assegnazione definito di *v* dopo *expr* è determinato da:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-380">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="6aa6a-381">Se *expr_first* è un'espressione costante con il valore `false`, lo stato di assegnazione definito di *v* dopo *expr* corrisponde allo stato di assegnazione definito di *v* dopo *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-381">If *expr_first* is a constant expression with the value `false`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="6aa6a-382">In caso contrario, se lo stato di *v* dopo *expr_first* è assegnato definitivamente, lo stato di *v* dopo *expr* viene assegnato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-382">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="6aa6a-383">In caso contrario, se lo stato di *v* dopo *expr_second* è assegnato definitivamente e lo stato di *v* dopo *expr_first* è "definitivamente assegnato dopo false Expression", lo stato di *v* dopo *expr* è sicuramente assegnato.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-383">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after false expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="6aa6a-384">In caso contrario, se lo stato di *v* dopo *expr_second* è assegnato definitivamente o "assegnato definitivamente dopo l'espressione true", lo stato di *v* dopo *expr* è "definitely Assigned after true Expression".</span><span class="sxs-lookup"><span data-stu-id="6aa6a-384">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="6aa6a-385">In caso contrario, se lo stato di *v* dopo *expr_first* è "definitely Assigned after false Expression" e lo stato di *v* dopo *expr_second* è "definitely Assigned after false Expression", lo stato di *v* dopo  *expr* è "assegnato definitivamente dopo false Expression".</span><span class="sxs-lookup"><span data-stu-id="6aa6a-385">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after false expression", and the state of *v* after *expr_second* is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="6aa6a-386">In caso contrario, lo stato di *v* dopo *expr* non viene assegnato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-386">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="6aa6a-387">Nell'esempio</span><span class="sxs-lookup"><span data-stu-id="6aa6a-387">In the example</span></span>
```csharp
class A
{
    static void F(int x, int y) {
        int i;
        if (x >= 0 && (i = y) >= 0) {
            // i definitely assigned
        }
        else {
            // i not definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="6aa6a-388">la variabile `i` viene considerata definitivamente assegnata in una delle istruzioni incorporate di `if` un'istruzione ma non nell'altra.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-388">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="6aa6a-389">Nell'istruzione nel metodo `F`, la variabile `i` viene assegnata definitivamente nella prima istruzione incorporata perché l'esecuzione dell'espressione `(i = y)` precede sempre l'esecuzione di questa istruzione incorporata. `if`</span><span class="sxs-lookup"><span data-stu-id="6aa6a-389">In the `if` statement in method `F`, the variable `i` is definitely assigned in the first embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="6aa6a-390">Al contrario, la variabile `i` non viene assegnata definitivamente nella seconda istruzione incorporata, `x >= 0` perché potrebbe avere testato false, causando la `i` mancata assegnazione della variabile.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-390">In contrast, the variable `i` is not definitely assigned in the second embedded statement, since `x >= 0` might have tested false, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-conditional-or-expressions"></a><span data-ttu-id="6aa6a-391">|| espressioni (condizionali o)</span><span class="sxs-lookup"><span data-stu-id="6aa6a-391">|| (conditional OR) expressions</span></span>

<span data-ttu-id="6aa6a-392">Per un'espressione *expr* nel formato `expr_first || expr_second`:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-392">For an expression *expr* of the form `expr_first || expr_second`:</span></span>

*  <span data-ttu-id="6aa6a-393">Lo stato di assegnazione definito di *v* prima di *expr_first* è lo stesso dello stato di assegnazione definito di *v* prima di *expr*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-393">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6aa6a-394">Lo stato di assegnazione definito di *v* prima di *expr_second* viene assegnato definitivamente se lo stato di *v* dopo *expr_first* è definitivamente assegnato o "assegnato definitivamente dopo false Expression".</span><span class="sxs-lookup"><span data-stu-id="6aa6a-394">The definite assignment state of *v* before *expr_second* is definitely assigned if the state of *v* after *expr_first* is either definitely assigned or "definitely assigned after false expression".</span></span> <span data-ttu-id="6aa6a-395">In caso contrario, non viene assegnato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-395">Otherwise, it is not definitely assigned.</span></span>
*  <span data-ttu-id="6aa6a-396">L'istruzione di assegnazione definita di *v* dopo *expr* è determinata da:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-396">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="6aa6a-397">Se *expr_first* è un'espressione costante con il valore `true`, lo stato di assegnazione definito di *v* dopo *expr* corrisponde allo stato di assegnazione definito di *v* dopo *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-397">If *expr_first* is a constant expression with the value `true`, then the definite assignment state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
    * <span data-ttu-id="6aa6a-398">In caso contrario, se lo stato di *v* dopo *expr_first* è assegnato definitivamente, lo stato di *v* dopo *expr* viene assegnato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-398">Otherwise, if the state of *v* after *expr_first* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="6aa6a-399">In caso contrario, se lo stato di *v* dopo *expr_second* è assegnato definitivamente e lo stato di *v* dopo *expr_first* è "definitivamente assegnato dopo l'espressione true", lo stato di *v* dopo *expr* è sicuramente assegnato.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-399">Otherwise, if the state of *v* after *expr_second* is definitely assigned, and the state of *v* after *expr_first* is "definitely assigned after true expression", then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="6aa6a-400">In caso contrario, se lo stato di *v* dopo *expr_second* è assegnato definitivamente o "assegnato definitivamente dopo false Expression", lo stato di *v* dopo *expr* sarà "definitely Assigned after false Expression".</span><span class="sxs-lookup"><span data-stu-id="6aa6a-400">Otherwise, if the state of *v* after *expr_second* is definitely assigned or "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>
    * <span data-ttu-id="6aa6a-401">In caso contrario, se lo stato di *v* dopo *expr_first* è "assegnato definitivamente dopo l'espressione true" e lo stato di *v* dopo *expr_second* è "definitivamente assegnato dopo l'espressione true", lo stato di *v* dopo *expr* è "assegnato definitivamente dopo l'espressione true".</span><span class="sxs-lookup"><span data-stu-id="6aa6a-401">Otherwise, if the state of *v* after *expr_first* is "definitely assigned after true expression", and the state of *v* after *expr_second* is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="6aa6a-402">In caso contrario, lo stato di *v* dopo *expr* non viene assegnato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-402">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

<span data-ttu-id="6aa6a-403">Nell'esempio</span><span class="sxs-lookup"><span data-stu-id="6aa6a-403">In the example</span></span>
```csharp
class A
{
    static void G(int x, int y) {
        int i;
        if (x >= 0 || (i = y) >= 0) {
            // i not definitely assigned
        }
        else {
            // i definitely assigned
        }
        // i not definitely assigned
    }
}
```
<span data-ttu-id="6aa6a-404">la variabile `i` viene considerata definitivamente assegnata in una delle istruzioni incorporate di `if` un'istruzione ma non nell'altra.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-404">the variable `i` is considered definitely assigned in one of the embedded statements of an `if` statement but not in the other.</span></span> <span data-ttu-id="6aa6a-405">Nell'istruzione nel metodo `G`, la variabile `i` viene assegnata definitivamente nella seconda istruzione incorporata perché l'esecuzione dell'espressione `(i = y)` precede sempre l'esecuzione di questa istruzione incorporata. `if`</span><span class="sxs-lookup"><span data-stu-id="6aa6a-405">In the `if` statement in method `G`, the variable `i` is definitely assigned in the second embedded statement because execution of the expression `(i = y)` always precedes execution of this embedded statement.</span></span> <span data-ttu-id="6aa6a-406">Al contrario, la variabile `i` non viene assegnata definitivamente nella prima istruzione incorporata, `x >= 0` perché potrebbe avere testato true, causando la `i` mancata assegnazione della variabile.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-406">In contrast, the variable `i` is not definitely assigned in the first embedded statement, since `x >= 0` might have tested true, resulting in the variable `i` being unassigned.</span></span>

#### <a name="-logical-negation-expressions"></a><span data-ttu-id="6aa6a-407">!</span><span class="sxs-lookup"><span data-stu-id="6aa6a-407">!</span></span> <span data-ttu-id="6aa6a-408">espressioni (negazione logica)</span><span class="sxs-lookup"><span data-stu-id="6aa6a-408">(logical negation) expressions</span></span>

<span data-ttu-id="6aa6a-409">Per un'espressione *expr* nel formato `! expr_operand`:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-409">For an expression *expr* of the form `! expr_operand`:</span></span>

*  <span data-ttu-id="6aa6a-410">Lo stato di assegnazione definito di *v* prima di *expr_operand* è lo stesso dello stato di assegnazione definito di *v* prima di *expr*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-410">The definite assignment state of *v* before *expr_operand* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6aa6a-411">Lo stato di assegnazione definito di *v* dopo *expr* è determinato da:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-411">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="6aa6a-412">Se lo stato di *v* after \* expr_operand \* viene assegnato definitivamente, lo stato di *v* dopo *expr* viene assegnato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-412">If the state of *v* after \*expr_operand \*is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="6aa6a-413">Se lo stato di *v* after \* expr_operand \* non è assegnato definitivamente, lo stato di *v* dopo *expr* non viene assegnato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-413">If the state of *v* after \*expr_operand \*is not definitely assigned, then the state of *v* after *expr* is not definitely assigned.</span></span>
    * <span data-ttu-id="6aa6a-414">Se lo stato di *v* after \* expr_operand \* è "definitely Assigned after false Expression", lo stato di *v* after *expr* è "definitely Assigned after true Expression".</span><span class="sxs-lookup"><span data-stu-id="6aa6a-414">If the state of *v* after \*expr_operand \*is "definitely assigned after false expression", then the state of *v* after *expr* is "definitely assigned after true expression".</span></span>
    * <span data-ttu-id="6aa6a-415">Se lo stato di *v* after \* expr_operand \* è "assegnato definitivamente dopo l'espressione true", lo stato di *v* dopo *expr* è "definitely Assigned after false Expression".</span><span class="sxs-lookup"><span data-stu-id="6aa6a-415">If the state of *v* after \*expr_operand \*is "definitely assigned after true expression", then the state of *v* after *expr* is "definitely assigned after false expression".</span></span>

#### <a name="-null-coalescing-expressions"></a><span data-ttu-id="6aa6a-416">??</span><span class="sxs-lookup"><span data-stu-id="6aa6a-416">??</span></span> <span data-ttu-id="6aa6a-417">espressioni (Unione di valori null)</span><span class="sxs-lookup"><span data-stu-id="6aa6a-417">(null coalescing) expressions</span></span>

<span data-ttu-id="6aa6a-418">Per un'espressione *expr* nel formato `expr_first ?? expr_second`:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-418">For an expression *expr* of the form `expr_first ?? expr_second`:</span></span>

*  <span data-ttu-id="6aa6a-419">Lo stato di assegnazione definito di *v* prima di *expr_first* è lo stesso dello stato di assegnazione definito di *v* prima di *expr*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-419">The definite assignment state of *v* before *expr_first* is the same as the definite assignment state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6aa6a-420">Lo stato di assegnazione definito di *v* prima di *expr_second* è lo stesso dello stato di assegnazione definito di *v* dopo *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-420">The definite assignment state of *v* before *expr_second* is the same as the definite assignment state of *v* after *expr_first*.</span></span>
*  <span data-ttu-id="6aa6a-421">L'istruzione di assegnazione definita di *v* dopo *expr* è determinata da:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-421">The definite assignment statement of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="6aa6a-422">Se *expr_first* è un'espressione costante ([espressioni costanti](expressions.md#constant-expressions)) con valore null, lo stato di *v* dopo *expr* sarà lo stesso dello stato *v* dopo *expr_second*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-422">If *expr_first* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value null, then the state of *v* after *expr* is the same as the state of *v* after *expr_second*.</span></span>
*  <span data-ttu-id="6aa6a-423">In caso contrario, lo stato di *v* dopo *expr* corrisponde allo stato di assegnazione definito di *v* dopo *expr_first*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-423">Otherwise, the state of *v* after *expr* is the same as the definite assignment state of *v* after *expr_first*.</span></span>

#### <a name="-conditional-expressions"></a><span data-ttu-id="6aa6a-424">espressioni?: (condizionale)</span><span class="sxs-lookup"><span data-stu-id="6aa6a-424">?: (conditional) expressions</span></span>

<span data-ttu-id="6aa6a-425">Per un'espressione *expr* nel formato `expr_cond ? expr_true : expr_false`:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-425">For an expression *expr* of the form `expr_cond ? expr_true : expr_false`:</span></span>

*  <span data-ttu-id="6aa6a-426">Lo stato di assegnazione definito di *v* prima di *expr_cond* è uguale allo stato di *v* prima di *expr*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-426">The definite assignment state of *v* before *expr_cond* is the same as the state of *v* before *expr*.</span></span>
*  <span data-ttu-id="6aa6a-427">Lo stato di assegnazione definito di *v* prima di *expr_true* viene assegnato definitivamente se e solo se uno degli elementi seguenti include:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-427">The definite assignment state of *v* before *expr_true* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="6aa6a-428">*expr_cond* è un'espressione costante con il valore`false`</span><span class="sxs-lookup"><span data-stu-id="6aa6a-428">*expr_cond* is a constant expression with the value `false`</span></span>
    * <span data-ttu-id="6aa6a-429">lo stato di *v* dopo *expr_cond* è assegnato definitivamente o "assegnato definitivamente dopo l'espressione true".</span><span class="sxs-lookup"><span data-stu-id="6aa6a-429">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after true expression".</span></span>
*  <span data-ttu-id="6aa6a-430">Lo stato di assegnazione definito di *v* prima di *expr_false* viene assegnato definitivamente se e solo se uno degli elementi seguenti include:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-430">The definite assignment state of *v* before *expr_false* is definitely assigned if and only if one of the following holds:</span></span>
    * <span data-ttu-id="6aa6a-431">*expr_cond* è un'espressione costante con il valore`true`</span><span class="sxs-lookup"><span data-stu-id="6aa6a-431">*expr_cond* is a constant expression with the value `true`</span></span>
*  <span data-ttu-id="6aa6a-432">lo stato di *v* dopo *expr_cond* è assegnato definitivamente o "assegnato definitivamente dopo false Expression".</span><span class="sxs-lookup"><span data-stu-id="6aa6a-432">the state of *v* after *expr_cond* is definitely assigned or "definitely assigned after false expression".</span></span>
*  <span data-ttu-id="6aa6a-433">Lo stato di assegnazione definito di *v* dopo *expr* è determinato da:</span><span class="sxs-lookup"><span data-stu-id="6aa6a-433">The definite assignment state of *v* after *expr* is determined by:</span></span>
    * <span data-ttu-id="6aa6a-434">Se *expr_cond* è un'espressione costante ([espressioni costanti](expressions.md#constant-expressions)) con valore `true` , lo stato di *v* dopo *expr* sarà lo stesso dello stato *v* dopo *expr_true*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-434">If *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `true` then the state of *v* after *expr* is the same as the state of *v* after *expr_true*.</span></span>
    * <span data-ttu-id="6aa6a-435">In caso contrario, se *expr_cond* è un'espressione costante ([espressioni costanti](expressions.md#constant-expressions)) `false` con valore, lo stato di *v* dopo *expr* sarà lo stesso dello stato *v* dopo *expr_false*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-435">Otherwise, if *expr_cond* is a constant expression ([Constant expressions](expressions.md#constant-expressions)) with value `false` then the state of *v* after *expr* is the same as the state of *v* after *expr_false*.</span></span>
    * <span data-ttu-id="6aa6a-436">In caso contrario, se lo stato di *v* dopo *expr_true* è assegnato definitivamente e lo stato di *v* dopo *expr_false* è definitivamente assegnato, lo stato di *v* dopo *expr* viene assegnato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-436">Otherwise, if the state of *v* after *expr_true* is definitely assigned and the state of *v* after *expr_false* is definitely assigned, then the state of *v* after *expr* is definitely assigned.</span></span>
    * <span data-ttu-id="6aa6a-437">In caso contrario, lo stato di *v* dopo *expr* non viene assegnato definitivamente.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-437">Otherwise, the state of *v* after *expr* is not definitely assigned.</span></span>

#### <a name="anonymous-functions"></a><span data-ttu-id="6aa6a-438">Funzioni anonime</span><span class="sxs-lookup"><span data-stu-id="6aa6a-438">Anonymous functions</span></span>

<span data-ttu-id="6aa6a-439">Per *lambda_expression* o *anonymous_method_expression* *expr* *con corpo (* *blocco* o *espressione*):</span><span class="sxs-lookup"><span data-stu-id="6aa6a-439">For a *lambda_expression* or *anonymous_method_expression* *expr* with a body (either *block* or *expression*) *body*:</span></span>

*  <span data-ttu-id="6aa6a-440">Lo stato di assegnazione definito di una variabile esterna *v* before *Body* corrisponde allo stato di *v* prima di *expr*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-440">The definite assignment state of an outer variable *v* before *body* is the same as the state of *v* before *expr*.</span></span> <span data-ttu-id="6aa6a-441">Ovvero lo stato di assegnazione definito delle variabili esterne viene ereditato dal contesto della funzione anonima.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-441">That is, definite assignment state of outer variables is inherited from the context of the anonymous function.</span></span>
*  <span data-ttu-id="6aa6a-442">Lo stato di assegnazione definito di una variabile esterna *v* dopo *expr* è identico a quello di *v* prima di *expr*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-442">The definite assignment state of an outer variable *v* after *expr* is the same as the state of *v* before *expr*.</span></span>

<span data-ttu-id="6aa6a-443">Esempio</span><span class="sxs-lookup"><span data-stu-id="6aa6a-443">The example</span></span>
```csharp
delegate bool Filter(int i);

void F() {
    int max;

    // Error, max is not definitely assigned
    Filter f = (int n) => n < max;

    max = 5;
    DoWork(f);
}
```
<span data-ttu-id="6aa6a-444">genera un errore in fase di compilazione `max` perché non è assegnato definitivamente quando viene dichiarata la funzione anonima.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-444">generates a compile-time error since `max` is not definitely assigned where the anonymous function is declared.</span></span> <span data-ttu-id="6aa6a-445">Esempio</span><span class="sxs-lookup"><span data-stu-id="6aa6a-445">The example</span></span>
```csharp
delegate void D();

void F() {
    int n;
    D d = () => { n = 1; };

    d();

    // Error, n is not definitely assigned
    Console.WriteLine(n);
}
```
<span data-ttu-id="6aa6a-446">genera inoltre un errore in fase di compilazione perché l'assegnazione `n` a nella funzione anonima non ha alcun effetto sullo stato di `n` assegnazione definito all'esterno della funzione anonima.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-446">also generates a compile-time error since the assignment to `n` in the anonymous function has no affect on the definite assignment state of `n` outside the anonymous function.</span></span>

## <a name="variable-references"></a><span data-ttu-id="6aa6a-447">Riferimenti a variabili</span><span class="sxs-lookup"><span data-stu-id="6aa6a-447">Variable references</span></span>

<span data-ttu-id="6aa6a-448">Un *variable_reference* è un' *espressione* classificata come variabile.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-448">A *variable_reference* is an *expression* that is classified as a variable.</span></span> <span data-ttu-id="6aa6a-449">Un *variable_reference* indica un percorso di archiviazione a cui è possibile accedere sia per recuperare il valore corrente sia per archiviare un nuovo valore.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-449">A *variable_reference* denotes a storage location that can be accessed both to fetch the current value and to store a new value.</span></span>

```antlr
variable_reference
    : expression
    ;
```

<span data-ttu-id="6aa6a-450">In C e C++un *variable_reference* è noto come *lvalue*.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-450">In C and C++, a *variable_reference* is known as an *lvalue*.</span></span>

## <a name="atomicity-of-variable-references"></a><span data-ttu-id="6aa6a-451">Atomicità dei riferimenti a variabili</span><span class="sxs-lookup"><span data-stu-id="6aa6a-451">Atomicity of variable references</span></span>

<span data-ttu-id="6aa6a-452">Le letture e le scritture dei tipi di dati seguenti `bool`sono `char`atomiche `sbyte`: `short` `byte`,,, `int`, `float`, `ushort`, `uint`,, e tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-452">Reads and writes of the following data types are atomic: `bool`, `char`, `byte`, `sbyte`, `short`, `ushort`, `uint`, `int`, `float`, and reference types.</span></span> <span data-ttu-id="6aa6a-453">Inoltre, le letture e le scritture dei tipi enum con un tipo sottostante nell'elenco precedente sono anche atomiche.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-453">In addition, reads and writes of enum types with an underlying type in the previous list are also atomic.</span></span> <span data-ttu-id="6aa6a-454">Le letture e le scritture di altri `long`tipi `ulong`, tra cui `decimal`,, `double`e, nonché i tipi definiti dall'utente, non sono necessariamente atomiche.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-454">Reads and writes of other types, including `long`, `ulong`, `double`, and `decimal`, as well as user-defined types, are not guaranteed to be atomic.</span></span> <span data-ttu-id="6aa6a-455">Oltre alle funzioni di libreria progettate a tale scopo, non esiste alcuna garanzia di Atomic read-modify-write, ad esempio in caso di incremento o decremento.</span><span class="sxs-lookup"><span data-stu-id="6aa6a-455">Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.</span></span>

