---
ms.openlocfilehash: a28397b1ce97dbead6d5014e2b20e108a1018502
ms.sourcegitcommit: 94a3d151c438d34ede1d99de9eb4ebdc07ba4699
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/25/2019
ms.locfileid: "64488783"
---
# <a name="types"></a><span data-ttu-id="d8a71-101">Tipi</span><span class="sxs-lookup"><span data-stu-id="d8a71-101">Types</span></span>

<span data-ttu-id="d8a71-102">I tipi del linguaggio c# sono suddivisi in due categorie principali: ***i tipi di valore*** e ***fanno riferimento ai tipi***.</span><span class="sxs-lookup"><span data-stu-id="d8a71-102">The types of the C# language are divided into two main categories: ***value types*** and ***reference types***.</span></span> <span data-ttu-id="d8a71-103">I tipi di valore e tipi di riferimento possono essere ***i tipi generici***, che accettano uno o più ***parametri di tipo***.</span><span class="sxs-lookup"><span data-stu-id="d8a71-103">Both value types and reference types may be ***generic types***, which take one or more ***type parameters***.</span></span> <span data-ttu-id="d8a71-104">I parametri di tipo possono designare entrambi i tipi valore e tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="d8a71-104">Type parameters can designate both value types and reference types.</span></span>

```antlr
type
    : value_type
    | reference_type
    | type_parameter
    | type_unsafe
    ;
```

<span data-ttu-id="d8a71-105">La categoria di tipi, i puntatori, finale è disponibile solo nel codice non sicuro.</span><span class="sxs-lookup"><span data-stu-id="d8a71-105">The final category of types, pointers, is available only in unsafe code.</span></span> <span data-ttu-id="d8a71-106">Questo argomento verrà trattato dettagliatamente nella [tipi di puntatore](unsafe-code.md#pointer-types).</span><span class="sxs-lookup"><span data-stu-id="d8a71-106">This is discussed further in [Pointer types](unsafe-code.md#pointer-types).</span></span>

<span data-ttu-id="d8a71-107">I tipi di valore differiscono dai tipi di riferimento in quanto le variabili dei tipi valore contengono direttamente i propri dati, mentre le variabili del riferimento a tipi di archivio ***riferimenti*** ai dati, i noti come ***oggetti***.</span><span class="sxs-lookup"><span data-stu-id="d8a71-107">Value types differ from reference types in that variables of the value types directly contain their data, whereas variables of the reference types store ***references*** to their data, the latter being known as ***objects***.</span></span> <span data-ttu-id="d8a71-108">Con i tipi riferimento, è possibile che due variabili possono fare riferimento allo stesso oggetto e pertanto le operazioni su una variabile influiscano sull'oggetto a cui fa riferimento l'altra.</span><span class="sxs-lookup"><span data-stu-id="d8a71-108">With reference types, it is possible for two variables to reference the same object, and thus possible for operations on one variable to affect the object referenced by the other variable.</span></span> <span data-ttu-id="d8a71-109">Tipi di valore, ogni variabile ha una propria copia dei dati e non è possibile per le operazioni su una variabile influiscano su altra.</span><span class="sxs-lookup"><span data-stu-id="d8a71-109">With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other.</span></span>

<span data-ttu-id="d8a71-110">C#del sistema di tipi è unificato in modo che un valore di qualsiasi tipo può essere considerato come un oggetto.</span><span class="sxs-lookup"><span data-stu-id="d8a71-110">C#'s type system is unified such that a value of any type can be treated as an object.</span></span> <span data-ttu-id="d8a71-111">In C# ogni tipo deriva direttamente o indirettamente dal tipo classe `object` e `object` è la classe di base principale di tutti i tipi.</span><span class="sxs-lookup"><span data-stu-id="d8a71-111">Every type in C# directly or indirectly derives from the `object` class type, and `object` is the ultimate base class of all types.</span></span> <span data-ttu-id="d8a71-112">I valori dei tipi riferimento vengono trattati come oggetti semplicemente visualizzando tali valori come tipi `object`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-112">Values of reference types are treated as objects simply by viewing the values as type `object`.</span></span> <span data-ttu-id="d8a71-113">I valori dei tipi di valore vengono trattati come oggetti mediante l'esecuzione di operazioni di conversione boxing e unboxing ([conversioni Boxing e unboxing](types.md#boxing-and-unboxing)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-113">Values of value types are treated as objects by performing boxing and unboxing operations ([Boxing and unboxing](types.md#boxing-and-unboxing)).</span></span>

## <a name="value-types"></a><span data-ttu-id="d8a71-114">Tipi valore</span><span class="sxs-lookup"><span data-stu-id="d8a71-114">Value types</span></span>

<span data-ttu-id="d8a71-115">Un tipo di valore è un tipo struct o un tipo di enumerazione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-115">A value type is either a struct type or an enumeration type.</span></span> <span data-ttu-id="d8a71-116">C# offre un set di tipi di struct predefinito denominato il ***i tipi semplici***.</span><span class="sxs-lookup"><span data-stu-id="d8a71-116">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="d8a71-117">I tipi semplici vengono identificati tramite le parole riservate.</span><span class="sxs-lookup"><span data-stu-id="d8a71-117">The simple types are identified through reserved words.</span></span>

```antlr
value_type
    : struct_type
    | enum_type
    ;

struct_type
    : type_name
    | simple_type
    | nullable_type
    ;

simple_type
    : numeric_type
    | 'bool'
    ;

numeric_type
    : integral_type
    | floating_point_type
    | 'decimal'
    ;

integral_type
    : 'sbyte'
    | 'byte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    ;

floating_point_type
    : 'float'
    | 'double'
    ;

nullable_type
    : non_nullable_value_type '?'
    ;

non_nullable_value_type
    : type
    ;

enum_type
    : type_name
    ;
```

<span data-ttu-id="d8a71-118">A differenza di una variabile di un tipo riferimento, una variabile di un tipo valore può contenere il valore `null` solo se il tipo di valore è un tipo nullable.</span><span class="sxs-lookup"><span data-stu-id="d8a71-118">Unlike a variable of a reference type, a variable of a value type can contain the value `null` only if the value type is a nullable type.</span></span>  <span data-ttu-id="d8a71-119">Per ogni tipo di valore non nullable è presente un corrispondente tipo di valore nullable che indica lo stesso set di valori più il valore `null`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-119">For every non-nullable value type there is a corresponding nullable value type denoting the same set of values plus the value `null`.</span></span>

<span data-ttu-id="d8a71-120">Assegnazione a una variabile di un tipo valore consente di creare una copia del valore da assegnare.</span><span class="sxs-lookup"><span data-stu-id="d8a71-120">Assignment to a variable of a value type creates a copy of the value being assigned.</span></span> <span data-ttu-id="d8a71-121">Questo comportamento è diverso dall'assegnazione a una variabile di un tipo riferimento, che consente di copiare il riferimento, ma non l'oggetto identificato dal riferimento.</span><span class="sxs-lookup"><span data-stu-id="d8a71-121">This differs from assignment to a variable of a reference type, which copies the reference but not the object identified by the reference.</span></span>

### <a name="the-systemvaluetype-type"></a><span data-ttu-id="d8a71-122">Il tipo System. ValueType</span><span class="sxs-lookup"><span data-stu-id="d8a71-122">The System.ValueType type</span></span>

<span data-ttu-id="d8a71-123">Tutti i tipi valore ereditano in modo implicito dalla classe `System.ValueType`che, a sua volta eredita dalla classe `object`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-123">All value types implicitly inherit from the class `System.ValueType`, which, in turn, inherits from class `object`.</span></span> <span data-ttu-id="d8a71-124">Non è possibile per qualsiasi tipo da cui derivare un tipo di valore e tipi di valore in questo modo sono implicitamente sealed ([le classi Sealed](classes.md#sealed-classes)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-124">It is not possible for any type to derive from a value type, and value types are thus implicitly sealed ([Sealed classes](classes.md#sealed-classes)).</span></span>

<span data-ttu-id="d8a71-125">Si noti che `System.ValueType` non è a sua volta un *value_type*.</span><span class="sxs-lookup"><span data-stu-id="d8a71-125">Note that `System.ValueType` is not itself a *value_type*.</span></span> <span data-ttu-id="d8a71-126">Si tratta piuttosto di una *class_type* da cui tutti gli *value_type*derivano automaticamente.</span><span class="sxs-lookup"><span data-stu-id="d8a71-126">Rather, it is a *class_type* from which all *value_type*s are automatically derived.</span></span>

### <a name="default-constructors"></a><span data-ttu-id="d8a71-127">Costruttori predefiniti</span><span class="sxs-lookup"><span data-stu-id="d8a71-127">Default constructors</span></span>

<span data-ttu-id="d8a71-128">Tutti i tipi di valore dichiarano implicitamente un costruttore di istanza pubblico senza parametri denominato il ***costruttore predefinito***.</span><span class="sxs-lookup"><span data-stu-id="d8a71-128">All value types implicitly declare a public parameterless instance constructor called the ***default constructor***.</span></span> <span data-ttu-id="d8a71-129">Il costruttore predefinito restituisce un'istanza a inizializzazione zero nota come il ***il valore predefinito*** per il tipo di valore:</span><span class="sxs-lookup"><span data-stu-id="d8a71-129">The default constructor returns a zero-initialized instance known as the ***default value*** for the value type:</span></span>

*  <span data-ttu-id="d8a71-130">Per tutti i *simple_type*s, il valore predefinito è il valore restituito da uno schema di bit di tutti gli zero:</span><span class="sxs-lookup"><span data-stu-id="d8a71-130">For all *simple_type*s, the default value is the value produced by a bit pattern of all zeros:</span></span>
    * <span data-ttu-id="d8a71-131">Per la `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, e `ulong`, il valore predefinito è `0`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-131">For `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, and `ulong`, the default value is `0`.</span></span>
    * <span data-ttu-id="d8a71-132">Per la `char`, il valore predefinito è `'\x0000'`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-132">For `char`, the default value is `'\x0000'`.</span></span>
    * <span data-ttu-id="d8a71-133">Per la `float`, il valore predefinito è `0.0f`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-133">For `float`, the default value is `0.0f`.</span></span>
    * <span data-ttu-id="d8a71-134">Per la `double`, il valore predefinito è `0.0d`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-134">For `double`, the default value is `0.0d`.</span></span>
    * <span data-ttu-id="d8a71-135">Per la `decimal`, il valore predefinito è `0.0m`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-135">For `decimal`, the default value is `0.0m`.</span></span>
    * <span data-ttu-id="d8a71-136">Per la `bool`, il valore predefinito è `false`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-136">For `bool`, the default value is `false`.</span></span>
*  <span data-ttu-id="d8a71-137">Per un *enum_type* `E`, il valore predefinito è `0`, convertito nel tipo `E`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-137">For an *enum_type* `E`, the default value is `0`, converted to the type `E`.</span></span>
*  <span data-ttu-id="d8a71-138">Per un *struct_type*, il valore predefinito è il valore generato impostando tutti i campi di tipo di valore al relativo valore predefinito e riferimento a tutti i campi di tipo per `null`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-138">For a *struct_type*, the default value is the value produced by setting all value type fields to their default value and all reference type fields to `null`.</span></span>
*  <span data-ttu-id="d8a71-139">Per un *nullable_type* il valore predefinito è un'istanza per il quale il `HasValue` proprietà è false e `Value` proprietà non è definita.</span><span class="sxs-lookup"><span data-stu-id="d8a71-139">For a *nullable_type* the default value is an instance for which the `HasValue` property is false and the `Value` property is undefined.</span></span> <span data-ttu-id="d8a71-140">Il valore predefinito è noto anche come il ***valore null*** del tipo che ammette valori null.</span><span class="sxs-lookup"><span data-stu-id="d8a71-140">The default value is also known as the ***null value*** of the nullable type.</span></span>

<span data-ttu-id="d8a71-141">Come qualsiasi altro costruttore di istanza, viene richiamato il costruttore predefinito di un tipo di valore usando il `new` operatore.</span><span class="sxs-lookup"><span data-stu-id="d8a71-141">Like any other instance constructor, the default constructor of a value type is invoked using the `new` operator.</span></span> <span data-ttu-id="d8a71-142">Per motivi di efficienza, questo requisito non è pensato per generare una chiamata al costruttore.</span><span class="sxs-lookup"><span data-stu-id="d8a71-142">For efficiency reasons, this requirement is not intended to actually have the implementation generate a constructor call.</span></span> <span data-ttu-id="d8a71-143">Nell'esempio seguente, le variabili `i` e `j` vengono inizializzate su zero.</span><span class="sxs-lookup"><span data-stu-id="d8a71-143">In the example below, variables `i` and `j` are both initialized to zero.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        int j = new int();
    }
}
```

<span data-ttu-id="d8a71-144">Poiché ogni tipo di valore ha implicitamente un costruttore di istanza pubblico senza parametri, non è possibile che un tipo struct contenere una dichiarazione esplicita di un costruttore senza parametri.</span><span class="sxs-lookup"><span data-stu-id="d8a71-144">Because every value type implicitly has a public parameterless instance constructor, it is not possible for a struct type to contain an explicit declaration of a parameterless constructor.</span></span> <span data-ttu-id="d8a71-145">Un tipo struct, tuttavia è possibile dichiarare costruttori di istanze con parametri ([costruttori](structs.md#constructors)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-145">A struct type is however permitted to declare parameterized instance constructors ([Constructors](structs.md#constructors)).</span></span>

### <a name="struct-types"></a><span data-ttu-id="d8a71-146">Tipi struct</span><span class="sxs-lookup"><span data-stu-id="d8a71-146">Struct types</span></span>

<span data-ttu-id="d8a71-147">Un tipo struct è un tipo di valore che è possibile dichiarare le costanti, campi, metodi, proprietà, indicizzatori, operatori, costruttori di istanza, costruttori statici e i tipi annidati.</span><span class="sxs-lookup"><span data-stu-id="d8a71-147">A struct type is a value type that can declare constants, fields, methods, properties, indexers, operators, instance constructors, static constructors, and nested types.</span></span> <span data-ttu-id="d8a71-148">La dichiarazione di tipi struct è descritto nella [dichiarazioni Struct](structs.md#struct-declarations).</span><span class="sxs-lookup"><span data-stu-id="d8a71-148">The declaration of struct types is described in [Struct declarations](structs.md#struct-declarations).</span></span>

### <a name="simple-types"></a><span data-ttu-id="d8a71-149">Tipi semplici</span><span class="sxs-lookup"><span data-stu-id="d8a71-149">Simple types</span></span>

<span data-ttu-id="d8a71-150">C# offre un set di tipi di struct predefinito denominato il ***i tipi semplici***.</span><span class="sxs-lookup"><span data-stu-id="d8a71-150">C# provides a set of predefined struct types called the ***simple types***.</span></span> <span data-ttu-id="d8a71-151">I tipi semplici vengono identificati tramite le parole riservate, ma queste parole riservate sono semplicemente gli alias per i tipi struct predefiniti in di `System` dello spazio dei nomi, come descritto nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="d8a71-151">The simple types are identified through reserved words, but these reserved words are simply aliases for predefined struct types in the `System` namespace, as described in the table below.</span></span>


| <span data-ttu-id="d8a71-152">__Parola riservata__</span><span class="sxs-lookup"><span data-stu-id="d8a71-152">__Reserved word__</span></span> | <span data-ttu-id="d8a71-153">__Tipo di alias__</span><span class="sxs-lookup"><span data-stu-id="d8a71-153">__Aliased type__</span></span> |
|-------------------|------------------|
| `sbyte`           | `System.SByte`   | 
| `byte`            | `System.Byte`    | 
| `short`           | `System.Int16`   | 
| `ushort`          | `System.UInt16`  | 
| `int`             | `System.Int32`   | 
| `uint`            | `System.UInt32`  | 
| `long`            | `System.Int64`   | 
| `ulong`           | `System.UInt64`  | 
| `char`            | `System.Char`    | 
| `float`           | `System.Single`  | 
| `double`          | `System.Double`  | 
| `bool`            | `System.Boolean` | 
| `decimal`         | `System.Decimal` | 

<span data-ttu-id="d8a71-154">Poiché un semplice tipo alias di un tipo struct, ogni tipo semplice ha membri.</span><span class="sxs-lookup"><span data-stu-id="d8a71-154">Because a simple type aliases a struct type, every simple type has members.</span></span> <span data-ttu-id="d8a71-155">Ad esempio, `int` ha i membri dichiarati nella `System.Int32` e i membri ereditati da `System.Object`, e le istruzioni seguenti sono consentite:</span><span class="sxs-lookup"><span data-stu-id="d8a71-155">For example, `int` has the members declared in `System.Int32` and the members inherited from `System.Object`, and the following statements are permitted:</span></span>

```csharp
int i = int.MaxValue;           // System.Int32.MaxValue constant
string s = i.ToString();        // System.Int32.ToString() instance method
string t = 123.ToString();      // System.Int32.ToString() instance method
```

<span data-ttu-id="d8a71-156">I tipi semplici si differenziano da altri tipi struct in quanto permettono alcune operazioni aggiuntive:</span><span class="sxs-lookup"><span data-stu-id="d8a71-156">The simple types differ from other struct types in that they permit certain additional operations:</span></span>

*  <span data-ttu-id="d8a71-157">La maggior parte dei tipi semplici consentono di valori per essere create scrivendo *valori letterali* ([i valori letterali](lexical-structure.md#literals)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-157">Most simple types permit values to be created by writing *literals* ([Literals](lexical-structure.md#literals)).</span></span> <span data-ttu-id="d8a71-158">Ad esempio, `123` è un valore letterale di tipo `int` e `'a'` è un valore letterale di tipo `char`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-158">For example, `123` is a literal of type `int` and `'a'` is a literal of type `char`.</span></span> <span data-ttu-id="d8a71-159">C# non rende in genere non esiste alcun provisioning per i valori letterali dei tipi di struct e i valori non predefiniti di altri tipi di struct vengono sempre creati tramite i costruttori di istanza di tali tipi struct.</span><span class="sxs-lookup"><span data-stu-id="d8a71-159">C# makes no provision for literals of struct types in general, and non-default values of other struct types are ultimately always created through instance constructors of those struct types.</span></span>
*  <span data-ttu-id="d8a71-160">Quando gli operandi dell'espressione sono tutte costanti di tipo semplice, è possibile che il compilatore valutare l'espressione in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-160">When the operands of an expression are all simple type constants, it is possible for the compiler to evaluate the expression at compile-time.</span></span> <span data-ttu-id="d8a71-161">Tale espressione è noto come un *constant_expression* ([espressioni costanti](expressions.md#constant-expressions)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-161">Such an expression is known as a *constant_expression* ([Constant expressions](expressions.md#constant-expressions)).</span></span> <span data-ttu-id="d8a71-162">Espressioni che includono gli operatori definiti da altri tipi di struct non sono considerate espressioni costanti.</span><span class="sxs-lookup"><span data-stu-id="d8a71-162">Expressions involving operators defined by other struct types are not considered to be constant expressions.</span></span>
*  <span data-ttu-id="d8a71-163">Attraverso `const` dichiarazioni è possibile dichiarare le costanti dei tipi semplici ([costanti](classes.md#constants)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-163">Through `const` declarations it is possible to declare constants of the simple types ([Constants](classes.md#constants)).</span></span> <span data-ttu-id="d8a71-164">Non è possibile disporre di costanti di altri tipi di struct, ma viene fornito un risultato simile da `static readonly` campi.</span><span class="sxs-lookup"><span data-stu-id="d8a71-164">It is not possible to have constants of other struct types, but a similar effect is provided by `static readonly` fields.</span></span>
*  <span data-ttu-id="d8a71-165">Conversioni di tipi semplici possono far parte di valutazione degli operatori di conversione definiti da altri tipi di struct, ma un operatore di conversione definita dall'utente non può far parte di valutazione di un altro operatore definito dall'utente ([valutazione di conversioni definite dall'utente](conversions.md#evaluation-of-user-defined-conversions)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-165">Conversions involving simple types can participate in evaluation of conversion operators defined by other struct types, but a user-defined conversion operator can never participate in evaluation of another user-defined operator ([Evaluation of user-defined conversions](conversions.md#evaluation-of-user-defined-conversions)).</span></span>

### <a name="integral-types"></a><span data-ttu-id="d8a71-166">Tipi integrali</span><span class="sxs-lookup"><span data-stu-id="d8a71-166">Integral types</span></span>

<span data-ttu-id="d8a71-167">C# supporta nove tipi integrali: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, e `char`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-167">C# supports nine integral types: `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, and `char`.</span></span> <span data-ttu-id="d8a71-168">I tipi integrali sono le dimensioni e gli intervalli dei valori seguenti:</span><span class="sxs-lookup"><span data-stu-id="d8a71-168">The integral types have the following sizes and ranges of values:</span></span>

*  <span data-ttu-id="d8a71-169">Il `sbyte` rappresenta di tipo signed integer a 8 bit con valori compresi tra -128 e 127.</span><span class="sxs-lookup"><span data-stu-id="d8a71-169">The `sbyte` type represents signed 8-bit integers with values between -128 and 127.</span></span>
*  <span data-ttu-id="d8a71-170">Il `byte` tipo rappresenta interi senza segno a 8 bit con valori compresi tra 0 e 255.</span><span class="sxs-lookup"><span data-stu-id="d8a71-170">The `byte` type represents unsigned 8-bit integers with values between 0 and 255.</span></span>
*  <span data-ttu-id="d8a71-171">Il `short` rappresenta di tipo signed integer a 16 bit con valori compresi tra -32768 e 32767.</span><span class="sxs-lookup"><span data-stu-id="d8a71-171">The `short` type represents signed 16-bit integers with values between -32768 and 32767.</span></span>
*  <span data-ttu-id="d8a71-172">Il `ushort` tipo rappresenta interi senza segno a 16 bit con valori compresi tra 0 e 65535.</span><span class="sxs-lookup"><span data-stu-id="d8a71-172">The `ushort` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span>
*  <span data-ttu-id="d8a71-173">Il `int` rappresenta di tipo signed integer a 32 bit con valori compresi tra -2147483648 e 2147483647.</span><span class="sxs-lookup"><span data-stu-id="d8a71-173">The `int` type represents signed 32-bit integers with values between -2147483648 and 2147483647.</span></span>
*  <span data-ttu-id="d8a71-174">Il `uint` tipo rappresenta interi senza segno a 32 bit con valori compresi tra 0 e 4294967295.</span><span class="sxs-lookup"><span data-stu-id="d8a71-174">The `uint` type represents unsigned 32-bit integers with values between 0 and 4294967295.</span></span>
*  <span data-ttu-id="d8a71-175">Il `long` rappresenta di tipo signed integer a 64 bit con valori compresi tra -9223372036854775808 e 9223372036854775807.</span><span class="sxs-lookup"><span data-stu-id="d8a71-175">The `long` type represents signed 64-bit integers with values between -9223372036854775808 and 9223372036854775807.</span></span>
*  <span data-ttu-id="d8a71-176">Il `ulong` tipo rappresenta interi senza segno a 64 bit con valori compresi tra 0 e 18446744073709551615.</span><span class="sxs-lookup"><span data-stu-id="d8a71-176">The `ulong` type represents unsigned 64-bit integers with values between 0 and 18446744073709551615.</span></span>
*  <span data-ttu-id="d8a71-177">Il `char` tipo rappresenta interi senza segno a 16 bit con valori compresi tra 0 e 65535.</span><span class="sxs-lookup"><span data-stu-id="d8a71-177">The `char` type represents unsigned 16-bit integers with values between 0 and 65535.</span></span> <span data-ttu-id="d8a71-178">Il set di valori possibili per il `char` tipo corrisponde al set di caratteri Unicode.</span><span class="sxs-lookup"><span data-stu-id="d8a71-178">The set of possible values for the `char` type corresponds to the Unicode character set.</span></span> <span data-ttu-id="d8a71-179">Sebbene `char` ha la stessa rappresentazione di `ushort`, non tutte le operazioni consentite su un tipo sono consentite in altro.</span><span class="sxs-lookup"><span data-stu-id="d8a71-179">Although `char` has the same representation as `ushort`, not all operations permitted on one type are permitted on the other.</span></span>

<span data-ttu-id="d8a71-180">Il tipo integrale operatori unari e binari operano sempre con precisione a 32 bit con segno, precisione a 32 bit senza segno, precisione a 64 bit con segno o senza segno a 64 bit precisione:</span><span class="sxs-lookup"><span data-stu-id="d8a71-180">The integral-type unary and binary operators always operate with signed 32-bit precision, unsigned 32-bit precision, signed 64-bit precision, or unsigned 64-bit precision:</span></span>

*  <span data-ttu-id="d8a71-181">Per l'operatore unario `+` e `~` operatori, l'operando viene convertito nel tipo `T`, dove `T` è la prima delle `int`, `uint`, `long`, e `ulong` che può rappresentare completamente tutti valori possibili dell'operando.</span><span class="sxs-lookup"><span data-stu-id="d8a71-181">For the unary `+` and `~` operators, the operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="d8a71-182">L'operazione viene quindi eseguita con la precisione del tipo `T`, e il tipo del risultato è `T`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-182">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>
*  <span data-ttu-id="d8a71-183">Per l'operatore unario `-` operatore, operando verrà convertito nel tipo `T`, dove `T` è la prima delle `int` e `long` che può rappresentare completamente tutti i valori possibili dell'operando.</span><span class="sxs-lookup"><span data-stu-id="d8a71-183">For the unary `-` operator, the operand is converted to type `T`, where `T` is the first of `int` and `long` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="d8a71-184">L'operazione viene quindi eseguita con la precisione del tipo `T`, e il tipo del risultato è `T`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-184">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span> <span data-ttu-id="d8a71-185">Operatore unario `-` operatore non può essere applicato a operandi di tipo `ulong`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-185">The unary `-` operator cannot be applied to operands of type `ulong`.</span></span>
*  <span data-ttu-id="d8a71-186">Per il file binario `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`, e `<=` operatori, gli operandi verranno convertiti nel tipo `T`, dove `T` è la prima delle `int`, `uint`, `long`, e `ulong` che può rappresentare completamente tutte le possibili valori di entrambi gli operandi.</span><span class="sxs-lookup"><span data-stu-id="d8a71-186">For the binary `+`, `-`, `*`, `/`, `%`, `&`, `^`, `|`, `==`, `!=`, `>`, `<`, `>=`, and `<=` operators, the operands are converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of both operands.</span></span> <span data-ttu-id="d8a71-187">L'operazione viene quindi eseguita con la precisione del tipo `T`, e il tipo del risultato è `T` (o `bool` per gli operatori relazionali).</span><span class="sxs-lookup"><span data-stu-id="d8a71-187">The operation is then performed using the precision of type `T`, and the type of the result is `T` (or `bool` for the relational operators).</span></span> <span data-ttu-id="d8a71-188">Non è consentito per un operando di tipo `long` e l'altro di tipo `ulong` con gli operatori binari.</span><span class="sxs-lookup"><span data-stu-id="d8a71-188">It is not permitted for one operand to be of type `long` and the other to be of type `ulong` with the binary operators.</span></span>
*  <span data-ttu-id="d8a71-189">Per il file binario `<<` e `>>` operatori, il secondo operando viene convertito nel tipo `T`, dove `T` è la prima delle `int`, `uint`, `long`, e `ulong` che può rappresentare completamente tutti valori possibili dell'operando.</span><span class="sxs-lookup"><span data-stu-id="d8a71-189">For the binary `<<` and `>>` operators, the left operand is converted to type `T`, where `T` is the first of `int`, `uint`, `long`, and `ulong` that can fully represent all possible values of the operand.</span></span> <span data-ttu-id="d8a71-190">L'operazione viene quindi eseguita con la precisione del tipo `T`, e il tipo del risultato è `T`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-190">The operation is then performed using the precision of type `T`, and the type of the result is `T`.</span></span>

<span data-ttu-id="d8a71-191">Il `char` tipo viene classificato come un tipo integrale, ma differisce dagli altri tipi integrali in due modi:</span><span class="sxs-lookup"><span data-stu-id="d8a71-191">The `char` type is classified as an integral type, but it differs from the other integral types in two ways:</span></span>

*  <span data-ttu-id="d8a71-192">Non sono presenti conversioni implicite di altri tipi di `char` tipo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-192">There are no implicit conversions from other types to the `char` type.</span></span> <span data-ttu-id="d8a71-193">In particolare, anche se il `sbyte`, `byte`, e `ushort` tipi hanno intervalli di valori che sono completamente rappresentabile utilizzando la `char` digita, le conversioni implicite dal `sbyte`, `byte`, o `ushort` a `char` non esistono.</span><span class="sxs-lookup"><span data-stu-id="d8a71-193">In particular, even though the `sbyte`, `byte`, and `ushort` types have ranges of values that are fully representable using the `char` type, implicit conversions from `sbyte`, `byte`, or `ushort` to `char` do not exist.</span></span>
*  <span data-ttu-id="d8a71-194">Costanti del `char` tipo deve essere scritto come *character_literal*s o come *integer_literal*s in combinazione con un cast al tipo `char`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-194">Constants of the `char` type must be written as *character_literal*s or as *integer_literal*s in combination with a cast to type `char`.</span></span> <span data-ttu-id="d8a71-195">Ad esempio, `(char)10` equivale a `'\x000A'`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-195">For example, `(char)10` is the same as `'\x000A'`.</span></span>

<span data-ttu-id="d8a71-196">Il `checked` e `unchecked` istruzioni e gli operatori consentono di controllare controllo di overflow per conversioni e operazioni aritmetiche di tipo integrale ([gli operatori checked e unchecked](expressions.md#the-checked-and-unchecked-operators)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-196">The `checked` and `unchecked` operators and statements are used to control overflow checking for integral-type arithmetic operations and conversions ([The checked and unchecked operators](expressions.md#the-checked-and-unchecked-operators)).</span></span> <span data-ttu-id="d8a71-197">In un `checked` contesto, un overflow genera un errore in fase di compilazione o causa un `System.OverflowException` generata.</span><span class="sxs-lookup"><span data-stu-id="d8a71-197">In a `checked` context, an overflow produces a compile-time error or causes a `System.OverflowException` to be thrown.</span></span> <span data-ttu-id="d8a71-198">In un `unchecked` contesto di overflow vengono ignorati e vengono eliminati tutti i bit più significativi che non rientrano nel tipo di destinazione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-198">In an `unchecked` context, overflows are ignored and any high-order bits that do not fit in the destination type are discarded.</span></span>

### <a name="floating-point-types"></a><span data-ttu-id="d8a71-199">Tipi a virgola mobile</span><span class="sxs-lookup"><span data-stu-id="d8a71-199">Floating point types</span></span>

<span data-ttu-id="d8a71-200">C# supporta due tipi a virgola mobile: `float` e `double`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-200">C# supports two floating point types: `float` and `double`.</span></span> <span data-ttu-id="d8a71-201">Il `float` e `double` tipi vengono rappresentati usando i 32 bit e precisione singola e a 64 bit a precisione doppia IEEE 754 formati, che forniscono i seguenti insiemi di valori:</span><span class="sxs-lookup"><span data-stu-id="d8a71-201">The `float` and `double` types are represented using the 32-bit single-precision and 64-bit double-precision IEEE 754 formats, which provide the following sets of values:</span></span>

*  <span data-ttu-id="d8a71-202">Positivo zero e zero negativo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-202">Positive zero and negative zero.</span></span> <span data-ttu-id="d8a71-203">Nella maggior parte delle situazioni, zero positivo e negativo zero hanno lo stesso comportamento come valore semplice da zero, ma alcune operazioni di distinguono tra i due ([operatore di divisione](expressions.md#division-operator)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-203">In most situations, positive zero and negative zero behave identically as the simple value zero, but certain operations distinguish between the two ([Division operator](expressions.md#division-operator)).</span></span>
*  <span data-ttu-id="d8a71-204">Infinito positivo e un numero infinito negativo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-204">Positive infinity and negative infinity.</span></span> <span data-ttu-id="d8a71-205">Valori infiniti vengono prodotte da operazioni quali la divisione di un numero diverso da zero per zero.</span><span class="sxs-lookup"><span data-stu-id="d8a71-205">Infinities are produced by such operations as dividing a non-zero number by zero.</span></span> <span data-ttu-id="d8a71-206">Ad esempio, `1.0 / 0.0` produce un numero infinito positivo, e `-1.0 / 0.0` restituisce infinito negativo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-206">For example, `1.0 / 0.0` yields positive infinity, and `-1.0 / 0.0` yields negative infinity.</span></span>
*  <span data-ttu-id="d8a71-207">Il ***non un numero*** valore, spesso abbreviato NaN.</span><span class="sxs-lookup"><span data-stu-id="d8a71-207">The ***Not-a-Number*** value, often abbreviated NaN.</span></span> <span data-ttu-id="d8a71-208">NaN generati dalle operazioni a virgola mobile non valide, ad esempio divisione per zero di zero.</span><span class="sxs-lookup"><span data-stu-id="d8a71-208">NaNs are produced by invalid floating-point operations, such as dividing zero by zero.</span></span>
*  <span data-ttu-id="d8a71-209">Insieme finito di valori zero nel formato `s * m * 2^e`, dove `s` è 1 o -1, e `m` e `e` dipendono dal tipo a virgola mobile particolare: Per la `float`, `0 < m < 2^24` e `-149 <= e <= 104`e per `double`, `0 < m < 2^53` e `1075 <= e <= 970`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-209">The finite set of non-zero values of the form `s * m * 2^e`, where `s` is 1 or -1, and `m` and `e` are determined by the particular floating-point type: For `float`, `0 < m < 2^24` and `-149 <= e <= 104`, and for `double`, `0 < m < 2^53` and `1075 <= e <= 970`.</span></span> <span data-ttu-id="d8a71-210">Numeri a virgola mobile denormalizzati sono considerati validi valori diversi da zero.</span><span class="sxs-lookup"><span data-stu-id="d8a71-210">Denormalized floating-point numbers are considered valid non-zero values.</span></span>

<span data-ttu-id="d8a71-211">Il `float` tipo può rappresentare valori compresi tra circa `1.5 * 10^-45` a `3.4 * 10^38` con una precisione di 7 cifre.</span><span class="sxs-lookup"><span data-stu-id="d8a71-211">The `float` type can represent values ranging from approximately `1.5 * 10^-45` to `3.4 * 10^38` with a precision of 7 digits.</span></span>

<span data-ttu-id="d8a71-212">Il `double` tipo può rappresentare valori compresi tra circa `5.0 * 10^-324` a `1.7 × 10^308` con un'approssimazione di 15-16 cifre.</span><span class="sxs-lookup"><span data-stu-id="d8a71-212">The `double` type can represent values ranging from approximately `5.0 * 10^-324` to `1.7 × 10^308` with a precision of 15-16 digits.</span></span>

<span data-ttu-id="d8a71-213">Se uno degli operandi di un operatore binario è di tipo a virgola mobile, quindi l'altro operando deve essere di un tipo integrale o un tipo a virgola mobile e l'operazione viene valutata nel modo seguente:</span><span class="sxs-lookup"><span data-stu-id="d8a71-213">If one of the operands of a binary operator is of a floating-point type, then the other operand must be of an integral type or a floating-point type, and the operation is evaluated as follows:</span></span>

*  <span data-ttu-id="d8a71-214">Se uno degli operandi è di tipo integrale, tale operando verrà convertito nel tipo a virgola mobile di altro operando.</span><span class="sxs-lookup"><span data-stu-id="d8a71-214">If one of the operands is of an integral type, then that operand is converted to the floating-point type of the other operand.</span></span>
*  <span data-ttu-id="d8a71-215">Quindi, se uno degli operandi è di tipo `double`, l'altro operando viene convertito in `double`, l'operazione viene eseguita utilizzando almeno `double` intervallo e precisione e il tipo del risultato viene `double` (o `bool` per il operatori relazionali).</span><span class="sxs-lookup"><span data-stu-id="d8a71-215">Then, if either of the operands is of type `double`, the other operand is converted to `double`, the operation is performed using at least `double` range and precision, and the type of the result is `double` (or `bool` for the relational operators).</span></span>
*  <span data-ttu-id="d8a71-216">In caso contrario, l'operazione viene eseguita utilizzando almeno `float` intervallo e precisione e il tipo del risultato viene `float` (o `bool` per gli operatori relazionali).</span><span class="sxs-lookup"><span data-stu-id="d8a71-216">Otherwise, the operation is performed using at least `float` range and precision, and the type of the result is `float` (or `bool` for the relational operators).</span></span>

<span data-ttu-id="d8a71-217">Gli operatori a virgola mobile, inclusi gli operatori di assegnazione, mai generano eccezioni.</span><span class="sxs-lookup"><span data-stu-id="d8a71-217">The floating-point operators, including the assignment operators, never produce exceptions.</span></span> <span data-ttu-id="d8a71-218">In situazioni eccezionali, invece, le operazioni a virgola mobile e producono zero, infinito o NaN, come descritto di seguito:</span><span class="sxs-lookup"><span data-stu-id="d8a71-218">Instead, in exceptional situations, floating-point operations produce zero, infinity, or NaN, as described below:</span></span>

*  <span data-ttu-id="d8a71-219">Se il risultato di un'operazione a virgola mobile è troppo piccolo per il formato di destinazione, il risultato dell'operazione diventa zero positivo o negativo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-219">If the result of a floating-point operation is too small for the destination format, the result of the operation becomes positive zero or negative zero.</span></span>
*  <span data-ttu-id="d8a71-220">Se il risultato di un'operazione a virgola mobile è troppo grande per il formato di destinazione, il risultato dell'operazione sarà infinito positivo o negativo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-220">If the result of a floating-point operation is too large for the destination format, the result of the operation becomes positive infinity or negative infinity.</span></span>
*  <span data-ttu-id="d8a71-221">Se un'operazione a virgola mobile non è valida, il risultato dell'operazione diventa NaN.</span><span class="sxs-lookup"><span data-stu-id="d8a71-221">If a floating-point operation is invalid, the result of the operation becomes NaN.</span></span>
*  <span data-ttu-id="d8a71-222">Se uno o entrambi gli operandi di un'operazione a virgola mobile è NaN, il risultato dell'operazione diventa NaN.</span><span class="sxs-lookup"><span data-stu-id="d8a71-222">If one or both operands of a floating-point operation is NaN, the result of the operation becomes NaN.</span></span>

<span data-ttu-id="d8a71-223">Operazioni a virgola mobile possono essere eseguite con una maggiore precisione rispetto al tipo di risultato dell'operazione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-223">Floating-point operations may be performed with higher precision than the result type of the operation.</span></span> <span data-ttu-id="d8a71-224">Ad esempio, alcune architetture hardware supportano un tipo a virgola mobile "extended" o "long double" con una gamma più ampia e offre una precisione maggiore di `double` digitare ed eseguire in modo implicito tutte le operazioni a virgola mobile con questo tipo con precisione superiore.</span><span class="sxs-lookup"><span data-stu-id="d8a71-224">For example, some hardware architectures support an "extended" or "long double" floating-point type with greater range and precision than the `double` type, and implicitly perform all floating-point operations using this higher precision type.</span></span> <span data-ttu-id="d8a71-225">Comporterebbe costi di prestazioni tali architetture hardware per poter eseguire operazioni a virgola mobile con precisione inferiore, e invece di richiedere un'implementazione per rinunciare le prestazioni e la precisione, c# consente di essere un tipo di precisione superiore utilizzato per tutte le operazioni a virgola mobile.</span><span class="sxs-lookup"><span data-stu-id="d8a71-225">Only at excessive cost in performance can such hardware architectures be made to perform floating-point operations with less precision, and rather than require an implementation to forfeit both performance and precision, C# allows a higher precision type to be used for all floating-point operations.</span></span> <span data-ttu-id="d8a71-226">Diverso da fornire risultati più precisi, questo raramente ha effetti misurabili.</span><span class="sxs-lookup"><span data-stu-id="d8a71-226">Other than delivering more precise results, this rarely has any measurable effects.</span></span> <span data-ttu-id="d8a71-227">Tuttavia, nelle espressioni del form `x * y / z`, in cui il risultato della moltiplicazione che non è compreso il `double` intervallo, ma la divisione successiva Visualizza i risultati temporanei nel `double` intervallo, il fatto che l'espressione è valutata in un intervallo più alto formato può causare un risultato finito anziché un numero infinito.</span><span class="sxs-lookup"><span data-stu-id="d8a71-227">However, in expressions of the form `x * y / z`, where the multiplication produces a result that is outside the `double` range, but the subsequent division brings the temporary result back into the `double` range, the fact that the expression is evaluated in a higher range format may cause a finite result to be produced instead of an infinity.</span></span>

### <a name="the-decimal-type"></a><span data-ttu-id="d8a71-228">Il tipo decimal</span><span class="sxs-lookup"><span data-stu-id="d8a71-228">The decimal type</span></span>

<span data-ttu-id="d8a71-229">Il tipo `decimal` è un tipo dati a 128 bit adatto per i calcoli finanziari e monetari.</span><span class="sxs-lookup"><span data-stu-id="d8a71-229">The `decimal` type is a 128-bit data type suitable for financial and monetary calculations.</span></span> <span data-ttu-id="d8a71-230">Il `decimal` tipo può rappresentare valori compresi tra `1.0 * 10^-28` a circa `7.9 * 10^28` con 28-29 cifre significative.</span><span class="sxs-lookup"><span data-stu-id="d8a71-230">The `decimal` type can represent values ranging from `1.0 * 10^-28` to approximately `7.9 * 10^28` with 28-29 significant digits.</span></span>

<span data-ttu-id="d8a71-231">Insieme finito di valori di tipo `decimal` hanno la forma `(-1)^s * c * 10^-e`, dove il segno `s` è 0 o 1, il coefficiente `c` è dato dai `0 <= *c* < 2^96`e la scala `e` è tale che `0 <= e <= 28`. Il `decimal` tipo nepodporuje zero con segno, valori infiniti o NaN.</span><span class="sxs-lookup"><span data-stu-id="d8a71-231">The finite set of values of type `decimal` are of the form `(-1)^s * c * 10^-e`, where the sign `s` is 0 or 1, the coefficient `c` is given by `0 <= *c* < 2^96`, and the scale `e` is such that `0 <= e <= 28`.The `decimal` type does not support signed zeros, infinities, or NaN's.</span></span> <span data-ttu-id="d8a71-232">Oggetto `decimal` è rappresentato come intero a 96 bit scalato in base a una potenza di dieci.</span><span class="sxs-lookup"><span data-stu-id="d8a71-232">A `decimal` is represented as a 96-bit integer scaled by a power of ten.</span></span> <span data-ttu-id="d8a71-233">Per la `decimal`con un valore assoluto minore `1.0m`, il valore è esatta per la posizione decimale 28, ma non oltre.</span><span class="sxs-lookup"><span data-stu-id="d8a71-233">For `decimal`s with an absolute value less than `1.0m`, the value is exact to the 28th decimal place, but no further.</span></span> <span data-ttu-id="d8a71-234">Per la `decimal`con un valore assoluto maggiore o uguale a `1.0m`, il valore è esatto a 28 o 29 cifre.</span><span class="sxs-lookup"><span data-stu-id="d8a71-234">For `decimal`s with an absolute value greater than or equal to `1.0m`, the value is exact to 28 or 29 digits.</span></span> <span data-ttu-id="d8a71-235">Contrario al `float` e `double` tipi di dati, i numeri decimali frazionari come 0.1 possono essere rappresentati esattamente nel `decimal` rappresentazione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-235">Contrary to the `float` and `double` data types, decimal fractional numbers such as 0.1 can be represented exactly in the `decimal` representation.</span></span> <span data-ttu-id="d8a71-236">Nel `float` e `double` rappresentazioni, questi numeri sono spesso infinite frazioni, rendendo più inclini a arrotondamento errori.</span><span class="sxs-lookup"><span data-stu-id="d8a71-236">In the `float` and `double` representations, such numbers are often infinite fractions, making those representations more prone to round-off errors.</span></span>

<span data-ttu-id="d8a71-237">Se uno degli operandi di un operatore binario JE typu `decimal`, quindi l'altro operando deve essere di tipo integrale o di tipo `decimal`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-237">If one of the operands of a binary operator is of type `decimal`, then the other operand must be of an integral type or of type `decimal`.</span></span> <span data-ttu-id="d8a71-238">Se è presente un operando di tipo integrale, questo viene convertito in `decimal` prima che l'operazione viene eseguita.</span><span class="sxs-lookup"><span data-stu-id="d8a71-238">If an integral type operand is present, it is converted to `decimal` before the operation is performed.</span></span>

<span data-ttu-id="d8a71-239">Il risultato di un'operazione sui valori di tipo `decimal` è che si otterrebbe calcolando un risultato esatto (mantenimento scalabilità, come definito per ogni operatore presente) e quindi arrotondando per adattare la rappresentazione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-239">The result of an operation on values of type `decimal` is that which would result from calculating an exact result (preserving scale, as defined for each operator) and then rounding to fit the representation.</span></span> <span data-ttu-id="d8a71-240">I risultati vengono arrotondati per di più prossimo valore rappresentabile, e, quando il risultato è egualmente vicino a due valori rappresentabili, il valore con un numero pari alla posizione meno significativo (questo è noto come "il metodo di arrotondamento").</span><span class="sxs-lookup"><span data-stu-id="d8a71-240">Results are rounded to the nearest representable value, and, when a result is equally close to two representable values, to the value that has an even number in the least significant digit position (this is known as "banker's rounding").</span></span> <span data-ttu-id="d8a71-241">Alcun risultato, ha sempre un segno di 0 e una scala pari a 0.</span><span class="sxs-lookup"><span data-stu-id="d8a71-241">A zero result always has a sign of 0 and a scale of 0.</span></span>

<span data-ttu-id="d8a71-242">Se un'operazione aritmetica decimale produce un valore minore o uguale a `5 * 10^-29` in valore assoluto, il risultato dell'operazione diventa zero.</span><span class="sxs-lookup"><span data-stu-id="d8a71-242">If a decimal arithmetic operation produces a value less than or equal to `5 * 10^-29` in absolute value, the result of the operation becomes zero.</span></span> <span data-ttu-id="d8a71-243">Se un `decimal` aritmetica produce un risultato troppo grande per il `decimal` formato, un `System.OverflowException` viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-243">If a `decimal` arithmetic operation produces a result that is too large for the `decimal` format, a `System.OverflowException` is thrown.</span></span>

<span data-ttu-id="d8a71-244">Il `decimal` tipo ha una precisione maggiore intervallo di dimensioni ridotte rispetto ai tipi a virgola mobile.</span><span class="sxs-lookup"><span data-stu-id="d8a71-244">The `decimal` type has greater precision but smaller range than the floating-point types.</span></span> <span data-ttu-id="d8a71-245">Di conseguenza, le conversioni dai tipi a virgola mobile a `decimal` potrebbe generare eccezioni di overflow e le conversioni da `decimal` ai tipi a virgola mobile potrebbe causare la perdita di precisione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-245">Thus, conversions from the floating-point types to `decimal` might produce overflow exceptions, and conversions from `decimal` to the floating-point types might cause loss of precision.</span></span> <span data-ttu-id="d8a71-246">Per questi motivi, non esiste alcuna conversione implicite tra i tipi a virgola mobile e `decimal`, e senza cast espliciti, non è possibile combinare a virgola mobile e `decimal` operandi nella stessa espressione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-246">For these reasons, no implicit conversions exist between the floating-point types and `decimal`, and without explicit casts, it is not possible to mix floating-point and `decimal` operands in the same expression.</span></span>

### <a name="the-bool-type"></a><span data-ttu-id="d8a71-247">Il tipo bool</span><span class="sxs-lookup"><span data-stu-id="d8a71-247">The bool type</span></span>

<span data-ttu-id="d8a71-248">Il `bool` tipo rappresenta le quantità di logiche booleane.</span><span class="sxs-lookup"><span data-stu-id="d8a71-248">The `bool` type represents boolean logical quantities.</span></span> <span data-ttu-id="d8a71-249">I possibili valori di tipo `bool` vengono `true` e `false`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-249">The possible values of type `bool` are `true` and `false`.</span></span>

<span data-ttu-id="d8a71-250">Non esiste alcuna conversione standard tra `bool` e altri tipi.</span><span class="sxs-lookup"><span data-stu-id="d8a71-250">No standard conversions exist between `bool` and other types.</span></span> <span data-ttu-id="d8a71-251">In particolare, il `bool` è di tipo distinto e separato da tipi integrali e un' `bool` valore non può essere utilizzato al posto di un valore integrale e viceversa.</span><span class="sxs-lookup"><span data-stu-id="d8a71-251">In particular, the `bool` type is distinct and separate from the integral types, and a `bool` value cannot be used in place of an integral value, and vice versa.</span></span>

<span data-ttu-id="d8a71-252">Nei linguaggi C e C++, un valore pari a zero integrale o a virgola mobile o un puntatore null può essere convertito nel valore booleano `false`, e un valore integrale o a virgola mobile e diverso da zero o un puntatore null non può essere convertito nel valore booleano `true`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-252">In the C and C++ languages, a zero integral or floating-point value, or a null pointer can be converted to the boolean value `false`, and a non-zero integral or floating-point value, or a non-null pointer can be converted to the boolean value `true`.</span></span> <span data-ttu-id="d8a71-253">In c#, queste conversioni vengono portate a termine confrontando in modo esplicito un valore integrale o a virgola mobile a zero o confrontando in modo esplicito un riferimento a oggetto `null`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-253">In C#, such conversions are accomplished by explicitly comparing an integral or floating-point value to zero, or by explicitly comparing an object reference to `null`.</span></span>

### <a name="enumeration-types"></a><span data-ttu-id="d8a71-254">Tipi di enumerazione</span><span class="sxs-lookup"><span data-stu-id="d8a71-254">Enumeration types</span></span>

<span data-ttu-id="d8a71-255">Un tipo di enumerazione è un tipo distinto con costanti denominate.</span><span class="sxs-lookup"><span data-stu-id="d8a71-255">An enumeration type is a distinct type with named constants.</span></span> <span data-ttu-id="d8a71-256">Ogni tipo di enumerazione ha un tipo sottostante, che deve essere `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` o `ulong`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-256">Every enumeration type has an underlying type, which must be `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long` or `ulong`.</span></span> <span data-ttu-id="d8a71-257">Il set di valori del tipo di enumerazione è quello utilizzato per il set di valori del tipo sottostante.</span><span class="sxs-lookup"><span data-stu-id="d8a71-257">The set of values of the enumeration type is the same as the set of values of the underlying type.</span></span> <span data-ttu-id="d8a71-258">Valori del tipo di enumerazione non sono limitati ai valori delle costanti denominate.</span><span class="sxs-lookup"><span data-stu-id="d8a71-258">Values of the enumeration type are not restricted to the values of the named constants.</span></span> <span data-ttu-id="d8a71-259">I tipi di enumerazione vengono definiti tramite le dichiarazioni di enumerazione ([le dichiarazioni di enumerazione](enums.md#enum-declarations)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-259">Enumeration types are defined through enumeration declarations ([Enum declarations](enums.md#enum-declarations)).</span></span>

### <a name="nullable-types"></a><span data-ttu-id="d8a71-260">Tipi nullable</span><span class="sxs-lookup"><span data-stu-id="d8a71-260">Nullable types</span></span>

<span data-ttu-id="d8a71-261">Un tipo nullable può rappresentare tutti i valori del relativo ***tipo sottostante*** oltre a un altro valore null.</span><span class="sxs-lookup"><span data-stu-id="d8a71-261">A nullable type can represent all values of its ***underlying type*** plus an additional null value.</span></span> <span data-ttu-id="d8a71-262">Un tipo nullable è scritto `T?`, dove `T` è il tipo sottostante.</span><span class="sxs-lookup"><span data-stu-id="d8a71-262">A nullable type is written `T?`, where `T` is the underlying type.</span></span> <span data-ttu-id="d8a71-263">Questa sintassi è la sintassi abbreviata per `System.Nullable<T>`, e le due forme possono essere usate in modo intercambiabile.</span><span class="sxs-lookup"><span data-stu-id="d8a71-263">This syntax is shorthand for `System.Nullable<T>`, and the two forms can be used interchangeably.</span></span>

<span data-ttu-id="d8a71-264">Oggetto ***tipo di valore non nullable*** viceversa è qualsiasi tipo di valore diverso da `System.Nullable<T>` e dalla relativa abbreviazione `T?` (per qualsiasi `T`), oltre a qualsiasi parametro di tipo vincolato a essere un tipo di valore non nullable (ovvero, qualsiasi parametro di tipo con un `struct` vincolo).</span><span class="sxs-lookup"><span data-stu-id="d8a71-264">A ***non-nullable value type*** conversely is any value type other than `System.Nullable<T>` and its shorthand `T?` (for any `T`), plus any type parameter that is constrained to be a non-nullable value type (that is, any type parameter with a `struct` constraint).</span></span> <span data-ttu-id="d8a71-265">Il `System.Nullable<T>` tipo specifica il vincolo di tipo valore per `T` ([digitare i vincoli del parametro](classes.md#type-parameter-constraints)), il che significa che il tipo sottostante di un tipo nullable può essere qualsiasi tipo di valore non nullable.</span><span class="sxs-lookup"><span data-stu-id="d8a71-265">The `System.Nullable<T>` type specifies the value type constraint for `T` ([Type parameter constraints](classes.md#type-parameter-constraints)), which means that the underlying type of a nullable type can be any non-nullable value type.</span></span> <span data-ttu-id="d8a71-266">Il tipo sottostante di un tipo nullable non può essere un tipo nullable o un tipo riferimento.</span><span class="sxs-lookup"><span data-stu-id="d8a71-266">The underlying type of a nullable type cannot be a nullable type or a reference type.</span></span> <span data-ttu-id="d8a71-267">Ad esempio, `int??` e `string?` sono tipi non è validi.</span><span class="sxs-lookup"><span data-stu-id="d8a71-267">For example, `int??` and `string?` are invalid types.</span></span>

<span data-ttu-id="d8a71-268">Un'istanza di un tipo nullable `T?` ha due proprietà pubbliche di sola lettura:</span><span class="sxs-lookup"><span data-stu-id="d8a71-268">An instance of a nullable type `T?` has two public read-only properties:</span></span>

*  <span data-ttu-id="d8a71-269">Oggetto `HasValue` vlastnosti typu `bool`</span><span class="sxs-lookup"><span data-stu-id="d8a71-269">A `HasValue` property of type `bool`</span></span>
*  <span data-ttu-id="d8a71-270">Oggetto `Value` vlastnosti typu `T`</span><span class="sxs-lookup"><span data-stu-id="d8a71-270">A `Value` property of type `T`</span></span>

<span data-ttu-id="d8a71-271">Un'istanza per il quale `HasValue` è true viene definito per essere non null.</span><span class="sxs-lookup"><span data-stu-id="d8a71-271">An instance for which `HasValue` is true is said to be non-null.</span></span> <span data-ttu-id="d8a71-272">Un'istanza non null contiene un valore noto e `Value` restituisce tale valore.</span><span class="sxs-lookup"><span data-stu-id="d8a71-272">A non-null instance contains a known value and `Value` returns that value.</span></span>

<span data-ttu-id="d8a71-273">Un'istanza per il quale `HasValue` è FALSO è detto null.</span><span class="sxs-lookup"><span data-stu-id="d8a71-273">An instance for which `HasValue` is false is said to be null.</span></span> <span data-ttu-id="d8a71-274">Un'istanza null è un valore indefinito.</span><span class="sxs-lookup"><span data-stu-id="d8a71-274">A null instance has an undefined value.</span></span> <span data-ttu-id="d8a71-275">Tentativo di leggere il `Value` di un'istanza null causa un `System.InvalidOperationException` generata.</span><span class="sxs-lookup"><span data-stu-id="d8a71-275">Attempting to read the `Value` of a null instance causes a `System.InvalidOperationException` to be thrown.</span></span> <span data-ttu-id="d8a71-276">Il processo di accesso di `Value` proprietà di un'istanza che ammette valori null è detta ***eseguire l'operazione Unwrap***.</span><span class="sxs-lookup"><span data-stu-id="d8a71-276">The process of accessing the `Value` property of a nullable instance is referred to as ***unwrapping***.</span></span>

<span data-ttu-id="d8a71-277">Oltre al costruttore predefinito, tutti i tipi nullable `T?` ha un costruttore pubblico che accetta un singolo argomento di tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-277">In addition to the default constructor, every nullable type `T?` has a public constructor that takes a single argument of type `T`.</span></span> <span data-ttu-id="d8a71-278">Dato un valore `x` di tipo `T`, una chiamata del costruttore del form</span><span class="sxs-lookup"><span data-stu-id="d8a71-278">Given a value `x` of type `T`, a constructor invocation of the form</span></span>

```csharp
new T?(x)
```
<span data-ttu-id="d8a71-279">Crea un'istanza non null di `T?` per il quale il `Value` è di proprietà `x`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-279">creates a non-null instance of `T?` for which the `Value` property is `x`.</span></span> <span data-ttu-id="d8a71-280">Il processo di creazione di un'istanza non null di un tipo che ammette valori null per un determinato valore viene definito ***wrapping***.</span><span class="sxs-lookup"><span data-stu-id="d8a71-280">The process of creating a non-null instance of a nullable type for a given value is referred to as ***wrapping***.</span></span>

<span data-ttu-id="d8a71-281">Le conversioni implicite sono disponibili il `null` valore letterale `T?` ([conversioni di valori letterali Null](conversions.md#null-literal-conversions)) e da `T` a `T?` ([conversioni implicite nullable](conversions.md#implicit-nullable-conversions)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-281">Implicit conversions are available from the `null` literal to `T?` ([Null literal conversions](conversions.md#null-literal-conversions)) and from `T` to `T?` ([Implicit nullable conversions](conversions.md#implicit-nullable-conversions)).</span></span>

## <a name="reference-types"></a><span data-ttu-id="d8a71-282">Tipi riferimento</span><span class="sxs-lookup"><span data-stu-id="d8a71-282">Reference types</span></span>

<span data-ttu-id="d8a71-283">Un tipo di riferimento è un tipo di classe, un tipo di interfaccia, un tipo di matrice o un tipo delegato.</span><span class="sxs-lookup"><span data-stu-id="d8a71-283">A reference type is a class type, an interface type, an array type, or a delegate type.</span></span>

```antlr
reference_type
    : class_type
    | interface_type
    | array_type
    | delegate_type
    ;

class_type
    : type_name
    | 'object'
    | 'dynamic'
    | 'string'
    ;

interface_type
    : type_name
    ;

array_type
    : non_array_type rank_specifier+
    ;

non_array_type
    : type
    ;

rank_specifier
    : '[' dim_separator* ']'
    ;

dim_separator
    : ','
    ;

delegate_type
    : type_name
    ;
```

<span data-ttu-id="d8a71-284">Un valore di tipo riferimento è un riferimento a un ***istanza*** del tipo, nota come un' ***oggetto***.</span><span class="sxs-lookup"><span data-stu-id="d8a71-284">A reference type value is a reference to an ***instance*** of the type, the latter known as an ***object***.</span></span> <span data-ttu-id="d8a71-285">Il valore speciale `null` è compatibile con tutti i tipi riferimento e indica l'assenza di un'istanza.</span><span class="sxs-lookup"><span data-stu-id="d8a71-285">The special value `null` is compatible with all reference types and indicates the absence of an instance.</span></span>

### <a name="class-types"></a><span data-ttu-id="d8a71-286">Tipi classe</span><span class="sxs-lookup"><span data-stu-id="d8a71-286">Class types</span></span>

<span data-ttu-id="d8a71-287">Un tipo di classe definisce una struttura di dati che contiene i membri dati costanti e i campi, membri funzione (metodi, proprietà, eventi, indicizzatori, operatori, costruttori di istanze, distruttori e i costruttori statici) e i tipi annidati.</span><span class="sxs-lookup"><span data-stu-id="d8a71-287">A class type defines a data structure that contains data members (constants and fields), function members (methods, properties, events, indexers, operators, instance constructors, destructors and static constructors), and nested types.</span></span> <span data-ttu-id="d8a71-288">I tipi classe supportano l'ereditarietà, un meccanismo in base al quale le classi derivate possono estendere e specializzare le classi di base.</span><span class="sxs-lookup"><span data-stu-id="d8a71-288">Class types support inheritance, a mechanism whereby derived classes can extend and specialize base classes.</span></span> <span data-ttu-id="d8a71-289">Le istanze di tipi di classe vengono create utilizzando *object_creation_expression*s ([espressioni per la creazione dell'oggetto](expressions.md#object-creation-expressions)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-289">Instances of class types are created using *object_creation_expression*s ([Object creation expressions](expressions.md#object-creation-expressions)).</span></span>

<span data-ttu-id="d8a71-290">Tipi di classe sono descritte nel [classi](classes.md).</span><span class="sxs-lookup"><span data-stu-id="d8a71-290">Class types are described in [Classes](classes.md).</span></span>

<span data-ttu-id="d8a71-291">Alcuni tipi di classe predefiniti hanno un significato speciale in c#, come descritto nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="d8a71-291">Certain predefined class types have special meaning in the C# language, as described in the table below.</span></span>


| <span data-ttu-id="d8a71-292">__Tipo di classe__</span><span class="sxs-lookup"><span data-stu-id="d8a71-292">__Class type__</span></span>     | <span data-ttu-id="d8a71-293">__Descrizione__</span><span class="sxs-lookup"><span data-stu-id="d8a71-293">__Description__</span></span>                                         |
|--------------------|---------------------------------------------------------|
| `System.Object`    | <span data-ttu-id="d8a71-294">La classe di base fondamentale di tutti gli altri tipi.</span><span class="sxs-lookup"><span data-stu-id="d8a71-294">The ultimate base class of all other types.</span></span> <span data-ttu-id="d8a71-295">Visualizzare [il tipo di oggetto](types.md#the-object-type).</span><span class="sxs-lookup"><span data-stu-id="d8a71-295">See [The object type](types.md#the-object-type).</span></span> | 
| `System.String`    | <span data-ttu-id="d8a71-296">Il tipo di stringa del linguaggio c#.</span><span class="sxs-lookup"><span data-stu-id="d8a71-296">The string type of the C# language.</span></span> <span data-ttu-id="d8a71-297">Visualizzare [il tipo di stringa](types.md#the-string-type).</span><span class="sxs-lookup"><span data-stu-id="d8a71-297">See [The string type](types.md#the-string-type).</span></span>         |
| `System.ValueType` | <span data-ttu-id="d8a71-298">Classe di base di tutti i tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="d8a71-298">The base class of all value types.</span></span> <span data-ttu-id="d8a71-299">Visualizzare [System. ValueType di tipo](types.md#the-systemvaluetype-type).</span><span class="sxs-lookup"><span data-stu-id="d8a71-299">See [The System.ValueType type](types.md#the-systemvaluetype-type).</span></span>          |
| `System.Enum`      | <span data-ttu-id="d8a71-300">Classe di base di tutti i tipi di enumerazione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-300">The base class of all enum types.</span></span> <span data-ttu-id="d8a71-301">Visualizzare [enumerazioni](enums.md).</span><span class="sxs-lookup"><span data-stu-id="d8a71-301">See [Enums](enums.md).</span></span>              |
| `System.Array`     | <span data-ttu-id="d8a71-302">Classe di base di tutti i tipi di matrice.</span><span class="sxs-lookup"><span data-stu-id="d8a71-302">The base class of all array types.</span></span> <span data-ttu-id="d8a71-303">Vdere [Matrici](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="d8a71-303">See [Arrays](arrays.md).</span></span>             |
| `System.Delegate`  | <span data-ttu-id="d8a71-304">Classe di base di tutti i tipi di delegato.</span><span class="sxs-lookup"><span data-stu-id="d8a71-304">The base class of all delegate types.</span></span> <span data-ttu-id="d8a71-305">Visualizzare [delegati](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="d8a71-305">See [Delegates](delegates.md).</span></span>          |
| `System.Exception` | <span data-ttu-id="d8a71-306">Classe di base di tutti i tipi di eccezione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-306">The base class of all exception types.</span></span> <span data-ttu-id="d8a71-307">Visualizzare [eccezioni](exceptions.md).</span><span class="sxs-lookup"><span data-stu-id="d8a71-307">See [Exceptions](exceptions.md).</span></span>         |

### <a name="the-object-type"></a><span data-ttu-id="d8a71-308">Il tipo di oggetto</span><span class="sxs-lookup"><span data-stu-id="d8a71-308">The object type</span></span>

<span data-ttu-id="d8a71-309">Il `object` il tipo di classe è la classe di base fondamentale di tutti gli altri tipi.</span><span class="sxs-lookup"><span data-stu-id="d8a71-309">The `object` class type is the ultimate base class of all other types.</span></span> <span data-ttu-id="d8a71-310">In c# ogni tipo deriva direttamente o indirettamente dal `object` tipo di classe.</span><span class="sxs-lookup"><span data-stu-id="d8a71-310">Every type in C# directly or indirectly derives from the `object` class type.</span></span>

<span data-ttu-id="d8a71-311">La parola chiave `object` è semplicemente un alias per la classe predefinita `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-311">The keyword `object` is simply an alias for the predefined class `System.Object`.</span></span>

### <a name="the-dynamic-type"></a><span data-ttu-id="d8a71-312">Il tipo dinamico</span><span class="sxs-lookup"><span data-stu-id="d8a71-312">The dynamic type</span></span>

<span data-ttu-id="d8a71-313">Il `dynamic` digitare, ad esempio `object`, può fare riferimento a qualsiasi oggetto.</span><span class="sxs-lookup"><span data-stu-id="d8a71-313">The `dynamic` type, like `object`, can reference any object.</span></span> <span data-ttu-id="d8a71-314">Quando gli operatori vengono applicati alle espressioni di tipo `dynamic`, le relative soluzioni viene posticipata fino a quando non viene eseguito il programma.</span><span class="sxs-lookup"><span data-stu-id="d8a71-314">When operators are applied to expressions of type `dynamic`, their resolution is deferred until the program is run.</span></span> <span data-ttu-id="d8a71-315">Di conseguenza, se l'operatore non può essere legalmente applicato all'oggetto di riferimento, viene restituito alcun errore durante la compilazione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-315">Thus, if the operator cannot legally be applied to the referenced object, no error is given during compilation.</span></span> <span data-ttu-id="d8a71-316">Al contrario verrà generata un'eccezione durante la risoluzione dell'operatore non riesce in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-316">Instead an exception will be thrown when resolution of the operator fails at run-time.</span></span>

<span data-ttu-id="d8a71-317">Il suo scopo è consentire l'associazione dinamica, descritto dettagliatamente nelle [binding dinamico](expressions.md#dynamic-binding).</span><span class="sxs-lookup"><span data-stu-id="d8a71-317">Its purpose is to allow dynamic binding, which is described in detail in [Dynamic binding](expressions.md#dynamic-binding).</span></span>

<span data-ttu-id="d8a71-318">`dynamic` è considerato identico al `object` tranne che per i seguenti aspetti:</span><span class="sxs-lookup"><span data-stu-id="d8a71-318">`dynamic` is considered identical to `object` except in the following respects:</span></span>

*  <span data-ttu-id="d8a71-319">Operazioni su espressioni di tipo `dynamic` può essere associato in modo dinamico ([binding dinamico](expressions.md#dynamic-binding)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-319">Operations on expressions of type `dynamic` can be dynamically bound ([Dynamic binding](expressions.md#dynamic-binding)).</span></span>
*  <span data-ttu-id="d8a71-320">L'inferenza del tipo ([inferenza del tipo](expressions.md#type-inference)) preferiranno `dynamic` failover `object` se entrambi sono candidati.</span><span class="sxs-lookup"><span data-stu-id="d8a71-320">Type inference ([Type inference](expressions.md#type-inference)) will prefer `dynamic` over `object` if both are candidates.</span></span>

<span data-ttu-id="d8a71-321">A causa di questa equivalenza, tenere presente quanto segue:</span><span class="sxs-lookup"><span data-stu-id="d8a71-321">Because of this equivalence, the following holds:</span></span>

*  <span data-ttu-id="d8a71-322">È una conversione di identità implicite tra `object` e `dynamic`e tra tipi costruiti che sono gli stessi quando si sostituiscono `dynamic` con `object`</span><span class="sxs-lookup"><span data-stu-id="d8a71-322">There is an implicit identity conversion between `object` and `dynamic`, and between constructed types that are the same when replacing `dynamic` with `object`</span></span>
*  <span data-ttu-id="d8a71-323">Le conversioni implicite ed esplicite da e verso `object` si applicano anche a e da `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-323">Implicit and explicit conversions to and from `object` also apply to and from `dynamic`.</span></span>
*  <span data-ttu-id="d8a71-324">Firme del metodo che sono gli stessi quando si sostituiscono `dynamic` con `object` sono considerate la stessa firma</span><span class="sxs-lookup"><span data-stu-id="d8a71-324">Method signatures that are the same when replacing `dynamic` with `object` are considered the same signature</span></span>
*  <span data-ttu-id="d8a71-325">Il tipo `dynamic` non è distinguibile da `object` in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-325">The type `dynamic` is indistinguishable from `object` at run-time.</span></span>
*  <span data-ttu-id="d8a71-326">Un'espressione di tipo `dynamic` viene definito un ***espressione dinamica***.</span><span class="sxs-lookup"><span data-stu-id="d8a71-326">An expression of the type `dynamic` is referred to as a ***dynamic expression***.</span></span>

### <a name="the-string-type"></a><span data-ttu-id="d8a71-327">Il tipo di stringa</span><span class="sxs-lookup"><span data-stu-id="d8a71-327">The string type</span></span>

<span data-ttu-id="d8a71-328">Il `string` tipo è un tipo di classe sealed che eredita direttamente da `object`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-328">The `string` type is a sealed class type that inherits directly from `object`.</span></span> <span data-ttu-id="d8a71-329">Le istanze del `string` classe rappresentano stringhe di caratteri Unicode.</span><span class="sxs-lookup"><span data-stu-id="d8a71-329">Instances of the `string` class represent Unicode character strings.</span></span>

<span data-ttu-id="d8a71-330">I valori del `string` tipo può essere scritte come valori letterali stringa ([valori letterali stringa](lexical-structure.md#string-literals)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-330">Values of the `string` type can be written as string literals ([String literals](lexical-structure.md#string-literals)).</span></span>

<span data-ttu-id="d8a71-331">La parola chiave `string` è semplicemente un alias per la classe predefinita `System.String`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-331">The keyword `string` is simply an alias for the predefined class `System.String`.</span></span>

### <a name="interface-types"></a><span data-ttu-id="d8a71-332">Tipi interfaccia</span><span class="sxs-lookup"><span data-stu-id="d8a71-332">Interface types</span></span>

<span data-ttu-id="d8a71-333">Un'interfaccia definisce un contratto.</span><span class="sxs-lookup"><span data-stu-id="d8a71-333">An interface defines a contract.</span></span> <span data-ttu-id="d8a71-334">Una classe o struct che implementa un'interfaccia deve aderire al rispettivo contratto.</span><span class="sxs-lookup"><span data-stu-id="d8a71-334">A class or struct that implements an interface must adhere to its contract.</span></span> <span data-ttu-id="d8a71-335">Un'interfaccia può ereditare da più interfacce di base e una classe o struct può implementare più interfacce.</span><span class="sxs-lookup"><span data-stu-id="d8a71-335">An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.</span></span>

<span data-ttu-id="d8a71-336">Tipi di interfaccia sono descritte nel [interfacce](interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="d8a71-336">Interface types are described in [Interfaces](interfaces.md).</span></span>

### <a name="array-types"></a><span data-ttu-id="d8a71-337">Tipi matrice</span><span class="sxs-lookup"><span data-stu-id="d8a71-337">Array types</span></span>

<span data-ttu-id="d8a71-338">Una matrice è una struttura di dati che contiene zero o più variabili accessibili tramite indici calcolati.</span><span class="sxs-lookup"><span data-stu-id="d8a71-338">An array is a data structure that contains zero or more variables which are accessed through computed indices.</span></span> <span data-ttu-id="d8a71-339">Le variabili contenute in una matrice, chiamata anche gli elementi della matrice, sono tutti dello stesso tipo, e questo tipo viene definito il tipo di elemento della matrice.</span><span class="sxs-lookup"><span data-stu-id="d8a71-339">The variables contained in an array, also called the elements of the array, are all of the same type, and this type is called the element type of the array.</span></span>

<span data-ttu-id="d8a71-340">I tipi matrice sono descritte nel [matrici](arrays.md).</span><span class="sxs-lookup"><span data-stu-id="d8a71-340">Array types are described in [Arrays](arrays.md).</span></span>

### <a name="delegate-types"></a><span data-ttu-id="d8a71-341">Tipi delegato</span><span class="sxs-lookup"><span data-stu-id="d8a71-341">Delegate types</span></span>

<span data-ttu-id="d8a71-342">Un delegato è una struttura di dati che fa riferimento a uno o più metodi.</span><span class="sxs-lookup"><span data-stu-id="d8a71-342">A delegate is a data structure that refers to one or more methods.</span></span> <span data-ttu-id="d8a71-343">Ad esempio metodi, si intende anche istanze degli oggetti corrispondenti.</span><span class="sxs-lookup"><span data-stu-id="d8a71-343">For instance methods, it also refers to their corresponding object instances.</span></span>

<span data-ttu-id="d8a71-344">L'equivalente più vicino di un delegato in C o C++ è un puntatore a funzione, ma mentre un puntatore a funzione può fare riferimento solo a funzioni statiche, un delegato può fare riferimento sia statici e metodi di istanza.</span><span class="sxs-lookup"><span data-stu-id="d8a71-344">The closest equivalent of a delegate in C or C++ is a function pointer, but whereas a function pointer can only reference static functions, a delegate can reference both static and instance methods.</span></span> <span data-ttu-id="d8a71-345">Nel secondo caso, il delegato archivia non solo un riferimento al punto di ingresso del metodo, ma anche un riferimento all'istanza dell'oggetto sul quale richiamare il metodo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-345">In the latter case, the delegate stores not only a reference to the method's entry point, but also a reference to the object instance on which to invoke the method.</span></span>

<span data-ttu-id="d8a71-346">I tipi delegati sono descritte nel [delegati](delegates.md).</span><span class="sxs-lookup"><span data-stu-id="d8a71-346">Delegate types are described in [Delegates](delegates.md).</span></span>

## <a name="boxing-and-unboxing"></a><span data-ttu-id="d8a71-347">Boxing e unboxing</span><span class="sxs-lookup"><span data-stu-id="d8a71-347">Boxing and unboxing</span></span>

<span data-ttu-id="d8a71-348">Il concetto di conversione boxing e unboxing è fondamentale per il C#del sistema di tipi.</span><span class="sxs-lookup"><span data-stu-id="d8a71-348">The concept of boxing and unboxing is central to C#'s type system.</span></span> <span data-ttu-id="d8a71-349">Fornisce un collegamento tra *value_type*s e *reference_type*s consentono qualsiasi valore di una *value_type* da convertire in e dal tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-349">It provides a bridge between *value_type*s and *reference_type*s by permitting any value of a *value_type* to be converted to and from type `object`.</span></span> <span data-ttu-id="d8a71-350">Boxing e unboxing consente una visualizzazione unificata del sistema di tipi in cui un valore di qualsiasi tipo può essere considerato in definitiva come oggetto.</span><span class="sxs-lookup"><span data-stu-id="d8a71-350">Boxing and unboxing enables a unified view of the type system wherein a value of any type can ultimately be treated as an object.</span></span>

### <a name="boxing-conversions"></a><span data-ttu-id="d8a71-351">Conversioni boxing</span><span class="sxs-lookup"><span data-stu-id="d8a71-351">Boxing conversions</span></span>

<span data-ttu-id="d8a71-352">Una conversione boxing consente una *value_type* da convertire in modo implicito in un *reference_type*.</span><span class="sxs-lookup"><span data-stu-id="d8a71-352">A boxing conversion permits a *value_type* to be implicitly converted to a *reference_type*.</span></span> <span data-ttu-id="d8a71-353">Sono disponibili le conversioni boxing seguenti:</span><span class="sxs-lookup"><span data-stu-id="d8a71-353">The following boxing conversions exist:</span></span>

*  <span data-ttu-id="d8a71-354">Da qualsiasi *value_type* al tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-354">From any *value_type* to the type `object`.</span></span>
*  <span data-ttu-id="d8a71-355">Da qualsiasi *value_type* al tipo `System.ValueType`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-355">From any *value_type* to the type `System.ValueType`.</span></span>
*  <span data-ttu-id="d8a71-356">Da qualsiasi *non_nullable_value_type* a qualsiasi *interface_type* implementata dal *value_type*.</span><span class="sxs-lookup"><span data-stu-id="d8a71-356">From any *non_nullable_value_type* to any *interface_type* implemented by the *value_type*.</span></span>
*  <span data-ttu-id="d8a71-357">Da qualsiasi *nullable_type* a qualsiasi *interface_type* implementate dal tipo sottostante del *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="d8a71-357">From any *nullable_type* to any *interface_type* implemented by the underlying type of the *nullable_type*.</span></span>
*  <span data-ttu-id="d8a71-358">Da qualsiasi *enum_type* al tipo `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-358">From any *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="d8a71-359">Da qualsiasi *nullable_type* con un oggetto sottostante *enum_type* al tipo `System.Enum`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-359">From any *nullable_type* with an underlying *enum_type* to the type `System.Enum`.</span></span>
*  <span data-ttu-id="d8a71-360">Notare che verrà eseguita una conversione implicita da un parametro di tipo come conversione boxing se in fase di esecuzione viene eseguita la conversione da un tipo di valore a un tipo riferimento ([conversioni implicite con i parametri di tipo](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-360">Note that an implicit conversion from a type parameter will be executed as a boxing conversion if at run-time it ends up converting from a value type to a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span>

<span data-ttu-id="d8a71-361">Conversione boxing di un valore di una *non_nullable_value_type* consiste nell'allocare un'istanza dell'oggetto e copia le *non_nullable_value_type* valore in tale istanza.</span><span class="sxs-lookup"><span data-stu-id="d8a71-361">Boxing a value of a *non_nullable_value_type* consists of allocating an object instance and copying the *non_nullable_value_type* value into that instance.</span></span>

<span data-ttu-id="d8a71-362">Conversione boxing di un valore di una *nullable_type* produce un riferimento null se è la `null` valore (`HasValue` è `false`), o il risultato dell'annullamento del wrapping e conversione boxing in caso contrario, il valore sottostante.</span><span class="sxs-lookup"><span data-stu-id="d8a71-362">Boxing a value of a *nullable_type* produces a null reference if it is the `null` value (`HasValue` is `false`), or the result of unwrapping and boxing the underlying value otherwise.</span></span>

<span data-ttu-id="d8a71-363">L'effettivo processo di conversione boxing di un valore di una *non_nullable_value_type* è la risposta è chiarita immaginando l'esistenza di un oggetto generico ***classe boxing***, che si comporta come se fosse dichiarato come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="d8a71-363">The actual process of boxing a value of a *non_nullable_value_type* is best explained by imagining the existence of a generic ***boxing class***, which behaves as if it were declared as follows:</span></span>

```csharp
sealed class Box<T>: System.ValueType
{
    T value;

    public Box(T t) {
        value = t;
    }
}
```

<span data-ttu-id="d8a71-364">Conversione boxing di un valore `v` typu `T` ora è costituito da esegue l'espressione `new Box<T>(v)`e restituendo l'istanza risultante come un valore di tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-364">Boxing of a value `v` of type `T` now consists of executing the expression `new Box<T>(v)`, and returning the resulting instance as a value of type `object`.</span></span> <span data-ttu-id="d8a71-365">Di conseguenza, le istruzioni</span><span class="sxs-lookup"><span data-stu-id="d8a71-365">Thus, the statements</span></span>
```csharp
int i = 123;
object box = i;
```
<span data-ttu-id="d8a71-366">a livello concettuale corrispondono alle</span><span class="sxs-lookup"><span data-stu-id="d8a71-366">conceptually correspond to</span></span>
```csharp
int i = 123;
object box = new Box<int>(i);
```

<span data-ttu-id="d8a71-367">Una classe di conversione boxing, ad esempio `Box<T>` sopra in realtà non esiste e il tipo dinamico di un valore boxed non è effettivamente un tipo di classe.</span><span class="sxs-lookup"><span data-stu-id="d8a71-367">A boxing class like `Box<T>` above doesn't actually exist and the dynamic type of a boxed value isn't actually a class type.</span></span> <span data-ttu-id="d8a71-368">Al contrario, valore boxed del tipo `T` ha il tipo dinamico `T`e un controllo di tipo dinamico mediante il `is` operatore può semplicemente fare riferimento a tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-368">Instead, a boxed value of type `T` has the dynamic type `T`, and a dynamic type check using the `is` operator can simply reference type `T`.</span></span> <span data-ttu-id="d8a71-369">Ad esempio,</span><span class="sxs-lookup"><span data-stu-id="d8a71-369">For example,</span></span>
```csharp
int i = 123;
object box = i;
if (box is int) {
    Console.Write("Box contains an int");
}
```
<span data-ttu-id="d8a71-370">restituirà la stringa "`Box contains an int`" nella console.</span><span class="sxs-lookup"><span data-stu-id="d8a71-370">will output the string "`Box contains an int`" on the console.</span></span>

<span data-ttu-id="d8a71-371">Conversione boxing implica la copia del valore da convertire.</span><span class="sxs-lookup"><span data-stu-id="d8a71-371">A boxing conversion implies making a copy of the value being boxed.</span></span> <span data-ttu-id="d8a71-372">Questo comportamento è diverso rispetto alla conversione di un *reference_type* al tipo `object`, in cui il valore continua a fare riferimento alla stessa istanza e viene considerato solo come tipo meno derivato `object`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-372">This is different from a conversion of a *reference_type* to type `object`, in which the value continues to reference the same instance and simply is regarded as the less derived type `object`.</span></span> <span data-ttu-id="d8a71-373">Ad esempio, considerando la dichiarazione</span><span class="sxs-lookup"><span data-stu-id="d8a71-373">For example, given the declaration</span></span>
```csharp
struct Point
{
    public int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```
<span data-ttu-id="d8a71-374">le istruzioni seguenti</span><span class="sxs-lookup"><span data-stu-id="d8a71-374">the following statements</span></span>
```csharp
Point p = new Point(10, 10);
object box = p;
p.x = 20;
Console.Write(((Point)box).x);
```
<span data-ttu-id="d8a71-375">restituirà il valore 10 nella console perché l'operazione di conversione boxing implicita che si verifica l'assegnazione di `p` al `box` fa sì che il valore di `p` da copiare.</span><span class="sxs-lookup"><span data-stu-id="d8a71-375">will output the value 10 on the console because the implicit boxing operation that occurs in the assignment of `p` to `box` causes the value of `p` to be copied.</span></span> <span data-ttu-id="d8a71-376">Aveva `Point` stato dichiarato un `class` invece il valore 20 sarebbe output poiché `p` e `box` fa riferimento alla stessa istanza.</span><span class="sxs-lookup"><span data-stu-id="d8a71-376">Had `Point` been declared a `class` instead, the value 20 would be output because `p` and `box` would reference the same instance.</span></span>

### <a name="unboxing-conversions"></a><span data-ttu-id="d8a71-377">Conversione unboxing</span><span class="sxs-lookup"><span data-stu-id="d8a71-377">Unboxing conversions</span></span>

<span data-ttu-id="d8a71-378">Una conversione unboxing consente una *reference_type* da convertire in modo esplicito in un *value_type*.</span><span class="sxs-lookup"><span data-stu-id="d8a71-378">An unboxing conversion permits a *reference_type* to be explicitly converted to a *value_type*.</span></span> <span data-ttu-id="d8a71-379">Sono disponibili le seguenti conversioni unboxing:</span><span class="sxs-lookup"><span data-stu-id="d8a71-379">The following unboxing conversions exist:</span></span>

*  <span data-ttu-id="d8a71-380">Dal tipo `object` a qualsiasi *value_type*.</span><span class="sxs-lookup"><span data-stu-id="d8a71-380">From the type `object` to any *value_type*.</span></span>
*  <span data-ttu-id="d8a71-381">Dal tipo `System.ValueType` a qualsiasi *value_type*.</span><span class="sxs-lookup"><span data-stu-id="d8a71-381">From the type `System.ValueType` to any *value_type*.</span></span>
*  <span data-ttu-id="d8a71-382">Da qualsiasi *interface_type* a qualsiasi *non_nullable_value_type* che implementa il *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="d8a71-382">From any *interface_type* to any *non_nullable_value_type* that implements the *interface_type*.</span></span>
*  <span data-ttu-id="d8a71-383">Da qualsiasi *interface_type* a qualsiasi *nullable_type* il cui tipo sottostante implementa il *interface_type*.</span><span class="sxs-lookup"><span data-stu-id="d8a71-383">From any *interface_type* to any *nullable_type* whose underlying type implements the *interface_type*.</span></span>
*  <span data-ttu-id="d8a71-384">Dal tipo `System.Enum` a qualsiasi *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="d8a71-384">From the type `System.Enum` to any *enum_type*.</span></span>
*  <span data-ttu-id="d8a71-385">Dal tipo `System.Enum` a qualsiasi *nullable_type* con un oggetto sottostante *enum_type*.</span><span class="sxs-lookup"><span data-stu-id="d8a71-385">From the type `System.Enum` to any *nullable_type* with an underlying *enum_type*.</span></span>
*  <span data-ttu-id="d8a71-386">Notare che verrà eseguita una conversione esplicita di un parametro di tipo come una conversione unboxing se in fase di esecuzione viene eseguita la conversione da un tipo riferimento a un tipo valore ([conversioni esplicite dinamiche](conversions.md#explicit-dynamic-conversions)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-386">Note that an explicit conversion to a type parameter will be executed as an unboxing conversion if at run-time it ends up converting from a reference type to a value type ([Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions)).</span></span>

<span data-ttu-id="d8a71-387">Un'operazione di unboxing un *non_nullable_value_type* è costituito da verificare prima che l'istanza dell'oggetto è un valore boxed del determinato *non_nullable_value_type*e quindi copiando il valore fuori il istanza.</span><span class="sxs-lookup"><span data-stu-id="d8a71-387">An unboxing operation to a *non_nullable_value_type* consists of first checking that the object instance is a boxed value of the given *non_nullable_value_type*, and then copying the value out of the instance.</span></span>

<span data-ttu-id="d8a71-388">Conversione unboxing di un *nullable_type* produce il valore null delle *nullable_type* se l'operando di origine è `null`, o il risultato con wrapping di unboxing l'istanza dell'oggetto per il tipo sottostante del *nullable_type* in caso contrario.</span><span class="sxs-lookup"><span data-stu-id="d8a71-388">Unboxing to a *nullable_type* produces the null value of the *nullable_type* if the source operand is `null`, or the wrapped result of unboxing the object instance to the underlying type of the *nullable_type* otherwise.</span></span>

<span data-ttu-id="d8a71-389">Che fa riferimento alla classe di conversione boxing immaginaria descritta nella sezione precedente, una conversione unboxing di un oggetto `box` a un *value_type* `T` corrisponde all'esecuzione dell'espressione `((Box<T>)box).value`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-389">Referring to the imaginary boxing class described in the previous section, an unboxing conversion of an object `box` to a *value_type* `T` consists of executing the expression `((Box<T>)box).value`.</span></span> <span data-ttu-id="d8a71-390">Di conseguenza, le istruzioni</span><span class="sxs-lookup"><span data-stu-id="d8a71-390">Thus, the statements</span></span>
```csharp
object box = 123;
int i = (int)box;
```
<span data-ttu-id="d8a71-391">a livello concettuale corrispondono alle</span><span class="sxs-lookup"><span data-stu-id="d8a71-391">conceptually correspond to</span></span>
```csharp
object box = new Box<int>(123);
int i = ((Box<int>)box).value;
```

<span data-ttu-id="d8a71-392">Per una conversione unboxing di un determinato *non_nullable_value_type* per la corretta in fase di esecuzione, il valore dell'operando di origine deve essere un riferimento a un valore boxed di tale *non_nullable_value_type*.</span><span class="sxs-lookup"><span data-stu-id="d8a71-392">For an unboxing conversion to a given *non_nullable_value_type* to succeed at run-time, the value of the source operand must be a reference to a boxed value of that *non_nullable_value_type*.</span></span> <span data-ttu-id="d8a71-393">Se l'operando di origine è `null`, un `System.NullReferenceException` viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-393">If the source operand is `null`, a `System.NullReferenceException` is thrown.</span></span> <span data-ttu-id="d8a71-394">Se l'operando di origine è un riferimento a un oggetto incompatibile, un `System.InvalidCastException` viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-394">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

<span data-ttu-id="d8a71-395">Per una conversione unboxing di un determinato *nullable_type* per la corretta in fase di esecuzione, il valore dell'operando di origine deve essere `null` o un riferimento a un valore boxed dell'oggetto sottostante *non_nullable_value_type* del *nullable_type*.</span><span class="sxs-lookup"><span data-stu-id="d8a71-395">For an unboxing conversion to a given *nullable_type* to succeed at run-time, the value of the source operand must be either `null` or a reference to a boxed value of the underlying *non_nullable_value_type* of the *nullable_type*.</span></span> <span data-ttu-id="d8a71-396">Se l'operando di origine è un riferimento a un oggetto incompatibile, un `System.InvalidCastException` viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-396">If the source operand is a reference to an incompatible object, a `System.InvalidCastException` is thrown.</span></span>

## <a name="constructed-types"></a><span data-ttu-id="d8a71-397">Tipi costruiti</span><span class="sxs-lookup"><span data-stu-id="d8a71-397">Constructed types</span></span>

<span data-ttu-id="d8a71-398">Una dichiarazione di tipo generico, di per sé, denota un ***annullare l'associazione di tipo generico*** che viene utilizzato come un' "istantanea" in modo da formare vari tipi differenti, applicando ***gli argomenti di tipo***.</span><span class="sxs-lookup"><span data-stu-id="d8a71-398">A generic type declaration, by itself, denotes an ***unbound generic type*** that is used as a "blueprint" to form many different types, by way of applying ***type arguments***.</span></span> <span data-ttu-id="d8a71-399">Gli argomenti di tipo vengono scritti tra parentesi angolari (`<` e `>`) subito dopo il nome del tipo generico.</span><span class="sxs-lookup"><span data-stu-id="d8a71-399">The type arguments are written within angle brackets (`<` and `>`) immediately following the name of the generic type.</span></span> <span data-ttu-id="d8a71-400">Un tipo che include almeno un argomento di tipo viene chiamato un ***tipo costruito***.</span><span class="sxs-lookup"><span data-stu-id="d8a71-400">A type that includes at least one type argument is called a ***constructed type***.</span></span> <span data-ttu-id="d8a71-401">Un tipo costruito è utilizzabile nella maggior parte delle posizioni nel linguaggio in cui può essere visualizzato un nome di tipo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-401">A constructed type can be used in most places in the language in which a type name can appear.</span></span> <span data-ttu-id="d8a71-402">Un tipo generico non associato può essere usato solo all'interno di un *typeof_expression* ([l'operatore typeof](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-402">An unbound generic type can only be used within a *typeof_expression* ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

<span data-ttu-id="d8a71-403">Tipi costruiti possono anche essere utilizzati nelle espressioni come nomi semplici ([nomi semplici](expressions.md#simple-names)) o quando si accede a un membro ([l'accesso ai membri](expressions.md#member-access)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-403">Constructed types can also be used in expressions as simple names ([Simple names](expressions.md#simple-names)) or when accessing a member ([Member access](expressions.md#member-access)).</span></span>

<span data-ttu-id="d8a71-404">Quando un *namespace_or_type_name* viene valutati, solo i tipi generici con il numero corretto di parametri sono considerati di tipo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-404">When a *namespace_or_type_name* is evaluated, only generic types with the correct number of type parameters are considered.</span></span> <span data-ttu-id="d8a71-405">Di conseguenza, è possibile usare lo stesso identificatore per identificare i tipi diversi, purché i tipi hanno diversi numeri di parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-405">Thus, it is possible to use the same identifier to identify different types, as long as the types have different numbers of type parameters.</span></span> <span data-ttu-id="d8a71-406">Ciò è utile quando si combinano le classi generiche e non generici nello stesso programma:</span><span class="sxs-lookup"><span data-stu-id="d8a71-406">This is useful when mixing generic and non-generic classes in the same program:</span></span>

```csharp
namespace Widgets
{
    class Queue {...}
    class Queue<TElement> {...}
}

namespace MyApplication
{
    using Widgets;

    class X
    {
        Queue q1;            // Non-generic Widgets.Queue
        Queue<int> q2;       // Generic Widgets.Queue
    }
}
```

<span data-ttu-id="d8a71-407">Oggetto *type_name* può identificare un tipo costruito, anche se non specifica i parametri di tipo direttamente.</span><span class="sxs-lookup"><span data-stu-id="d8a71-407">A *type_name* might identify a constructed type even though it doesn't specify type parameters directly.</span></span> <span data-ttu-id="d8a71-408">Ciò può verificarsi in cui un tipo annidato all'interno di una dichiarazione di classe generica, e il tipo di istanza di dichiarazione che lo contiene è implicitamente per la ricerca del nome ([annidati di tipi in classi generiche](classes.md#nested-types-in-generic-classes)):</span><span class="sxs-lookup"><span data-stu-id="d8a71-408">This can occur where a type is nested within a generic class declaration, and the instance type of the containing declaration is implicitly used for name lookup ([Nested types in generic classes](classes.md#nested-types-in-generic-classes)):</span></span>

```csharp
class Outer<T>
{
    public class Inner {...}

    public Inner i;                // Type of i is Outer<T>.Inner
}
```

<span data-ttu-id="d8a71-409">Nel codice unsafe, un tipo costruito non può essere utilizzato come un *unmanaged_type* ([tipi di puntatore](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-409">In unsafe code, a constructed type cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

### <a name="type-arguments"></a><span data-ttu-id="d8a71-410">Argomenti di tipo</span><span class="sxs-lookup"><span data-stu-id="d8a71-410">Type arguments</span></span>

<span data-ttu-id="d8a71-411">Ciascun argomento in un elenco di argomenti è semplicemente una *tipo*.</span><span class="sxs-lookup"><span data-stu-id="d8a71-411">Each argument in a type argument list is simply a *type*.</span></span>

```antlr
type_argument_list
    : '<' type_arguments '>'
    ;

type_arguments
    : type_argument (',' type_argument)*
    ;

type_argument
    : type
    ;
```

<span data-ttu-id="d8a71-412">Nel codice non sicuro ([codice Unsafe](unsafe-code.md)), un *type_argument* potrebbe non essere un tipo di puntatore.</span><span class="sxs-lookup"><span data-stu-id="d8a71-412">In unsafe code ([Unsafe code](unsafe-code.md)), a *type_argument* may not be a pointer type.</span></span> <span data-ttu-id="d8a71-413">Ogni argomento tipo deve soddisfare tutti i vincoli nel corrispondente parametro di tipo ([vincoli di parametro di tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-413">Each type argument must satisfy any constraints on the corresponding type parameter ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>

### <a name="open-and-closed-types"></a><span data-ttu-id="d8a71-414">Tipi aperti e chiusi</span><span class="sxs-lookup"><span data-stu-id="d8a71-414">Open and closed types</span></span>

<span data-ttu-id="d8a71-415">Tutti i tipi possono essere classificati come ***tipi aperti*** oppure ***tipi chiusi***.</span><span class="sxs-lookup"><span data-stu-id="d8a71-415">All types can be classified as either ***open types*** or ***closed types***.</span></span> <span data-ttu-id="d8a71-416">Un tipo aperto è un tipo che prevede parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-416">An open type is a type that involves type parameters.</span></span> <span data-ttu-id="d8a71-417">In particolare:</span><span class="sxs-lookup"><span data-stu-id="d8a71-417">More specifically:</span></span>

*  <span data-ttu-id="d8a71-418">Un parametro di tipo definisce un tipo aperto.</span><span class="sxs-lookup"><span data-stu-id="d8a71-418">A type parameter defines an open type.</span></span>
*  <span data-ttu-id="d8a71-419">Un tipo di matrice è un tipo aperto solo se il tipo di elemento è un tipo aperto.</span><span class="sxs-lookup"><span data-stu-id="d8a71-419">An array type is an open type if and only if its element type is an open type.</span></span>
*  <span data-ttu-id="d8a71-420">Un tipo costruito è un tipo aperto solo se uno o più dei relativi argomenti di tipo è un tipo aperto.</span><span class="sxs-lookup"><span data-stu-id="d8a71-420">A constructed type is an open type if and only if one or more of its type arguments is an open type.</span></span> <span data-ttu-id="d8a71-421">Un tipo costruito annidato è un tipo aperto solo se uno o più dei relativi argomenti di tipo o gli argomenti di tipo dei relativi tipi che lo contiene è un tipo aperto.</span><span class="sxs-lookup"><span data-stu-id="d8a71-421">A constructed nested type is an open type if and only if one or more of its type arguments or the type arguments of its containing type(s) is an open type.</span></span>

<span data-ttu-id="d8a71-422">Un tipo chiuso è un tipo che non è un tipo aperto.</span><span class="sxs-lookup"><span data-stu-id="d8a71-422">A closed type is a type that is not an open type.</span></span>

<span data-ttu-id="d8a71-423">In fase di esecuzione, tutto il codice all'interno di una dichiarazione di tipo generico viene eseguita nel contesto di un tipo costruito chiuso che è stato creato applicando gli argomenti tipo per la dichiarazione generica.</span><span class="sxs-lookup"><span data-stu-id="d8a71-423">At run-time, all of the code within a generic type declaration is executed in the context of a closed constructed type that was created by applying type arguments to the generic declaration.</span></span> <span data-ttu-id="d8a71-424">Ogni parametro di tipo all'interno del tipo generico è associato a un determinato tipo in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-424">Each type parameter within the generic type is bound to a particular run-time type.</span></span> <span data-ttu-id="d8a71-425">Si verifica sempre l'elaborazione in fase di esecuzione di tutte le istruzioni e le espressioni con tipi chiusi e i tipi aperti si verificano solo durante la fase di compilazione l'elaborazione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-425">The run-time processing of all statements and expressions always occurs with closed types, and open types occur only during compile-time processing.</span></span>

<span data-ttu-id="d8a71-426">Ogni tipo costruito chiuso ha un proprio set di variabili statiche, che non sono condivise con qualsiasi altro tipo costruito chiuso.</span><span class="sxs-lookup"><span data-stu-id="d8a71-426">Each closed constructed type has its own set of static variables, which are not shared with any other closed constructed types.</span></span> <span data-ttu-id="d8a71-427">Poiché non esiste un tipo aperto in fase di esecuzione, vi sono variabili statiche associate a un tipo aperto.</span><span class="sxs-lookup"><span data-stu-id="d8a71-427">Since an open type does not exist at run-time, there are no static variables associated with an open type.</span></span> <span data-ttu-id="d8a71-428">Due tipi costruiti chiusi sono dello stesso tipo se vengono costruiti dallo stesso tipo generico non associato e relativi argomenti di tipo corrispondenti sono dello stesso tipo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-428">Two closed constructed types are the same type if they are constructed from the same unbound generic type, and their corresponding type arguments are the same type.</span></span>

### <a name="bound-and-unbound-types"></a><span data-ttu-id="d8a71-429">Tipi associati e non associati</span><span class="sxs-lookup"><span data-stu-id="d8a71-429">Bound and unbound types</span></span>

<span data-ttu-id="d8a71-430">Il termine ***annullare l'associazione di tipo*** fa riferimento a un tipo non generico o un tipo generico non associato.</span><span class="sxs-lookup"><span data-stu-id="d8a71-430">The term ***unbound type*** refers to a non-generic type or an unbound generic type.</span></span> <span data-ttu-id="d8a71-431">Il termine ***associata tipo*** fa riferimento a un tipo non generico o un tipo costruito.</span><span class="sxs-lookup"><span data-stu-id="d8a71-431">The term ***bound type*** refers to a non-generic type or a constructed type.</span></span>

<span data-ttu-id="d8a71-432">Un tipo non associato fa riferimento all'entità dichiarato da una dichiarazione del tipo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-432">An unbound type refers to the entity declared by a type declaration.</span></span> <span data-ttu-id="d8a71-433">Un tipo generico non associato non è un tipo e non può essere utilizzato come tipo di variabile, argomento o valore restituito o come un tipo di base.</span><span class="sxs-lookup"><span data-stu-id="d8a71-433">An unbound generic type is not itself a type, and cannot be used as the type of a variable, argument or return value, or as a base type.</span></span> <span data-ttu-id="d8a71-434">Il costrutto solo in cui è possibile fare riferimento un tipo generico non associato è il `typeof` espressione ([l'operatore typeof](expressions.md#the-typeof-operator)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-434">The only construct in which an unbound generic type can be referenced is the `typeof` expression ([The typeof operator](expressions.md#the-typeof-operator)).</span></span>

### <a name="satisfying-constraints"></a><span data-ttu-id="d8a71-435">Rispetto dei vincoli</span><span class="sxs-lookup"><span data-stu-id="d8a71-435">Satisfying constraints</span></span>

<span data-ttu-id="d8a71-436">Ogni volta che un tipo costruito o metodo generico viene fatto riferimento, in base ai vincoli di parametro di tipo dichiarati per il tipo o metodo generico vengono controllati gli argomenti di tipo fornito ([vincoli di parametro di tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-436">Whenever a constructed type or generic method is referenced, the supplied type arguments are checked against the type parameter constraints declared on the generic type or method ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span> <span data-ttu-id="d8a71-437">Per ognuno `where` clausola, l'argomento di tipo `A` che corrisponde al denominato parametro di tipo viene confrontato con ogni vincolo come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="d8a71-437">For each `where` clause, the type argument `A` that corresponds to the named type parameter is checked against each constraint as follows:</span></span>

*  <span data-ttu-id="d8a71-438">Se il vincolo è un parametro di tipo, un tipo di interfaccia o un tipo di classe, lasciar `C` rappresentano che un vincolo con gli argomenti di tipo fornito sostituito per qualsiasi parametro di tipo che vengono visualizzati nel vincolo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-438">If the constraint is a class type, an interface type, or a type parameter, let `C` represent that constraint with the supplied type arguments substituted for any type parameters that appear in the constraint.</span></span> <span data-ttu-id="d8a71-439">Per soddisfare il vincolo, deve essere il caso indipendente dai tipi `A` convertibile nel tipo `C` da uno dei seguenti:</span><span class="sxs-lookup"><span data-stu-id="d8a71-439">To satisfy the constraint, it must be the case that type `A` is convertible to type `C` by one of the following:</span></span>
    * <span data-ttu-id="d8a71-440">Una conversione di identità ([conversione di identità](conversions.md#identity-conversion))</span><span class="sxs-lookup"><span data-stu-id="d8a71-440">An identity conversion ([Identity conversion](conversions.md#identity-conversion))</span></span>
    * <span data-ttu-id="d8a71-441">Una conversione implicita del riferimento ([le conversioni dei riferimenti implicita](conversions.md#implicit-reference-conversions))</span><span class="sxs-lookup"><span data-stu-id="d8a71-441">An implicit reference conversion ([Implicit reference conversions](conversions.md#implicit-reference-conversions))</span></span>
    * <span data-ttu-id="d8a71-442">Conversione boxing ([conversioni Boxing](conversions.md#boxing-conversions)), a condizione che il tipo è un tipo di valore non nullable.</span><span class="sxs-lookup"><span data-stu-id="d8a71-442">A boxing conversion ([Boxing conversions](conversions.md#boxing-conversions)), provided that type A is a non-nullable value type.</span></span>
    * <span data-ttu-id="d8a71-443">Riferimento, la conversione boxing o tipo di parametro conversione implicita da un parametro di tipo `A` a `C`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-443">An implicit reference, boxing or type parameter conversion from a type parameter `A` to `C`.</span></span>
*  <span data-ttu-id="d8a71-444">Se il vincolo è il vincolo di tipo riferimento (`class`), il tipo `A` deve soddisfare uno dei seguenti:</span><span class="sxs-lookup"><span data-stu-id="d8a71-444">If the constraint is the reference type constraint (`class`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="d8a71-445">`A` è un tipo di interfaccia, tipo di classe, tipo di delegato o tipo di matrice.</span><span class="sxs-lookup"><span data-stu-id="d8a71-445">`A` is an interface type, class type, delegate type or array type.</span></span> <span data-ttu-id="d8a71-446">Si noti che `System.ValueType` e `System.Enum` sono tipi di riferimento che soddisfano questo vincolo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-446">Note that `System.ValueType` and `System.Enum` are reference types that satisfy this constraint.</span></span>
    * <span data-ttu-id="d8a71-447">`A` è un parametro di tipo noto per essere un tipo riferimento ([vincoli di parametro di tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-447">`A` is a type parameter that is known to be a reference type ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="d8a71-448">Se il vincolo è il vincolo di tipo valore (`struct`), il tipo `A` deve soddisfare uno dei seguenti:</span><span class="sxs-lookup"><span data-stu-id="d8a71-448">If the constraint is the value type constraint (`struct`), the type `A` must satisfy one of the following:</span></span>
    * <span data-ttu-id="d8a71-449">`A` è un tipo struct o tipo di enumerazione, ma non un tipo nullable.</span><span class="sxs-lookup"><span data-stu-id="d8a71-449">`A` is a struct type or enum type, but not a nullable type.</span></span> <span data-ttu-id="d8a71-450">Si noti che `System.ValueType` e `System.Enum` sono tipi di riferimento che non soddisfano questo vincolo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-450">Note that `System.ValueType` and `System.Enum` are reference types that do not satisfy this constraint.</span></span>
    * <span data-ttu-id="d8a71-451">`A` è un parametro di tipo con il vincolo di tipo valore ([vincoli di parametro di tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-451">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="d8a71-452">Se il vincolo è il vincolo del costruttore `new()`, il tipo `A` non deve essere `abstract` e deve avere un costruttore pubblico senza parametri.</span><span class="sxs-lookup"><span data-stu-id="d8a71-452">If the constraint is the constructor constraint `new()`, the type `A` must not be `abstract` and must have a public parameterless constructor.</span></span> <span data-ttu-id="d8a71-453">Ciò viene soddisfatta se viene soddisfatta una delle operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="d8a71-453">This is satisfied if one of the following is true:</span></span>
    * <span data-ttu-id="d8a71-454">`A` è un tipo di valore, poiché tutti i tipi valore hanno un costruttore pubblico predefinito ([costruttori predefiniti](types.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-454">`A` is a value type, since all value types have a public default constructor ([Default constructors](types.md#default-constructors)).</span></span>
    * <span data-ttu-id="d8a71-455">`A` è un parametro di tipo con il vincolo del costruttore ([vincoli di parametro di tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-455">`A` is a type parameter having the constructor constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="d8a71-456">`A` è un parametro di tipo con il vincolo di tipo valore ([vincoli di parametro di tipo](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-456">`A` is a type parameter having the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
    * <span data-ttu-id="d8a71-457">`A` è una classe che non è `abstract` e contiene un dichiarato in modo esplicito `public` costruttore senza parametri.</span><span class="sxs-lookup"><span data-stu-id="d8a71-457">`A` is a class that is not `abstract` and contains an explicitly declared `public` constructor with no parameters.</span></span>
    * <span data-ttu-id="d8a71-458">`A` non è `abstract` e ha un costruttore predefinito ([costruttori predefiniti](classes.md#default-constructors)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-458">`A` is not `abstract` and has a default constructor ([Default constructors](classes.md#default-constructors)).</span></span>

<span data-ttu-id="d8a71-459">Se uno o più vincoli del parametro di tipo non sono soddisfatte dagli argomenti di tipo specificato, si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-459">A compile-time error occurs if one or more of a type parameter's constraints are not satisfied by the given type arguments.</span></span>

<span data-ttu-id="d8a71-460">Poiché i parametri di tipo non vengono ereditati, i vincoli non sono mai ereditate uno.</span><span class="sxs-lookup"><span data-stu-id="d8a71-460">Since type parameters are not inherited, constraints are never inherited either.</span></span> <span data-ttu-id="d8a71-461">Nell'esempio riportato di seguito `D` deve specificare il vincolo nel parametro di tipo `T` in modo che `T` soddisfa il vincolo imposto dalla classe di base `B<T>`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-461">In the example below, `D` needs to specify the constraint on its type parameter `T` so that `T` satisfies the constraint imposed by the base class `B<T>`.</span></span> <span data-ttu-id="d8a71-462">Classe invece `E` non è necessario specificare un vincolo, in quanto `List<T>` implementa `IEnumerable` per qualsiasi `T`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-462">In contrast, class `E` need not specify a constraint, because `List<T>` implements `IEnumerable` for any `T`.</span></span>

```csharp
class B<T> where T: IEnumerable {...}

class D<T>: B<T> where T: IEnumerable {...}

class E<T>: B<List<T>> {...}
```

## <a name="type-parameters"></a><span data-ttu-id="d8a71-463">Parametri di tipo</span><span class="sxs-lookup"><span data-stu-id="d8a71-463">Type parameters</span></span>

<span data-ttu-id="d8a71-464">Un parametro di tipo è un identificatore che designa un tipo valore o tipo di riferimento che è associato il parametro in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-464">A type parameter is an identifier designating a value type or reference type that the parameter is bound to at run-time.</span></span>

```antlr
type_parameter
    : identifier
    ;
```

<span data-ttu-id="d8a71-465">Poiché è possibile creare istanze di un parametro di tipo con molti argomenti di tipo effettivo diverso, i parametri di tipo sono leggermente diversi di operazioni e le restrizioni rispetto ad altri tipi.</span><span class="sxs-lookup"><span data-stu-id="d8a71-465">Since a type parameter can be instantiated with many different actual type arguments, type parameters have slightly different operations and restrictions than other types.</span></span> <span data-ttu-id="d8a71-466">Sono inclusi:</span><span class="sxs-lookup"><span data-stu-id="d8a71-466">These include:</span></span>

*  <span data-ttu-id="d8a71-467">Un parametro di tipo non può essere utilizzato direttamente per dichiarare una classe di base ([classe di Base](classes.md#base-class)) o l'interfaccia ([elenchi di parametri di tipo variante](interfaces.md#variant-type-parameter-lists)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-467">A type parameter cannot be used directly to declare a base class ([Base class](classes.md#base-class)) or interface ([Variant type parameter lists](interfaces.md#variant-type-parameter-lists)).</span></span>
*  <span data-ttu-id="d8a71-468">Le regole per la ricerca di membri nel tipo di parametri dipendono i vincoli, se presente, applicato al parametro di tipo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-468">The rules for member lookup on type parameters depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="d8a71-469">Sono descritti in dettaglio nelle [ricerca di membri](expressions.md#member-lookup).</span><span class="sxs-lookup"><span data-stu-id="d8a71-469">They are detailed in [Member lookup](expressions.md#member-lookup).</span></span>
*  <span data-ttu-id="d8a71-470">Le conversioni disponibili per un parametro di tipo variano in base ai vincoli, se presente, applicato al parametro di tipo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-470">The available conversions for a type parameter depend on the constraints, if any, applied to the type parameter.</span></span> <span data-ttu-id="d8a71-471">Sono descritti in dettaglio nelle [conversioni implicite con i parametri di tipo](conversions.md#implicit-conversions-involving-type-parameters) e [conversioni esplicite dinamiche](conversions.md#explicit-dynamic-conversions).</span><span class="sxs-lookup"><span data-stu-id="d8a71-471">They are detailed in [Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters) and [Explicit dynamic conversions](conversions.md#explicit-dynamic-conversions).</span></span>
*  <span data-ttu-id="d8a71-472">Il valore letterale `null` non può essere convertito in un tipo specificato da un parametro di tipo, eccetto se il parametro di tipo è noto per essere un tipo riferimento ([conversioni implicite con i parametri di tipo](conversions.md#implicit-conversions-involving-type-parameters)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-472">The literal `null` cannot be converted to a type given by a type parameter, except if the type parameter is known to be a reference type ([Implicit conversions involving type parameters](conversions.md#implicit-conversions-involving-type-parameters)).</span></span> <span data-ttu-id="d8a71-473">Tuttavia, un `default` espressione ([espressioni con valore predefinito](expressions.md#default-value-expressions)) è invece possibile usare.</span><span class="sxs-lookup"><span data-stu-id="d8a71-473">However, a `default` expression ([Default value expressions](expressions.md#default-value-expressions)) can be used instead.</span></span> <span data-ttu-id="d8a71-474">Inoltre, un valore con un tipo specificato da un parametro di tipo può essere confrontato con `null` usando `==` e `!=` ([gli operatori di uguaglianza di riferimenti tipo](expressions.md#reference-type-equality-operators)), a meno che il parametro di tipo contiene il vincolo di tipo valore.</span><span class="sxs-lookup"><span data-stu-id="d8a71-474">In addition, a value with a type given by a type parameter can be compared with `null` using `==` and `!=` ([Reference type equality operators](expressions.md#reference-type-equality-operators)) unless the type parameter has the value type constraint.</span></span>
*  <span data-ttu-id="d8a71-475">Oggetto `new` espressione ([espressioni per la creazione dell'oggetto](expressions.md#object-creation-expressions)) può essere usato con un parametro di tipo solo se il parametro di tipo è vincolato da una *constructor_constraint* o il valore (vincoloditipo[ Digitare i vincoli del parametro](classes.md#type-parameter-constraints)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-475">A `new` expression ([Object creation expressions](expressions.md#object-creation-expressions)) can only be used with a type parameter if the type parameter is constrained by a *constructor_constraint* or the value type constraint ([Type parameter constraints](classes.md#type-parameter-constraints)).</span></span>
*  <span data-ttu-id="d8a71-476">Un parametro di tipo non possa essere utilizzato ovunque all'interno di un attributo.</span><span class="sxs-lookup"><span data-stu-id="d8a71-476">A type parameter cannot be used anywhere within an attribute.</span></span>
*  <span data-ttu-id="d8a71-477">Un parametro di tipo non può essere usato in un accesso ai membri ([accesso al membro](expressions.md#member-access)) o nome di tipo ([Namespace e dei tipi](basic-concepts.md#namespace-and-type-names)) per identificare un membro statico o un tipo annidato.</span><span class="sxs-lookup"><span data-stu-id="d8a71-477">A type parameter cannot be used in a member access ([Member access](expressions.md#member-access)) or type name ([Namespace and type names](basic-concepts.md#namespace-and-type-names)) to identify a static member or a nested type.</span></span>
*  <span data-ttu-id="d8a71-478">Nel codice unsafe, un parametro di tipo non può essere utilizzato come un *unmanaged_type* ([tipi di puntatore](unsafe-code.md#pointer-types)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-478">In unsafe code, a type parameter cannot be used as an *unmanaged_type* ([Pointer types](unsafe-code.md#pointer-types)).</span></span>

<span data-ttu-id="d8a71-479">Come un tipo, i parametri di tipo sono esclusivamente un costrutto in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-479">As a type, type parameters are purely a compile-time construct.</span></span> <span data-ttu-id="d8a71-480">In fase di esecuzione, ogni parametro di tipo è associato a un tipo in fase di esecuzione che è stato specificato, fornendo un argomento di tipo per la dichiarazione di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="d8a71-480">At run-time, each type parameter is bound to a run-time type that was specified by supplying a type argument to the generic type declaration.</span></span> <span data-ttu-id="d8a71-481">Di conseguenza, il tipo di una variabile dichiarata con un parametro di tipo sarà, in fase di esecuzione, essere un tipo costruito chiuso ([aperto e chiuso tipi](types.md#open-and-closed-types)).</span><span class="sxs-lookup"><span data-stu-id="d8a71-481">Thus, the type of a variable declared with a type parameter will, at run-time, be a closed constructed type ([Open and closed types](types.md#open-and-closed-types)).</span></span> <span data-ttu-id="d8a71-482">La fase di esecuzione di tutte le istruzioni e le espressioni che includono parametri di tipo viene utilizzato il tipo effettivo che è stato fornito come argomento di tipo per quel parametro.</span><span class="sxs-lookup"><span data-stu-id="d8a71-482">The run-time execution of all statements and expressions involving type parameters uses the actual type that was supplied as the type argument for that parameter.</span></span>

## <a name="expression-tree-types"></a><span data-ttu-id="d8a71-483">Tipi di albero delle espressioni</span><span class="sxs-lookup"><span data-stu-id="d8a71-483">Expression tree types</span></span>

<span data-ttu-id="d8a71-484">***Gli alberi delle espressioni*** consentire le espressioni lambda per essere rappresentato come strutture dei dati anziché codice eseguibile.</span><span class="sxs-lookup"><span data-stu-id="d8a71-484">***Expression trees*** permit lambda expressions to be represented as data structures instead of executable code.</span></span> <span data-ttu-id="d8a71-485">Gli alberi delle espressioni sono valori di ***tipi di albero delle espressioni*** del form `System.Linq.Expressions.Expression<D>`, dove `D` è qualsiasi tipo di delegato.</span><span class="sxs-lookup"><span data-stu-id="d8a71-485">Expression trees are values of ***expression tree types*** of the form `System.Linq.Expressions.Expression<D>`, where `D` is any delegate type.</span></span> <span data-ttu-id="d8a71-486">Nella parte restante di questa specifica si farà riferimento a questi tipi usando la sintassi abbreviata `Expression<D>`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-486">For the remainder of this specification we will refer to these types using the shorthand `Expression<D>`.</span></span>

<span data-ttu-id="d8a71-487">Se esiste una conversione da un'espressione lambda a un tipo delegato `D`, disponibile anche una conversione nel tipo di albero delle espressioni `Expression<D>`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-487">If a conversion exists from a lambda expression to a delegate type `D`, a conversion also exists to the expression tree type `Expression<D>`.</span></span> <span data-ttu-id="d8a71-488">Mentre la conversione di un'espressione lambda a un tipo delegato genera un delegato che fa riferimento a codice eseguibile per l'espressione lambda, la conversione a un tipo di albero delle espressioni crea una rappresentazione di albero delle espressioni dell'espressione lambda.</span><span class="sxs-lookup"><span data-stu-id="d8a71-488">Whereas the conversion of a lambda expression to a delegate type generates a delegate that references executable code for the lambda expression, conversion to an expression tree type creates an expression tree representation of the lambda expression.</span></span>

<span data-ttu-id="d8a71-489">Gli alberi delle espressioni sono rappresentazioni efficiente dei dati in memoria delle espressioni lambda e creare la struttura dell'espressione lambda trasparente ed esplicite.</span><span class="sxs-lookup"><span data-stu-id="d8a71-489">Expression trees are efficient in-memory data representations of lambda expressions and make the structure of the lambda expression transparent and explicit.</span></span>

<span data-ttu-id="d8a71-490">Esattamente come un tipo delegato `D`, `Expression<D>` dice che ha parametri e tipi restituiti, che sono identici a quelli di `D`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-490">Just like a delegate type `D`, `Expression<D>` is said to have parameter and return types, which are the same as those of `D`.</span></span>

<span data-ttu-id="d8a71-491">Nell'esempio seguente rappresenta un'espressione lambda come codice eseguibile e come un albero delle espressioni.</span><span class="sxs-lookup"><span data-stu-id="d8a71-491">The following example represents a lambda expression both as executable code and as an expression tree.</span></span> <span data-ttu-id="d8a71-492">Poiché esiste una conversione in `Func<int,int>`, disponibile anche una conversione da `Expression<Func<int,int>>`:</span><span class="sxs-lookup"><span data-stu-id="d8a71-492">Because a conversion exists to `Func<int,int>`, a conversion also exists to `Expression<Func<int,int>>`:</span></span>

```csharp
Func<int,int> del = x => x + 1;                    // Code

Expression<Func<int,int>> exp = x => x + 1;        // Data
```

<span data-ttu-id="d8a71-493">Seguendo queste assegnazioni, il delegato `del` fa riferimento a un metodo che restituisce `x + 1`e l'albero delle espressioni `exp` fa riferimento a una struttura di dati che descrive l'espressione `x => x + 1`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-493">Following these assignments, the delegate `del` references a method that returns `x + 1`, and the expression tree `exp` references a data structure that describes the expression `x => x + 1`.</span></span>

<span data-ttu-id="d8a71-494">La definizione esatta del tipo generico `Expression<D>` , nonché le regole precise per la costruzione di un albero delle espressioni quando un'espressione lambda viene convertita in un tipo di albero delle espressioni, sono entrambi all'esterno dell'ambito di questa specifica.</span><span class="sxs-lookup"><span data-stu-id="d8a71-494">The exact definition of the generic type `Expression<D>` as well as the precise rules for constructing an expression tree when a lambda expression is converted to an expression tree type, are both outside the scope of this specification.</span></span>

<span data-ttu-id="d8a71-495">Due elementi vengono importante rendere esplicito:</span><span class="sxs-lookup"><span data-stu-id="d8a71-495">Two things are important to make explicit:</span></span>

*  <span data-ttu-id="d8a71-496">Non tutte le espressioni lambda possono essere convertite in alberi delle espressioni.</span><span class="sxs-lookup"><span data-stu-id="d8a71-496">Not all lambda expressions can be converted to expression trees.</span></span> <span data-ttu-id="d8a71-497">Ad esempio, le espressioni lambda con corpi di istruzione e le espressioni lambda che contengono espressioni di assegnazione non possono essere rappresentato.</span><span class="sxs-lookup"><span data-stu-id="d8a71-497">For instance, lambda expressions with statement bodies, and lambda expressions containing assignment expressions cannot be represented.</span></span> <span data-ttu-id="d8a71-498">In questi casi, una conversione ancora esiste, ma avrà esito negativo in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="d8a71-498">In these cases, a conversion still exists, but will fail at compile-time.</span></span> <span data-ttu-id="d8a71-499">Queste eccezioni sono descritti in dettaglio [conversioni delle funzioni anonime](conversions.md#anonymous-function-conversions).</span><span class="sxs-lookup"><span data-stu-id="d8a71-499">These exceptions are detailed in [Anonymous function conversions](conversions.md#anonymous-function-conversions).</span></span>
*   <span data-ttu-id="d8a71-500">`Expression<D>` offre un metodo di istanza `Compile` che produce un delegato del tipo `D`:</span><span class="sxs-lookup"><span data-stu-id="d8a71-500">`Expression<D>` offers an instance method `Compile` which produces a delegate of type `D`:</span></span>

    ```csharp
    Func<int,int> del2 = exp.Compile();
    ```

    <span data-ttu-id="d8a71-501">Richiamando il delegato fa sì che il codice rappresentato dall'albero delle espressioni deve essere eseguito.</span><span class="sxs-lookup"><span data-stu-id="d8a71-501">Invoking this delegate causes the code represented by the expression tree to be executed.</span></span> <span data-ttu-id="d8a71-502">Di conseguenza, date le definizioni precedenti, CANC e del2 sono equivalenti e le due istruzioni seguenti avranno lo stesso effetto:</span><span class="sxs-lookup"><span data-stu-id="d8a71-502">Thus, given the definitions above, del and del2 are equivalent, and the following two statements will have the same effect:</span></span>

    ```csharp
    int i1 = del(1);
    
    int i2 = del2(1);
    ```

    <span data-ttu-id="d8a71-503">Dopo avere eseguito questo codice `i1` e `i2` entrambi avranno il valore `2`.</span><span class="sxs-lookup"><span data-stu-id="d8a71-503">After executing this code,  `i1` and `i2` will both have the value `2`.</span></span>

