---
ms.openlocfilehash: 1c3d05674f8f7b69e70e0d9e06021537fc45f7ed
ms.sourcegitcommit: 3fc033b6e98ed7ecdf46a85c79b00a3a3ddcf963
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/18/2019
ms.locfileid: "47229661"
---
# <a name="basic-concepts"></a><span data-ttu-id="b2eb8-101">Concetti di base</span><span class="sxs-lookup"><span data-stu-id="b2eb8-101">Basic concepts</span></span>

## <a name="application-startup"></a><span data-ttu-id="b2eb8-102">Avvio dell'applicazione</span><span class="sxs-lookup"><span data-stu-id="b2eb8-102">Application Startup</span></span>

<span data-ttu-id="b2eb8-103">Un assembly con un ***punto di ingresso*** viene chiamato un ***applicazione***.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-103">An assembly that has an ***entry point*** is called an ***application***.</span></span> <span data-ttu-id="b2eb8-104">Quando un'applicazione viene eseguita, una nuova ***dominio applicazione*** viene creato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-104">When an application is run, a new ***application domain*** is created.</span></span> <span data-ttu-id="b2eb8-105">Più istanze diverse di un'applicazione possono esistere nello stesso computer contemporaneamente e ognuno ha il proprio dominio applicazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-105">Several different instantiations of an application may exist on the same machine at the same time, and each has its own application domain.</span></span>

<span data-ttu-id="b2eb8-106">Un dominio applicazione permette l'isolamento dell'applicazione che agisce come contenitore per lo stato dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-106">An application domain enables application isolation by acting as a container for application state.</span></span> <span data-ttu-id="b2eb8-107">Un dominio dell'applicazione funge da contenitore e limiti per i tipi definiti nell'applicazione e Usa le librerie di classi.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-107">An application domain acts as a container and boundary for the types defined in the application and the class libraries it uses.</span></span> <span data-ttu-id="b2eb8-108">I tipi caricati in un dominio dell'applicazione sono distinti dello stesso tipo caricato in un altro dominio applicazione e le istanze degli oggetti non sono condivisi tra domini delle applicazioni direttamente.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-108">Types loaded into one application domain are distinct from the same type loaded into another application domain, and instances of objects are not directly shared between application domains.</span></span> <span data-ttu-id="b2eb8-109">Ad esempio, ogni dominio dell'applicazione ha una propria copia di variabili statiche per questi tipi e un costruttore statico per un tipo viene eseguito al massimo una volta per ogni dominio dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-109">For instance, each application domain has its own copy of static variables for these types, and a static constructor for a type is run at most once per application domain.</span></span> <span data-ttu-id="b2eb8-110">Le implementazioni sono gratuite fornire criteri specifici dell'implementazione o meccanismi per la creazione e distruzione dei domini applicazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-110">Implementations are free to provide implementation-specific policy or mechanisms for the creation and destruction of application domains.</span></span>

<span data-ttu-id="b2eb8-111">***Avvio dell'applicazione*** si verifica quando l'ambiente di esecuzione chiama un metodo designato, che fa riferimento come punto di ingresso dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-111">***Application startup*** occurs when the execution environment calls a designated method, which is referred to as the application's entry point.</span></span> <span data-ttu-id="b2eb8-112">Questo metodo del punto di ingresso è sempre denominato `Main`e può avere uno dei seguenti firme:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-112">This entry point method is always named `Main`, and can have one of the following signatures:</span></span>

```csharp
static void Main() {...}

static void Main(string[] args) {...}

static int Main() {...}

static int Main(string[] args) {...}
```

<span data-ttu-id="b2eb8-113">Come indicato, il punto di ingresso può facoltativamente restituire un `int` valore.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-113">As shown, the entry point may optionally return an `int` value.</span></span> <span data-ttu-id="b2eb8-114">Questo valore restituito viene utilizzato nella chiusura dell'applicazione ([chiusura dell'applicazione](basic-concepts.md#application-termination)).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-114">This return value is used in application termination ([Application termination](basic-concepts.md#application-termination)).</span></span>

<span data-ttu-id="b2eb8-115">Il punto di ingresso possa facoltativamente avere un parametro formale.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-115">The entry point may optionally have one formal parameter.</span></span> <span data-ttu-id="b2eb8-116">Il parametro può avere qualsiasi nome, ma il tipo del parametro deve essere `string[]`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-116">The parameter may have any name, but the type of the parameter must be `string[]`.</span></span> <span data-ttu-id="b2eb8-117">Se il parametro formale è presente, l'ambiente di esecuzione viene creato e passa un `string[]` argomento che contiene gli argomenti della riga di comando che sono stati specificati quando è stata avviata l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-117">If the formal parameter is present, the execution environment creates and passes a `string[]` argument containing the command-line arguments that were specified when the application was started.</span></span> <span data-ttu-id="b2eb8-118">Il `string[]` argomento non è mai null, ma può avere una lunghezza pari a zero se nessun argomento della riga di comando specificato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-118">The `string[]` argument is never null, but it may have a length of zero if no command-line arguments were specified.</span></span>

<span data-ttu-id="b2eb8-119">Poiché C# supporta l'overload, una classe o struct può contenere più definizioni di un metodo, purché ognuna ha una firma diversa.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-119">Since C# supports method overloading, a class or struct may contain multiple definitions of some method, provided each has a different signature.</span></span> <span data-ttu-id="b2eb8-120">Tuttavia, all'interno di un unico programma, nessuna classe o struttura può contenere più di un metodo chiamato `Main` la cui definizione ne può essere usato come punto di ingresso dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-120">However, within a single program, no class or struct may contain more than one method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="b2eb8-121">Altre versioni di overload `Main` sono consentite, tuttavia, purché questi hanno più di un parametro, o un unico parametro è diverso dal tipo `string[]`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-121">Other overloaded versions of `Main` are permitted, however, provided they have more than one parameter, or their only parameter is other than type `string[]`.</span></span>

<span data-ttu-id="b2eb8-122">Un'applicazione può essere composto da più classi o struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-122">An application can be made up of multiple classes or structs.</span></span> <span data-ttu-id="b2eb8-123">È possibile che più di una di queste classi o struct possono contenere un metodo denominato `Main` la cui definizione ne può essere usato come punto di ingresso dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-123">It is possible for more than one of these classes or structs to contain a method called `Main` whose definition qualifies it to be used as an application entry point.</span></span> <span data-ttu-id="b2eb8-124">In questi casi, un meccanismo esterno (ad esempio, un'opzione della riga di comando del compilatore) deve essere utilizzato per selezionare uno di questi `Main` metodi come punto di ingresso.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-124">In such cases, an external mechanism (such as a command-line compiler option) must be used to select one of these `Main` methods as the entry point.</span></span>

<span data-ttu-id="b2eb8-125">In C#, ogni metodo deve essere definito come membro di una classe o struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-125">In C#, every method must be defined as a member of a class or struct.</span></span> <span data-ttu-id="b2eb8-126">In genere, l'accessibilità dichiarata ([accessibilità dichiarata](basic-concepts.md#declared-accessibility)) di un metodo è determinato dai modificatori di accesso ([modificatori di accesso](classes.md#access-modifiers)) specificato nella relativa dichiarazione e allo stesso modo dichiarato accessibilità di un tipo è determinato dai modificatori di accesso specificati nella relativa dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-126">Ordinarily, the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of a method is determined by the access modifiers ([Access modifiers](classes.md#access-modifiers)) specified in its declaration, and similarly the declared accessibility of a type is determined by the access modifiers specified in its declaration.</span></span> <span data-ttu-id="b2eb8-127">Affinché un determinato metodo di un determinato tipo possa essere chiamata, il tipo e il membro deve essere accessibile.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-127">In order for a given method of a given type to be callable, both the type and the member must be accessible.</span></span> <span data-ttu-id="b2eb8-128">Tuttavia, il punto di ingresso dell'applicazione è un caso speciale.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-128">However, the application entry point is a special case.</span></span> <span data-ttu-id="b2eb8-129">In particolare, l'ambiente di esecuzione può accedere a punto di ingresso dell'applicazione indipendentemente dall'accessibilità dichiarata e indipendentemente dall'accessibilità dichiarata del relativo contenitore dichiarazioni di tipo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-129">Specifically, the execution environment can access the application's entry point regardless of its declared accessibility and regardless of the declared accessibility of its enclosing type declarations.</span></span>

<span data-ttu-id="b2eb8-130">Il metodo di punto di ingresso dell'applicazione potrebbe non essere in una dichiarazione di classe generica.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-130">The application entry point method may not be in a generic class declaration.</span></span>

<span data-ttu-id="b2eb8-131">Tutti gli altri aspetti, i metodi del punto di ingresso si comportano come gli utenti che non punti di ingresso.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-131">In all other respects, entry point methods behave like those that are not entry points.</span></span>

## <a name="application-termination"></a><span data-ttu-id="b2eb8-132">Chiusura dell'applicazione</span><span class="sxs-lookup"><span data-stu-id="b2eb8-132">Application termination</span></span>

<span data-ttu-id="b2eb8-133">***Chiusura dell'applicazione*** restituisce il controllo all'ambiente di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-133">***Application termination*** returns control to the execution environment.</span></span>

<span data-ttu-id="b2eb8-134">Se il tipo restituito dell'applicazione ***punto di ingresso*** consiste `int`, il valore restituito viene utilizzato come l'applicazione ***codice di stato di chiusura***.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-134">If the return type of the application's ***entry point*** method is `int`, the value returned serves as the application's ***termination status code***.</span></span> <span data-ttu-id="b2eb8-135">Lo scopo di questo codice è per consentire la comunicazione di esito positivo o negativo per l'ambiente di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-135">The purpose of this code is to allow communication of success or failure to the execution environment.</span></span>

<span data-ttu-id="b2eb8-136">Se il tipo restituito del metodo del punto di ingresso `void`, raggiunge la parentesi graffa destra (`}`) che termina che metodo o l'esecuzione di un `return` istruzione che è presente alcuna espressione, come risultato un codice di stato di chiusura `0`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-136">If the return type of the entry point method is `void`, reaching the right brace (`}`) which terminates that method, or executing a `return` statement that has no expression, results in a termination status code of `0`.</span></span>

<span data-ttu-id="b2eb8-137">Prima della chiusura di un'applicazione, vengono chiamati i distruttori di tutti i relativi oggetti che non sono ancora stato sottoposto a garbage collection, a meno che non è stato soppresso questo tipo di pulizia (da una chiamata al metodo libreria `GC.SuppressFinalize`, ad esempio).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-137">Prior to an application's termination, destructors for all of its objects that have not yet been garbage collected are called, unless such cleanup has been suppressed (by a call to the library method `GC.SuppressFinalize`, for example).</span></span>

## <a name="declarations"></a><span data-ttu-id="b2eb8-138">Dichiarazioni</span><span class="sxs-lookup"><span data-stu-id="b2eb8-138">Declarations</span></span>

<span data-ttu-id="b2eb8-139">Le dichiarazioni in un programma C# definiscono gli elementi costitutivi del programma.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-139">Declarations in a C# program define the constituent elements of the program.</span></span> <span data-ttu-id="b2eb8-140">Organizzazione dei programmi C# usando gli spazi dei nomi ([spazi dei nomi](namespaces.md)), che può contenere tipo dichiarazioni e le dichiarazioni dello spazio dei nomi annidati.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-140">C# programs are organized using namespaces ([Namespaces](namespaces.md)), which can contain type declarations and nested namespace declarations.</span></span> <span data-ttu-id="b2eb8-141">Dichiarazioni di tipo ([dichiarazioni di tipo](namespaces.md#type-declarations)) vengono usate per definire le classi ([classi](classes.md)), struct ([struct](structs.md)), le interfacce ([interfacce](interfaces.md) ), le enumerazioni ([enumerazioni](enums.md)), i delegati e ([delegati](delegates.md)).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-141">Type declarations ([Type declarations](namespaces.md#type-declarations)) are used to define classes ([Classes](classes.md)), structs ([Structs](structs.md)), interfaces ([Interfaces](interfaces.md)), enums ([Enums](enums.md)), and delegates ([Delegates](delegates.md)).</span></span> <span data-ttu-id="b2eb8-142">I tipi di membri consentiti in una dichiarazione del tipo variano a seconda forma di dichiarazione del tipo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-142">The kinds of members permitted in a type declaration depend on the form of the type declaration.</span></span> <span data-ttu-id="b2eb8-143">Ad esempio, le dichiarazioni di classe possono contenere dichiarazioni per le costanti ([costanti](classes.md#constants)), i campi ([campi](classes.md#fields)), i metodi ([metodi](classes.md#methods)), le proprietà ([ Le proprietà](classes.md#properties)), gli eventi ([eventi](classes.md#events)), gli indicizzatori ([indicizzatori](classes.md#indexers)), gli operatori ([operatori](classes.md#operators)), costruttori di istanze ([ Costruttori di istanze](classes.md#instance-constructors)), i costruttori statici ([costruttori statici](classes.md#static-constructors)), distruttori ([distruttori](classes.md#destructors)) e i tipi annidati ([tipiannidati](classes.md#nested-types)).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-143">For instance, class declarations can contain declarations for constants ([Constants](classes.md#constants)), fields ([Fields](classes.md#fields)), methods ([Methods](classes.md#methods)), properties ([Properties](classes.md#properties)), events ([Events](classes.md#events)), indexers ([Indexers](classes.md#indexers)), operators ([Operators](classes.md#operators)), instance constructors ([Instance constructors](classes.md#instance-constructors)), static constructors ([Static constructors](classes.md#static-constructors)), destructors ([Destructors](classes.md#destructors)), and nested types ([Nested types](classes.md#nested-types)).</span></span>

<span data-ttu-id="b2eb8-144">Una dichiarazione definisce un nome nel ***spazio di dichiarazione*** a cui appartiene la dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-144">A declaration defines a name in the ***declaration space*** to which the declaration belongs.</span></span> <span data-ttu-id="b2eb8-145">Ad eccezione dei membri di overload ([firme e overload](basic-concepts.md#signatures-and-overloading)), è un errore in fase di compilazione hanno due o più dichiarazioni che introducono i membri con lo stesso nome in uno spazio di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-145">Except for overloaded members ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)), it is a compile-time error to have two or more declarations that introduce members with the same name in a declaration space.</span></span> <span data-ttu-id="b2eb8-146">Non è mai possibile che uno spazio di dichiarazione per contenere diversi tipi di membri con lo stesso nome.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-146">It is never possible for a declaration space to contain different kinds of members with the same name.</span></span> <span data-ttu-id="b2eb8-147">Ad esempio, uno spazio di dichiarazione non può mai contenere un campo e un metodo con lo stesso nome.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-147">For example, a declaration space can never contain a field and a method by the same name.</span></span>

<span data-ttu-id="b2eb8-148">Esistono diversi tipi di spazi di dichiarazione, come descritto di seguito.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-148">There are several different types of declaration spaces, as described in the following.</span></span>

*  <span data-ttu-id="b2eb8-149">All'interno di tutti i file di origine di un programma *namespace_member_declaration*s con alcun tipo di inclusione *namespace_declaration* sono membri di un singola dichiarazione combinato spazio il ***globale spazio di dichiarazione***.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-149">Within all source files of a program, *namespace_member_declaration*s with no enclosing *namespace_declaration* are members of a single combined declaration space called the ***global declaration space***.</span></span>
*  <span data-ttu-id="b2eb8-150">All'interno di tutti i file di origine di un programma *namespace_member_declaration*entro *namespace_declaration*che hanno lo stesso nome completo dello spazio dei nomi sono membri di una singola dichiarazione combinato spazio.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-150">Within all source files of a program, *namespace_member_declaration*s within *namespace_declaration*s that have the same fully qualified namespace name are members of a single combined declaration space.</span></span>
*  <span data-ttu-id="b2eb8-151">Ogni classe, struct o dichiarazione di interfaccia crea un nuovo spazio di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-151">Each class, struct, or interface declaration creates a new declaration space.</span></span> <span data-ttu-id="b2eb8-152">I nomi vengono introdotti in questo spazio di dichiarazione attraverso *class_member_declaration*s *struct_member_declaration*s *interface_member_declaration*s, o *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-152">Names are introduced into this declaration space through *class_member_declaration*s, *struct_member_declaration*s, *interface_member_declaration*s, or *type_parameter*s.</span></span> <span data-ttu-id="b2eb8-153">Ad eccezione di costruttore di overload istanza dichiarazioni e un costruttore statico dichiarazioni, una classe o struct non può contenere una dichiarazione di membro con lo stesso nome della classe o struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-153">Except for overloaded instance constructor declarations and static constructor declarations, a class or struct cannot contain a member declaration with the same name as the class or struct.</span></span> <span data-ttu-id="b2eb8-154">Una classe, struct o interfaccia consente la dichiarazione di metodi di overload e indicizzatori.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-154">A class, struct, or interface permits the declaration of overloaded methods and indexers.</span></span> <span data-ttu-id="b2eb8-155">Inoltre, una classe o struct consente la dichiarazione di costruttori di istanze in overload e operatori.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-155">Furthermore, a class or struct permits the declaration of overloaded instance constructors and operators.</span></span> <span data-ttu-id="b2eb8-156">Ad esempio, una classe, struct o interfaccia contenga più dichiarazioni di metodo con lo stesso nome, purché queste dichiarazioni differente abbiano una firma ([firme e overload](basic-concepts.md#signatures-and-overloading)).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-156">For example, a class, struct, or interface may contain multiple method declarations with the same name, provided these method declarations differ in their signature ([Signatures and overloading](basic-concepts.md#signatures-and-overloading)).</span></span> <span data-ttu-id="b2eb8-157">Si noti che le classi di base non vengono conteggiati per lo spazio di dichiarazione di una classe e le interfacce di base non vengono conteggiati per lo spazio di dichiarazione di un'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-157">Note that base classes do not contribute to the declaration space of a class, and base interfaces do not contribute to the declaration space of an interface.</span></span> <span data-ttu-id="b2eb8-158">Di conseguenza, una classe derivata o un'interfaccia è consentito dichiarare un membro con lo stesso nome di un membro ereditato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-158">Thus, a derived class or interface is allowed to declare a member with the same name as an inherited member.</span></span> <span data-ttu-id="b2eb8-159">Tale membro viene detto ***nascondere*** il membro ereditato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-159">Such a member is said to ***hide*** the inherited member.</span></span>
*  <span data-ttu-id="b2eb8-160">Ogni dichiarazione di delegato crea un nuovo spazio di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-160">Each delegate declaration creates a new declaration space.</span></span> <span data-ttu-id="b2eb8-161">I nomi vengono introdotti in questo spazio di dichiarazione tramite i parametri formali (*fixed_parameter*s e *parameter_array*s) e *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-161">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span>
*  <span data-ttu-id="b2eb8-162">Ogni dichiarazione di enumerazione crea un nuovo spazio di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-162">Each enumeration declaration creates a new declaration space.</span></span> <span data-ttu-id="b2eb8-163">I nomi vengono introdotti in questo spazio di dichiarazione attraverso *enum_member_declarations*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-163">Names are introduced into this declaration space through *enum_member_declarations*.</span></span>
*  <span data-ttu-id="b2eb8-164">Ogni dichiarazione di metodo, la dichiarazione di indicizzatore, dichiarazioni di operatore, dichiarazione di costruttore di istanza e funzione anonima consente di creare un nuovo spazio di dichiarazione chiamato un' ***dello spazio di dichiarazione di variabile locale***.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-164">Each method declaration, indexer declaration, operator declaration, instance constructor declaration and anonymous function creates a new declaration space called a ***local variable declaration space***.</span></span> <span data-ttu-id="b2eb8-165">I nomi vengono introdotti in questo spazio di dichiarazione tramite i parametri formali (*fixed_parameter*s e *parameter_array*s) e *type_parameter*s.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-165">Names are introduced into this declaration space through formal parameters (*fixed_parameter*s and *parameter_array*s) and *type_parameter*s.</span></span> <span data-ttu-id="b2eb8-166">Il corpo della funzione membro o della funzione anonima, se presente, viene considerato l'annidamento nello spazio di dichiarazione di variabile locale.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-166">The body of the function member or anonymous function, if any, is considered to be nested within the local variable declaration space.</span></span> <span data-ttu-id="b2eb8-167">È un errore per uno spazio di dichiarazione di variabile locale e uno spazio di dichiarazione di variabile locale annidati per contenere gli elementi con lo stesso nome.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-167">It is an error for a local variable declaration space and a nested local variable declaration space to contain elements with the same name.</span></span> <span data-ttu-id="b2eb8-168">Di conseguenza, all'interno di uno spazio di dichiarazione annidati non è possibile dichiarare una variabile locale costante o variabile o costante con lo stesso nome di una variabile locale in uno spazio di dichiarazione che lo contiene.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-168">Thus, within a nested declaration space it is not possible to declare a local variable or constant with the same name as a local variable or constant in an enclosing declaration space.</span></span> <span data-ttu-id="b2eb8-169">È possibile che due spazi di dichiarazione contenere gli elementi con lo stesso nome, purché nessuno spazio di dichiarazione contiene l'altro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-169">It is possible for two declaration spaces to contain elements with the same name as long as neither declaration space contains the other.</span></span>
*  <span data-ttu-id="b2eb8-170">Ogni *blocco* oppure *switch_block* , nonché una *per*, *foreach* e *usando* istruzione, crea un spazio di dichiarazione di variabile locale per le variabili locali e le costanti locali.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-170">Each *block* or *switch_block* , as well as a *for*, *foreach* and *using* statement, creates a local variable declaration space for local variables and local constants .</span></span> <span data-ttu-id="b2eb8-171">I nomi vengono introdotti in questo spazio di dichiarazione attraverso *local_variable_declaration*s e *local_constant_declaration*s.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-171">Names are introduced into this declaration space through *local_variable_declaration*s and *local_constant_declaration*s.</span></span> <span data-ttu-id="b2eb8-172">Si noti che i blocchi che si verificano come o all'interno del corpo di una funzione anonima o un membro di funzione sono annidati nello spazio di dichiarazione di variabile locale dichiarato da tali funzioni per i relativi parametri.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-172">Note that blocks that occur as or within the body of a function member or anonymous function are nested within the local variable declaration space declared by those functions for their parameters.</span></span> <span data-ttu-id="b2eb8-173">In questo modo è errato, ad esempio un metodo con un parametro lo stesso nome e una variabile locale.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-173">Thus it is an error to have e.g. a method with a local variable and a parameter of the same name.</span></span>
*  <span data-ttu-id="b2eb8-174">Ciascuna *block* oppure *switch_block* crea uno spazio di dichiarazione separata per le etichette.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-174">Each *block* or *switch_block* creates a separate declaration space for labels.</span></span> <span data-ttu-id="b2eb8-175">I nomi vengono introdotti in questo spazio di dichiarazione attraverso *labeled_statement*s e i nomi vengono fatto riferimento tramite *goto_statement*s.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-175">Names are introduced into this declaration space through *labeled_statement*s, and the names are referenced through *goto_statement*s.</span></span> <span data-ttu-id="b2eb8-176">Il ***etichettare spazio di dichiarazione*** di un blocco include tutti i blocchi annidati.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-176">The ***label declaration space*** of a block includes any nested blocks.</span></span> <span data-ttu-id="b2eb8-177">Di conseguenza, all'interno di un blocco annidato non è possibile dichiarare un'etichetta con lo stesso nome di un'etichetta in un blocco di inclusione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-177">Thus, within a nested block it is not possible to declare a label with the same name as a label in an enclosing block.</span></span>

<span data-ttu-id="b2eb8-178">L'ordine testuale in cui vengono dichiarati i nomi è in genere, non è importante.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-178">The textual order in which names are declared is generally of no significance.</span></span> <span data-ttu-id="b2eb8-179">Ordine testuale in particolare, non è significativo per la dichiarazione e utilizzo di spazi dei nomi, costanti, metodi, proprietà, eventi, indicizzatori, operatori, costruttori di istanze, distruttori, i costruttori statici e tipi.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-179">In particular, textual order is not significant for the declaration and use of namespaces, constants, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors, and types.</span></span> <span data-ttu-id="b2eb8-180">Ordine di dichiarazione è significativo nei modi seguenti:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-180">Declaration order is significant in the following ways:</span></span>

*  <span data-ttu-id="b2eb8-181">Ordine di dichiarazione per le dichiarazioni di campo e dichiarazioni di variabile locale determina l'ordine in cui vengono eseguiti i relativi inizializzatori (se presente).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-181">Declaration order for field declarations and local variable declarations determines the order in which their initializers (if any) are executed.</span></span>
*  <span data-ttu-id="b2eb8-182">Le variabili locali devono essere definite prima che vengano utilizzate ([ambiti](basic-concepts.md#scopes)).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-182">Local variables must be defined before they are used ([Scopes](basic-concepts.md#scopes)).</span></span>
*  <span data-ttu-id="b2eb8-183">Ordine di dichiarazione per le dichiarazioni di membro di enumerazione ([membri Enum](enums.md#enum-members)) è significativo quando *constant_expression* i valori vengono omessi.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-183">Declaration order for enum member declarations ([Enum members](enums.md#enum-members)) is significant when *constant_expression* values are omitted.</span></span>

<span data-ttu-id="b2eb8-184">Lo spazio di dichiarazione di uno spazio dei nomi è "aperta" e lo spazio dei nomi due dichiarazioni con lo stesso nome completo contribuiscono allo stesso spazio di dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-184">The declaration space of a namespace is "open ended", and two namespace declarations with the same fully qualified name contribute to the same declaration space.</span></span> <span data-ttu-id="b2eb8-185">Esempio:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-185">For example</span></span>
```csharp
namespace Megacorp.Data
{
    class Customer
    {
        ...
    }
}

namespace Megacorp.Data
{
    class Order
    {
        ...
    }
}
```

<span data-ttu-id="b2eb8-186">le due dichiarazioni dello spazio dei nomi sopra contribuiscono allo stesso spazio di dichiarazione, in questo caso dichiarare due classi con nomi completi `Megacorp.Data.Customer` e `Megacorp.Data.Order`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-186">The two namespace declarations above contribute to the same declaration space, in this case declaring two classes with the fully qualified names `Megacorp.Data.Customer` and `Megacorp.Data.Order`.</span></span> <span data-ttu-id="b2eb8-187">Poiché le due dichiarazioni contribuiscono allo stesso spazio di dichiarazione, si verificherebbe un errore in fase di compilazione se ognuno contiene una dichiarazione di una classe con lo stesso nome.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-187">Because the two declarations contribute to the same declaration space, it would have caused a compile-time error if each contained a declaration of a class with the same name.</span></span>

<span data-ttu-id="b2eb8-188">Come specificato in precedenza, lo spazio di dichiarazione di un blocco include tutti i blocchi annidati.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-188">As specified above, the declaration space of a block includes any nested blocks.</span></span> <span data-ttu-id="b2eb8-189">Pertanto, nell'esempio seguente, il `F` e `G` metodi generato un errore in fase di compilazione perché il nome `i` viene dichiarato in un blocco esterno e non può essere ridichiarato nel blocco interno.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-189">Thus, in the following example, the `F` and `G` methods result in a compile-time error because the name `i` is declared in the outer block and cannot be redeclared in the inner block.</span></span> <span data-ttu-id="b2eb8-190">Tuttavia, il `H` e `I` metodi sono validi perché i due `i`del vengono dichiarati in blocchi separati non annidata.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-190">However, the `H` and `I` methods are valid since the two `i`'s are declared in separate non-nested blocks.</span></span>

```csharp
class A
{
    void F() {
        int i = 0;
        if (true) {
            int i = 1;            
        }
    }

    void G() {
        if (true) {
            int i = 0;
        }
        int i = 1;                
    }

    void H() {
        if (true) {
            int i = 0;
        }
        if (true) {
            int i = 1;
        }
    }

    void I() {
        for (int i = 0; i < 10; i++)
            H();
        for (int i = 0; i < 10; i++)
            H();
    }
}
```

## <a name="members"></a><span data-ttu-id="b2eb8-191">Membri</span><span class="sxs-lookup"><span data-stu-id="b2eb8-191">Members</span></span>

<span data-ttu-id="b2eb8-192">Gli spazi dei nomi e tipi hanno ***membri***.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-192">Namespaces and types have ***members***.</span></span> <span data-ttu-id="b2eb8-193">I membri di un'entità sono in genere disponibili tramite l'uso di un nome completo che inizia con un riferimento all'entità, seguito da un "`.`" token, seguito dal nome del membro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-193">The members of an entity are generally available through the use of a qualified name that starts with a reference to the entity, followed by a "`.`" token, followed by the name of the member.</span></span>

<span data-ttu-id="b2eb8-194">I membri di un tipo sono dichiarati nella dichiarazione del tipo oppure ***ereditata*** dalla classe di base del tipo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-194">Members of a type are either declared in the type declaration or ***inherited*** from the base class of the type.</span></span> <span data-ttu-id="b2eb8-195">Quando un tipo eredita da una classe di base, tutti i membri della classe di base, ad eccezione di costruttori di istanze, distruttori e i costruttori statici, diventano membri del tipo derivato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-195">When a type inherits from a base class, all members of the base class, except instance constructors, destructors and static constructors, become members of the derived type.</span></span> <span data-ttu-id="b2eb8-196">L'accessibilità dichiarata di un membro della classe base non controlla se il membro viene ereditato, ereditarietà si estende a tutti i membri che non sono un costruttore di istanza, costruttore statico o distruttore.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-196">The declared accessibility of a base class member does not control whether the member is inherited—inheritance extends to any member that isn't an instance constructor, static constructor, or destructor.</span></span> <span data-ttu-id="b2eb8-197">Tuttavia, un membro ereditato non sia accessibile in un tipo derivato, a causa l'accessibilità dichiarata ([accessibilità dichiarata](basic-concepts.md#declared-accessibility)) o perché è nascosta da una dichiarazione del tipo stesso ([nascosto tramite ereditarietà](basic-concepts.md#hiding-through-inheritance)).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-197">However, an inherited member may not be accessible in a derived type, either because of its declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) or because it is hidden by a declaration in the type itself ([Hiding through inheritance](basic-concepts.md#hiding-through-inheritance)).</span></span>

### <a name="namespace-members"></a><span data-ttu-id="b2eb8-198">Membri di Namespace</span><span class="sxs-lookup"><span data-stu-id="b2eb8-198">Namespace members</span></span>

<span data-ttu-id="b2eb8-199">Spazi dei nomi e tipi che non dispongono di alcun spazio dei nomi contenitore sono membri del ***spazio dei nomi globale***.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-199">Namespaces and types that have no enclosing namespace are members of the ***global namespace***.</span></span> <span data-ttu-id="b2eb8-200">Corrisponde direttamente ai nomi dichiarati nello spazio di dichiarazione globale.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-200">This corresponds directly to the names declared in the global declaration space.</span></span>

<span data-ttu-id="b2eb8-201">Gli spazi dei nomi e i tipi dichiarati all'interno di uno spazio dei nomi sono membri di tale spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-201">Namespaces and types declared within a namespace are members of that namespace.</span></span> <span data-ttu-id="b2eb8-202">Corrisponde direttamente ai nomi dichiarati nello spazio di dichiarazione dello spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-202">This corresponds directly to the names declared in the declaration space of the namespace.</span></span>

<span data-ttu-id="b2eb8-203">Gli spazi dei nomi non hanno restrizioni di accesso.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-203">Namespaces have no access restrictions.</span></span> <span data-ttu-id="b2eb8-204">Non è possibile dichiarare gli spazi dei nomi privato, protetto o interno e spazi dei nomi sono sempre accessibili pubblicamente.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-204">It is not possible to declare private, protected, or internal namespaces, and namespace names are always publicly accessible.</span></span>

### <a name="struct-members"></a><span data-ttu-id="b2eb8-205">Membri struct</span><span class="sxs-lookup"><span data-stu-id="b2eb8-205">Struct members</span></span>

<span data-ttu-id="b2eb8-206">I membri di uno struct sono i membri dichiarati nella struttura e i membri ereditati dalla classe base diretta dello struct `System.ValueType` e la classe base indiretta `object`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-206">The members of a struct are the members declared in the struct and the members inherited from the struct's direct base class `System.ValueType` and the indirect base class `object`.</span></span>

<span data-ttu-id="b2eb8-207">I membri di un tipo semplice corrispondono direttamente ai membri del tipo di struct con alias dal tipo semplice:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-207">The members of a simple type correspond directly to the members of the struct type aliased by the simple type:</span></span>

*  <span data-ttu-id="b2eb8-208">I membri del `sbyte` sono i membri del `System.SByte` struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-208">The members of `sbyte` are the members of the `System.SByte` struct.</span></span>
*  <span data-ttu-id="b2eb8-209">I membri del `byte` sono i membri del `System.Byte` struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-209">The members of `byte` are the members of the `System.Byte` struct.</span></span>
*  <span data-ttu-id="b2eb8-210">I membri del `short` sono i membri del `System.Int16` struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-210">The members of `short` are the members of the `System.Int16` struct.</span></span>
*  <span data-ttu-id="b2eb8-211">I membri del `ushort` sono i membri del `System.UInt16` struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-211">The members of `ushort` are the members of the `System.UInt16` struct.</span></span>
*  <span data-ttu-id="b2eb8-212">I membri del `int` sono i membri del `System.Int32` struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-212">The members of `int` are the members of the `System.Int32` struct.</span></span>
*  <span data-ttu-id="b2eb8-213">I membri del `uint` sono i membri del `System.UInt32` struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-213">The members of `uint` are the members of the `System.UInt32` struct.</span></span>
*  <span data-ttu-id="b2eb8-214">I membri del `long` sono i membri del `System.Int64` struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-214">The members of `long` are the members of the `System.Int64` struct.</span></span>
*  <span data-ttu-id="b2eb8-215">I membri del `ulong` sono i membri del `System.UInt64` struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-215">The members of `ulong` are the members of the `System.UInt64` struct.</span></span>
*  <span data-ttu-id="b2eb8-216">I membri del `char` sono i membri del `System.Char` struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-216">The members of `char` are the members of the `System.Char` struct.</span></span>
*  <span data-ttu-id="b2eb8-217">I membri del `float` sono i membri del `System.Single` struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-217">The members of `float` are the members of the `System.Single` struct.</span></span>
*  <span data-ttu-id="b2eb8-218">I membri del `double` sono i membri del `System.Double` struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-218">The members of `double` are the members of the `System.Double` struct.</span></span>
*  <span data-ttu-id="b2eb8-219">I membri del `decimal` sono i membri del `System.Decimal` struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-219">The members of `decimal` are the members of the `System.Decimal` struct.</span></span>
*  <span data-ttu-id="b2eb8-220">I membri del `bool` sono i membri del `System.Boolean` struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-220">The members of `bool` are the members of the `System.Boolean` struct.</span></span>

### <a name="enumeration-members"></a><span data-ttu-id="b2eb8-221">Membri dell'enumerazione</span><span class="sxs-lookup"><span data-stu-id="b2eb8-221">Enumeration members</span></span>

<span data-ttu-id="b2eb8-222">I membri di un'enumerazione sono costanti dichiarate nell'enumerazione e i membri ereditati dalla classe base diretta dell'enumerazione `System.Enum` e le classi di base indirette `System.ValueType` e `object`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-222">The members of an enumeration are the constants declared in the enumeration and the members inherited from the enumeration's direct base class `System.Enum` and the indirect base classes `System.ValueType` and `object`.</span></span>

### <a name="class-members"></a><span data-ttu-id="b2eb8-223">Membri della classe</span><span class="sxs-lookup"><span data-stu-id="b2eb8-223">Class members</span></span>

<span data-ttu-id="b2eb8-224">I membri di una classe sono i membri dichiarati nella classe e i membri ereditati dalla classe di base (ad eccezione di classe `object` che non dispone di alcuna classe di base).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-224">The members of a class are the members declared in the class and the members inherited from the base class (except for class `object` which has no base class).</span></span> <span data-ttu-id="b2eb8-225">I membri ereditati dalla classe di base includono le costanti, campi, metodi, proprietà, eventi, indicizzatori, operatori e tipi di classe di base, ma non i costruttori di istanze, distruttori e i costruttori statici della classe di base.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-225">The members inherited from the base class include the constants, fields, methods, properties, events, indexers, operators, and types of the base class, but not the instance constructors, destructors and static constructors of the base class.</span></span> <span data-ttu-id="b2eb8-226">I membri di classe di base vengono ereditati senza considerare l'accessibilità.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-226">Base class members are inherited without regard to their accessibility.</span></span>

<span data-ttu-id="b2eb8-227">Una dichiarazione di classe può contenere le dichiarazioni delle costanti, campi, metodi, proprietà, eventi, indicizzatori, operatori, costruttori di istanze, distruttori, i costruttori statici e i tipi.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-227">A class declaration may contain declarations of constants, fields, methods, properties, events, indexers, operators, instance constructors, destructors, static constructors and types.</span></span>

<span data-ttu-id="b2eb8-228">I membri del `object` e `string` corrispondono direttamente ai membri dei tipi di classe costituiscono gli alias:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-228">The members of `object` and `string` correspond directly to the members of the class types they alias:</span></span>

*  <span data-ttu-id="b2eb8-229">I membri del `object` sono i membri del `System.Object` classe.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-229">The members of `object` are the members of the `System.Object` class.</span></span>
*  <span data-ttu-id="b2eb8-230">I membri del `string` sono i membri del `System.String` classe.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-230">The members of `string` are the members of the `System.String` class.</span></span>

### <a name="interface-members"></a><span data-ttu-id="b2eb8-231">Membri di interfaccia</span><span class="sxs-lookup"><span data-stu-id="b2eb8-231">Interface members</span></span>

<span data-ttu-id="b2eb8-232">I membri di un'interfaccia sono i membri dichiarati nell'interfaccia e in tutte le interfacce di base dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-232">The members of an interface are the members declared in the interface and in all base interfaces of the interface.</span></span> <span data-ttu-id="b2eb8-233">I membri nella classe `object` non lo sono, in senso stretto, membri di un'interfaccia ([membri di interfaccia](interfaces.md#interface-members)).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-233">The members in class `object` are not, strictly speaking, members of any interface ([Interface members](interfaces.md#interface-members)).</span></span> <span data-ttu-id="b2eb8-234">Tuttavia, i membri nella classe `object` sono disponibili tramite ricerca di membri in qualsiasi tipo di interfaccia ([ricerca di membri](expressions.md#member-lookup)).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-234">However, the members in class `object` are available via member lookup in any interface type ([Member lookup](expressions.md#member-lookup)).</span></span>

### <a name="array-members"></a><span data-ttu-id="b2eb8-235">Membri di matrici</span><span class="sxs-lookup"><span data-stu-id="b2eb8-235">Array members</span></span>

<span data-ttu-id="b2eb8-236">I membri di una matrice sono i membri ereditati dalla classe `System.Array`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-236">The members of an array are the members inherited from class `System.Array`.</span></span>

### <a name="delegate-members"></a><span data-ttu-id="b2eb8-237">Membri di delegato</span><span class="sxs-lookup"><span data-stu-id="b2eb8-237">Delegate members</span></span>

<span data-ttu-id="b2eb8-238">I membri di un delegato sono i membri ereditati dalla classe `System.Delegate`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-238">The members of a delegate are the members inherited from class `System.Delegate`.</span></span>

## <a name="member-access"></a><span data-ttu-id="b2eb8-239">Accesso ai membri</span><span class="sxs-lookup"><span data-stu-id="b2eb8-239">Member access</span></span>

<span data-ttu-id="b2eb8-240">Le dichiarazioni dei membri consentono di controllare l'accesso al membro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-240">Declarations of members allow control over member access.</span></span> <span data-ttu-id="b2eb8-241">L'accessibilità di un membro viene stabilito dall'accessibilità dichiarata ([accessibilità dichiarata](basic-concepts.md#declared-accessibility)) del membro combinati con l'accessibilità del tipo contenitore, se presente.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-241">The accessibility of a member is established by the declared accessibility ([Declared accessibility](basic-concepts.md#declared-accessibility)) of the member combined with the accessibility of the immediately containing type, if any.</span></span>

<span data-ttu-id="b2eb8-242">Quando è consentito l'accesso a un determinato membro, il membro viene detto ***accessibile***.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-242">When access to a particular member is allowed, the member is said to be ***accessible***.</span></span> <span data-ttu-id="b2eb8-243">Per contro, non è consentito l'accesso a un determinato membro, il membro è detta ***inaccessibile***.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-243">Conversely, when access to a particular member is disallowed, the member is said to be ***inaccessible***.</span></span> <span data-ttu-id="b2eb8-244">Accesso a un membro è consentito quando la posizione di testo in cui si desidera accedere è incluso nel dominio di accessibilità ([domini accessibilità](basic-concepts.md#accessibility-domains)) del membro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-244">Access to a member is permitted when the textual location in which the access takes place is included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>

### <a name="declared-accessibility"></a><span data-ttu-id="b2eb8-245">Accessibilità dichiarata</span><span class="sxs-lookup"><span data-stu-id="b2eb8-245">Declared accessibility</span></span>

<span data-ttu-id="b2eb8-246">Il ***accessibilità dichiarata*** di un membro può essere uno dei seguenti:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-246">The ***declared accessibility*** of a member can be one of the following:</span></span>

*  <span data-ttu-id="b2eb8-247">Pubblico, che viene selezionato, includendo un `public` modificatore nella dichiarazione del membro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-247">Public, which is selected by including a `public` modifier in the member declaration.</span></span> <span data-ttu-id="b2eb8-248">Intuibile `public` ad "non accesso limitato".</span><span class="sxs-lookup"><span data-stu-id="b2eb8-248">The intuitive meaning of `public` is "access not limited".</span></span>
*  <span data-ttu-id="b2eb8-249">Protetto, che è selezionata, includendo un `protected` modificatore nella dichiarazione del membro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-249">Protected, which is selected by including a `protected` modifier in the member declaration.</span></span> <span data-ttu-id="b2eb8-250">Intuibile `protected` è "accesso limitato alla classe o i tipi derivato dalla classe di appartenenza".</span><span class="sxs-lookup"><span data-stu-id="b2eb8-250">The intuitive meaning of `protected` is "access limited to the containing class or types derived from the containing class".</span></span>
*  <span data-ttu-id="b2eb8-251">Interno, che viene selezionato, includendo un `internal` modificatore nella dichiarazione del membro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-251">Internal, which is selected by including an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="b2eb8-252">Intuibile `internal` ad "accesso limitato a questo programma".</span><span class="sxs-lookup"><span data-stu-id="b2eb8-252">The intuitive meaning of `internal` is "access limited to this program".</span></span>
*  <span data-ttu-id="b2eb8-253">Protected internal (ovvero protetto o interno), che è selezionata, includendo entrambi una `protected` e un `internal` modificatore nella dichiarazione del membro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-253">Protected internal (meaning protected or internal), which is selected by including both a `protected` and an `internal` modifier in the member declaration.</span></span> <span data-ttu-id="b2eb8-254">Intuibile `protected internal` è "accesso limitato a questo programma o ai tipi derivati dalla classe di appartenenza".</span><span class="sxs-lookup"><span data-stu-id="b2eb8-254">The intuitive meaning of `protected internal` is "access limited to this program or types derived from the containing class".</span></span>
*  <span data-ttu-id="b2eb8-255">Private, che viene selezionata, includendo un `private` modificatore nella dichiarazione del membro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-255">Private, which is selected by including a `private` modifier in the member declaration.</span></span> <span data-ttu-id="b2eb8-256">Intuibile `private` ad "accesso limitato al tipo contenitore".</span><span class="sxs-lookup"><span data-stu-id="b2eb8-256">The intuitive meaning of `private` is "access limited to the containing type".</span></span>

<span data-ttu-id="b2eb8-257">A seconda del contesto in cui è stata eseguita una dichiarazione di membro posizionate, sono consentiti solo determinati tipi di accessibilità dichiarata.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-257">Depending on the context in which a member declaration takes place, only certain types of declared accessibility are permitted.</span></span> <span data-ttu-id="b2eb8-258">Inoltre, quando una dichiarazione di membro non include tutti i modificatori di accesso, il contesto in cui viene eseguita la dichiarazione determina l'impostazione predefinita l'accessibilità dichiarata.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-258">Furthermore, when a member declaration does not include any access modifiers, the context in which the declaration takes place determines the default declared accessibility.</span></span>

*  <span data-ttu-id="b2eb8-259">Gli spazi dei nomi dispongono implicitamente `public` l'accessibilità dichiarata.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-259">Namespaces implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="b2eb8-260">Nessun modificatore di accesso sono consentito su dichiarazioni dello spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-260">No access modifiers are allowed on namespace declarations.</span></span>
*  <span data-ttu-id="b2eb8-261">I tipi dichiarati in unità di compilazione o gli spazi dei nomi possono avere `public` oppure `internal` l'accessibilità dichiarata per impostazione predefinita a `internal` l'accessibilità dichiarata.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-261">Types declared in compilation units or namespaces can have `public` or `internal` declared accessibility and default to `internal` declared accessibility.</span></span>
*  <span data-ttu-id="b2eb8-262">I membri di classe possono avere uno dei cinque tipi di accessibilità dichiarata e per impostazione predefinita `private` l'accessibilità dichiarata.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-262">Class members can have any of the five kinds of declared accessibility and default to `private` declared accessibility.</span></span> <span data-ttu-id="b2eb8-263">(Si noti che il tipo dichiarato come un membro di una classe può avere uno dei cinque tipi di accessibilità dichiarata, mentre il tipo dichiarato come un membro di uno spazio dei nomi può avere solo `public` o `internal` l'accessibilità dichiarata.)</span><span class="sxs-lookup"><span data-stu-id="b2eb8-263">(Note that a type declared as a member of a class can have any of the five kinds of declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="b2eb8-264">I membri struct possono avere `public`, `internal`, o `private` l'accessibilità dichiarata per impostazione predefinita a `private` l'accessibilità dichiarata poiché gli struct sono sealed in modo implicito.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-264">Struct members can have `public`, `internal`, or `private` declared accessibility and default to `private` declared accessibility because structs are implicitly sealed.</span></span> <span data-ttu-id="b2eb8-265">I membri struct introdotti in una struttura (ovvero, non è ereditata da tale struct) non possono avere `protected` o `protected internal` l'accessibilità dichiarata.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-265">Struct members introduced in a struct (that is, not inherited by that struct) cannot have `protected` or `protected internal` declared accessibility.</span></span> <span data-ttu-id="b2eb8-266">(Si noti che il tipo dichiarato come un membro di uno struct può avere `public`, `internal`, o `private` dichiarato accessibilità, mentre il tipo dichiarato come un membro di uno spazio dei nomi può avere solo `public` o `internal` l'accessibilità dichiarata.)</span><span class="sxs-lookup"><span data-stu-id="b2eb8-266">(Note that a type declared as a member of a struct can have `public`, `internal`, or `private` declared accessibility, whereas a type declared as a member of a namespace can have only `public` or `internal` declared accessibility.)</span></span>
*  <span data-ttu-id="b2eb8-267">I membri di interfaccia dispongono implicitamente `public` l'accessibilità dichiarata.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-267">Interface members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="b2eb8-268">Nessun modificatore di accesso sono consentito su dichiarazioni di membro di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-268">No access modifiers are allowed on interface member declarations.</span></span>
*  <span data-ttu-id="b2eb8-269">I membri dell'enumerazione dispongono implicitamente `public` l'accessibilità dichiarata.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-269">Enumeration members implicitly have `public` declared accessibility.</span></span> <span data-ttu-id="b2eb8-270">Nessun modificatore di accesso sono consentito su dichiarazioni di membro di enumerazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-270">No access modifiers are allowed on enumeration member declarations.</span></span>

### <a name="accessibility-domains"></a><span data-ttu-id="b2eb8-271">Domini di accessibilità</span><span class="sxs-lookup"><span data-stu-id="b2eb8-271">Accessibility domains</span></span>

<span data-ttu-id="b2eb8-272">Il ***dominio di accessibilità*** di un membro include le sezioni di testo di programma in cui è consentito l'accesso al membro (probabilmente non contigui).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-272">The ***accessibility domain*** of a member consists of the (possibly disjoint) sections of program text in which access to the member is permitted.</span></span> <span data-ttu-id="b2eb8-273">Ai fini della definizione del dominio di accessibilità di un membro, viene definito un membro ***principale*** se non è dichiarato all'interno di un tipo e un membro viene detto ***nidificata*** se è dichiarata all'interno di un altro tipo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-273">For purposes of defining the accessibility domain of a member, a member is said to be ***top-level*** if it is not declared within a type, and a member is said to be ***nested*** if it is declared within another type.</span></span> <span data-ttu-id="b2eb8-274">Inoltre, il ***testo di programma*** di un programma viene definito come tutti i programmi contenuto in tutti i file di origine del programma di testo e il testo di un tipo di programma viene definito come tutti i programmi contenuto nel testo di *type_declaration*s di quel tipo (inclusi gli eventuali tipi annidati all'interno del tipo).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-274">Furthermore, the ***program text*** of a program is defined as all program text contained in all source files of the program, and the program text of a type is defined as all program text contained in the *type_declaration*s of that type (including, possibly, types that are nested within the type).</span></span>

<span data-ttu-id="b2eb8-275">Il dominio di accessibilità di un tipo predefinito (ad esempio `object`, `int`, o `double`) è illimitato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-275">The accessibility domain of a predefined type (such as `object`, `int`, or `double`) is unlimited.</span></span>

<span data-ttu-id="b2eb8-276">Tipo non associato di dominio di accessibilità di un livello superiore `T` ([associate e non associato tipi](types.md#bound-and-unbound-types)) che viene dichiarato in un programma `P` viene definito come segue:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-276">The accessibility domain of a top-level unbound type `T` ([Bound and unbound types](types.md#bound-and-unbound-types)) that is declared in a program `P` is defined as follows:</span></span>

*  <span data-ttu-id="b2eb8-277">Se l'accessibilità dichiarata di `T` viene `public`, il dominio di accessibilità `T` è il testo del programma `P` e qualsiasi programma che fa riferimento a `P`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-277">If the declared accessibility of `T` is `public`, the accessibility domain of `T` is the program text of `P` and any program that references `P`.</span></span>
*  <span data-ttu-id="b2eb8-278">Se l'accessibilità dichiarata di `T` è `internal`, il dominio di accessibilità di `T` è il testo di programma di `P`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-278">If the declared accessibility of `T` is `internal`, the accessibility domain of `T` is the program text of `P`.</span></span>

<span data-ttu-id="b2eb8-279">Da queste definizioni si deduce che il dominio di accessibilità di un tipo non associato di primo livello sia sempre almeno il testo di programma del programma in cui tale tipo viene dichiarato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-279">From these definitions it follows that the accessibility domain of a top-level unbound type is always at least the program text of the program in which that type is declared.</span></span>

<span data-ttu-id="b2eb8-280">Il dominio di accessibilità per un tipo costruito `T<A1, ..., An>` rappresenta l'intersezione del dominio di accessibilità del tipo generico non associato `T` e i domini di accessibilità di argomenti di tipo `A1, ..., An`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-280">The accessibility domain for a constructed type `T<A1, ..., An>` is the intersection of the accessibility domain of the unbound generic type `T` and the accessibility domains of the type arguments `A1, ..., An`.</span></span>

<span data-ttu-id="b2eb8-281">Il dominio di accessibilità di un membro annidato `M` dichiarati nel tipo `T` all'interno di un programma `P` viene definito come segue (notare che `M` potrebbe eventualmente essere un tipo):</span><span class="sxs-lookup"><span data-stu-id="b2eb8-281">The accessibility domain of a nested member `M` declared in a type `T` within a program `P` is defined as follows (noting that `M` itself may possibly be a type):</span></span>

*  <span data-ttu-id="b2eb8-282">Se l'accessibilità dichiarata di `M` è `public`, il dominio di accessibilità di `M` è il dominio di accessibilità di `T`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-282">If the declared accessibility of `M` is `public`, the accessibility domain of `M` is the accessibility domain of `T`.</span></span>
*  <span data-ttu-id="b2eb8-283">Se l'accessibilità dichiarata di `M` viene `protected internal`, consentono `D` l'unione del testo del programma `P` e il testo di programma di qualsiasi tipo derivato da `T`, che viene dichiarato all'esterno `P`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-283">If the declared accessibility of `M` is `protected internal`, let `D` be the union of the program text of `P` and the program text of any type derived from `T`, which is declared outside `P`.</span></span> <span data-ttu-id="b2eb8-284">Il dominio di accessibilità `M` rappresenta l'intersezione tra il dominio di accessibilità `T` con `D`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-284">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="b2eb8-285">Se l'accessibilità dichiarata di `M` viene `protected`, consentono `D` essere l'unione tra il testo del programma `T` e il testo di programma di qualsiasi tipo derivato da `T`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-285">If the declared accessibility of `M` is `protected`, let `D` be the union of the program text of `T` and the program text of any type derived from `T`.</span></span> <span data-ttu-id="b2eb8-286">Il dominio di accessibilità `M` rappresenta l'intersezione tra il dominio di accessibilità `T` con `D`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-286">The accessibility domain of `M` is the intersection of the accessibility domain of `T` with `D`.</span></span>
*  <span data-ttu-id="b2eb8-287">Se l'accessibilità dichiarata di `M` è `internal`, il dominio di accessibilità di `M` è l'intersezione del dominio di accessibilità di `T` con il testo di programma di `P`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-287">If the declared accessibility of `M` is `internal`, the accessibility domain of `M` is the intersection of the accessibility domain of `T` with the program text of `P`.</span></span>
*  <span data-ttu-id="b2eb8-288">Se l'accessibilità dichiarata di `M` è `private`, il dominio di accessibilità di `M` è il testo di programma di `T`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-288">If the declared accessibility of `M` is `private`, the accessibility domain of `M` is the program text of `T`.</span></span>

<span data-ttu-id="b2eb8-289">Da queste definizioni si deduce che il dominio di accessibilità di un membro annidato è sempre almeno il testo di programma del tipo in cui viene dichiarato il membro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-289">From these definitions it follows that the accessibility domain of a nested member is always at least the program text of the type in which the member is declared.</span></span> <span data-ttu-id="b2eb8-290">Inoltre, ne consegue che il dominio di accessibilità di un membro non è mai più inclusivo rispetto al dominio di accessibilità del tipo in cui viene dichiarato il membro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-290">Furthermore, it follows that the accessibility domain of a member is never more inclusive than the accessibility domain of the type in which the member is declared.</span></span>

<span data-ttu-id="b2eb8-291">In pratica, quando un tipo o membro `M` è accessibile, la procedura seguente viene valutata per assicurarsi che l'accesso è consentito:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-291">In intuitive terms, when a type or member `M` is accessed, the following steps are evaluated to ensure that the access is permitted:</span></span>

*  <span data-ttu-id="b2eb8-292">Innanzitutto, se `M` dichiarata all'interno di un tipo (come anziché un'unità di compilazione o uno spazio dei nomi), si verifica un errore in fase di compilazione se tale tipo non è accessibile.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-292">First, if `M` is declared within a type (as opposed to a compilation unit or a namespace), a compile-time error occurs if that type is not accessible.</span></span>
*  <span data-ttu-id="b2eb8-293">Quindi, se `M` è `public`, l'accesso è consentito.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-293">Then, if `M` is `public`, the access is permitted.</span></span>
*  <span data-ttu-id="b2eb8-294">In caso contrario, se `M` viene `protected internal`, l'accesso è consentito se si verifica all'interno del programma in cui `M` viene dichiarata, o se si verifica all'interno di una classe derivata dalla classe in cui `M` viene dichiarata e viene eseguita tramite la derivata tipo di classe ([protetto, ad esempio accedere a membri](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-294">Otherwise, if `M` is `protected internal`, the access is permitted if it occurs within the program in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="b2eb8-295">In caso contrario, se `M` viene `protected`, l'accesso è consentito se si verifica all'interno della classe in cui `M` viene dichiarata, o se si verifica all'interno di una classe derivata dalla classe in cui `M` viene dichiarata e viene eseguita tramite la derivata tipo di classe ([protetto, ad esempio accedere a membri](basic-concepts.md#protected-access-for-instance-members)).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-295">Otherwise, if `M` is `protected`, the access is permitted if it occurs within the class in which `M` is declared, or if it occurs within a class derived from the class in which `M` is declared and takes place through the derived class type ([Protected access for instance members](basic-concepts.md#protected-access-for-instance-members)).</span></span>
*  <span data-ttu-id="b2eb8-296">In caso contrario, se `M` viene `internal`, l'accesso è consentito se si verifica all'interno del programma in cui `M` viene dichiarato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-296">Otherwise, if `M` is `internal`, the access is permitted if it occurs within the program in which `M` is declared.</span></span>
*  <span data-ttu-id="b2eb8-297">In caso contrario, se `M` viene `private`, l'accesso è consentito se si verifica all'interno del tipo in cui `M` viene dichiarato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-297">Otherwise, if `M` is `private`, the access is permitted if it occurs within the type in which `M` is declared.</span></span>
*  <span data-ttu-id="b2eb8-298">In caso contrario, il tipo o membro è accessibile e si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-298">Otherwise, the type or member is inaccessible, and a compile-time error occurs.</span></span>

<span data-ttu-id="b2eb8-299">Nell'esempio</span><span class="sxs-lookup"><span data-stu-id="b2eb8-299">In the example</span></span>
```csharp
public class A
{
    public static int X;
    internal static int Y;
    private static int Z;
}

internal class B
{
    public static int X;
    internal static int Y;
    private static int Z;

    public class C
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }

    private class D
    {
        public static int X;
        internal static int Y;
        private static int Z;
    }
}
```
<span data-ttu-id="b2eb8-300">le classi e membri sono i domini di accessibilità seguenti:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-300">the classes and members have the following accessibility domains:</span></span>

*  <span data-ttu-id="b2eb8-301">Il dominio di accessibilità `A` e `A.X` è illimitato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-301">The accessibility domain of `A` and `A.X` is unlimited.</span></span>
*  <span data-ttu-id="b2eb8-302">Il dominio di accessibilità `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`, e `B.C.Y` è il testo di programma del programma che lo contiene.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-302">The accessibility domain of `A.Y`, `B`, `B.X`, `B.Y`, `B.C`, `B.C.X`, and `B.C.Y` is the program text of the containing program.</span></span>
*  <span data-ttu-id="b2eb8-303">Il dominio di accessibilità `A.Z` è il testo del programma `A`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-303">The accessibility domain of `A.Z` is the program text of `A`.</span></span>
*  <span data-ttu-id="b2eb8-304">Il dominio di accessibilità `B.Z` e `B.D` è il testo del programma `B`, incluso il testo del programma `B.C` e `B.D`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-304">The accessibility domain of `B.Z` and `B.D` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="b2eb8-305">Il dominio di accessibilità `B.C.Z` è il testo del programma `B.C`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-305">The accessibility domain of `B.C.Z` is the program text of `B.C`.</span></span>
*  <span data-ttu-id="b2eb8-306">Il dominio di accessibilità `B.D.X` e `B.D.Y` è il testo del programma `B`, incluso il testo del programma `B.C` e `B.D`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-306">The accessibility domain of `B.D.X` and `B.D.Y` is the program text of `B`, including the program text of `B.C` and `B.D`.</span></span>
*  <span data-ttu-id="b2eb8-307">Il dominio di accessibilità `B.D.Z` è il testo del programma `B.D`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-307">The accessibility domain of `B.D.Z` is the program text of `B.D`.</span></span>

<span data-ttu-id="b2eb8-308">Come illustrato nell'esempio, il dominio di accessibilità di un membro non è mai maggiore rispetto a quello di un tipo contenitore.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-308">As the example illustrates, the accessibility domain of a member is never larger than that of a containing type.</span></span> <span data-ttu-id="b2eb8-309">Ad esempio, anche se tutti i `X` i membri hanno accessibilità dichiarata pubblica, tutto tranne `A.X` hanno accessibilità domini che sono vincolati da un tipo che lo contiene.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-309">For example, even though all `X` members have public declared accessibility, all but `A.X` have accessibility domains that are constrained by a containing type.</span></span>

<span data-ttu-id="b2eb8-310">Come descritto in [membri](basic-concepts.md#members), tutti i membri di una classe di base, tranne ad esempio costruttori, distruttori e i costruttori statici, vengono ereditati dai tipi derivati.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-310">As described in [Members](basic-concepts.md#members), all members of a base class, except for instance constructors, destructors and static constructors, are inherited by derived types.</span></span> <span data-ttu-id="b2eb8-311">Ciò include anche ai membri privati di una classe base.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-311">This includes even private members of a base class.</span></span> <span data-ttu-id="b2eb8-312">Tuttavia, il dominio di accessibilità di un membro privato include solo il testo di programma del tipo in cui viene dichiarato il membro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-312">However, the accessibility domain of a private member includes only the program text of the type in which the member is declared.</span></span> <span data-ttu-id="b2eb8-313">Nell'esempio</span><span class="sxs-lookup"><span data-stu-id="b2eb8-313">In the example</span></span>
```csharp
class A
{
    int x;

    static void F(B b) {
        b.x = 1;        // Ok
    }
}

class B: A
{
    static void F(B b) {
        b.x = 1;        // Error, x not accessible
    }
}
```
<span data-ttu-id="b2eb8-314">il `B` classe eredita il membro privato `x` dal `A` classe.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-314">the `B` class inherits the private member `x` from the `A` class.</span></span> <span data-ttu-id="b2eb8-315">Poiché il membro è privato, sarà accessibile solo entro le *class_body* di `A`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-315">Because the member is private, it is only accessible within the *class_body* of `A`.</span></span> <span data-ttu-id="b2eb8-316">Di conseguenza, l'accesso al `b.x` ha esito positivo nel `A.F` metodo, ma non riesce nel `B.F` (metodo).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-316">Thus, the access to `b.x` succeeds in the `A.F` method, but fails in the `B.F` method.</span></span>

### <a name="protected-access-for-instance-members"></a><span data-ttu-id="b2eb8-317">Accesso protetto per i membri di istanza</span><span class="sxs-lookup"><span data-stu-id="b2eb8-317">Protected access for instance members</span></span>

<span data-ttu-id="b2eb8-318">Quando un `protected` membro di istanza viene eseguito all'esterno del testo di programma della classe in cui è dichiarata, e quando un `protected internal` membro di istanza viene eseguito all'esterno del testo di programma del programma in cui è dichiarata, l'accesso deve avvenire all'interno di un dichiarazione di classe che deriva dalla classe in cui è dichiarata.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-318">When a `protected` instance member is accessed outside the program text of the class in which it is declared, and when a `protected internal` instance member is accessed outside the program text of the program in which it is declared, the access must take place within a class declaration that derives from the class in which it is declared.</span></span> <span data-ttu-id="b2eb8-319">Inoltre, l'accesso è necessaria per sfruttare tramite un'istanza di quel tipo di classe derivata o di un tipo di classe costruita da quest'ultimo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-319">Furthermore, the access is required to take place through an instance of that derived class type or a class type constructed from it.</span></span> <span data-ttu-id="b2eb8-320">Questa restrizione impedisce l'accesso ai membri protetti delle altre classi derivate, anche quando i membri sono ereditati dalla stessa classe di base di una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-320">This restriction prevents one derived class from accessing protected members of other derived classes, even when the members are inherited from the same base class.</span></span>

<span data-ttu-id="b2eb8-321">Let `B` da una classe di base che dichiara un membro di istanza protetta `M`e consentire `D` essere una classe che deriva da `B`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-321">Let `B` be a base class that declares a protected instance member `M`, and let `D` be a class that derives from `B`.</span></span> <span data-ttu-id="b2eb8-322">All'interno di *class_body* dei `D`, l'accesso a `M` può assumere uno dei formati seguenti:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-322">Within the *class_body* of `D`, access to `M` can take one of the following forms:</span></span>

*  <span data-ttu-id="b2eb8-323">Un non qualificato *type_name* oppure *primary_expression* nel formato `M`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-323">An unqualified *type_name* or *primary_expression* of the form `M`.</span></span>
*  <span data-ttu-id="b2eb8-324">Oggetto *primary_expression* del form `E.M`, purché il tipo di `E` viene `T` o una classe derivata da `T`, dove `T` è il tipo di classe `D`, o un tipo di classe creato da `D`</span><span class="sxs-lookup"><span data-stu-id="b2eb8-324">A *primary_expression* of the form `E.M`, provided the type of `E` is `T` or a class derived from `T`, where `T` is the class type `D`, or a class type constructed from `D`</span></span>
*  <span data-ttu-id="b2eb8-325">Oggetto *primary_expression* del form `base.M`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-325">A *primary_expression* of the form `base.M`.</span></span>

<span data-ttu-id="b2eb8-326">Oltre a questi tipi di accesso, una classe derivata può accedere a un costruttore di istanza protetta di una classe base in un *constructor_initializer* ([inizializzatori del costruttore](classes.md#constructor-initializers)).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-326">In addition to these forms of access, a derived class can access a protected instance constructor of a base class in a *constructor_initializer* ([Constructor initializers](classes.md#constructor-initializers)).</span></span>

<span data-ttu-id="b2eb8-327">Nell'esempio</span><span class="sxs-lookup"><span data-stu-id="b2eb8-327">In the example</span></span>
```csharp
public class A
{
    protected int x;

    static void F(A a, B b) {
        a.x = 1;        // Ok
        b.x = 1;        // Ok
    }
}

public class B: A
{
    static void F(A a, B b) {
        a.x = 1;        // Error, must access through instance of B
        b.x = 1;        // Ok
    }
}
```
<span data-ttu-id="b2eb8-328">all'interno `A`, è possibile accedere `x` tramite le istanze di entrambe `A` e `B`, dal momento che in entrambi i casi l'accesso avviene tramite un'istanza di `A` o una classe derivata da `A`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-328">within `A`, it is possible to access `x` through instances of both `A` and `B`, since in either case the access takes place through an instance of `A` or a class derived from `A`.</span></span> <span data-ttu-id="b2eb8-329">Tuttavia, all'interno `B`, non è possibile accedere ai `x` tramite un'istanza del `A`, poiché `A` non deriva da `B`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-329">However, within `B`, it is not possible to access `x` through an instance of `A`, since `A` does not derive from `B`.</span></span>

<span data-ttu-id="b2eb8-330">Nell'esempio</span><span class="sxs-lookup"><span data-stu-id="b2eb8-330">In the example</span></span>
```csharp
class C<T>
{
    protected T x;
}

class D<T>: C<T>
{
    static void F() {
        D<T> dt = new D<T>();
        D<int> di = new D<int>();
        D<string> ds = new D<string>();
        dt.x = default(T);
        di.x = 123;
        ds.x = "test";
    }
}
```
<span data-ttu-id="b2eb8-331">le assegnazioni a tre `x` sono consentite perché vengono eseguite tramite le istanze di tipi di classe costruiti dal tipo generico.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-331">the three assignments to `x` are permitted because they all take place through instances of class types constructed from the generic type.</span></span>

### <a name="accessibility-constraints"></a><span data-ttu-id="b2eb8-332">Vincoli di accessibilità</span><span class="sxs-lookup"><span data-stu-id="b2eb8-332">Accessibility constraints</span></span>

<span data-ttu-id="b2eb8-333">Alcuni costrutti del linguaggio C# richiedono un tipo può essere ***accessibile almeno quanto come*** un membro o un altro tipo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-333">Several constructs in the C# language require a type to be ***at least as accessible as*** a member or another type.</span></span> <span data-ttu-id="b2eb8-334">Un tipo `T` viene definito per essere accessibili almeno quanto un tipo o membro `M` se il dominio di accessibilità `T` è un superset di dominio di accessibilità di `M`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-334">A type `T` is said to be at least as accessible as a member or type `M` if the accessibility domain of `T` is a superset of the accessibility domain of `M`.</span></span> <span data-ttu-id="b2eb8-335">In altre parole, `T` è accessibile almeno quanto come `M` se `T` accessibile in tutti i contesti in cui `M` è accessibile.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-335">In other words, `T` is at least as accessible as `M` if `T` is accessible in all contexts in which `M` is accessible.</span></span>

<span data-ttu-id="b2eb8-336">Sono disponibili i vincoli di accessibilità seguenti:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-336">The following accessibility constraints exist:</span></span>

*  <span data-ttu-id="b2eb8-337">La classe di base diretta di un tipo di classe deve essere accessibile almeno quanto il tipo di classe.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-337">The direct base class of a class type must be at least as accessible as the class type itself.</span></span>
*  <span data-ttu-id="b2eb8-338">Le interfacce di base esplicite di un tipo di interfaccia devono essere accessibili almeno quanto il tipo di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-338">The explicit base interfaces of an interface type must be at least as accessible as the interface type itself.</span></span>
*  <span data-ttu-id="b2eb8-339">Il tipo restituito e i tipi di parametro di un tipo delegato devono essere accessibili almeno quanto il tipo delegato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-339">The return type and parameter types of a delegate type must be at least as accessible as the delegate type itself.</span></span>
*  <span data-ttu-id="b2eb8-340">Il tipo di una costante deve essere accessibile almeno quanto la costante.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-340">The type of a constant must be at least as accessible as the constant itself.</span></span>
*  <span data-ttu-id="b2eb8-341">Il tipo di un campo deve essere accessibile almeno quanto il campo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-341">The type of a field must be at least as accessible as the field itself.</span></span>
*  <span data-ttu-id="b2eb8-342">Il tipo restituito e i tipi di parametro di un metodo devono essere accessibili almeno quanto il metodo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-342">The return type and parameter types of a method must be at least as accessible as the method itself.</span></span>
*  <span data-ttu-id="b2eb8-343">Il tipo di una proprietà deve essere accessibile almeno quanto la proprietà.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-343">The type of a property must be at least as accessible as the property itself.</span></span>
*  <span data-ttu-id="b2eb8-344">Il tipo di un evento deve essere accessibile almeno quanto l'evento.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-344">The type of an event must be at least as accessible as the event itself.</span></span>
*  <span data-ttu-id="b2eb8-345">Il tipo e i tipi di parametro di un indicizzatore devono essere accessibili almeno quanto l'indicizzatore.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-345">The type and parameter types of an indexer must be at least as accessible as the indexer itself.</span></span>
*  <span data-ttu-id="b2eb8-346">Il tipo restituito e i tipi di parametro di un operatore devono essere accessibili almeno quanto l'operatore.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-346">The return type and parameter types of an operator must be at least as accessible as the operator itself.</span></span>
*  <span data-ttu-id="b2eb8-347">I tipi di parametro di un costruttore di istanza devono essere accessibili almeno quanto il costruttore di istanza.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-347">The parameter types of an instance constructor must be at least as accessible as the instance constructor itself.</span></span>

<span data-ttu-id="b2eb8-348">Nell'esempio</span><span class="sxs-lookup"><span data-stu-id="b2eb8-348">In the example</span></span>
```csharp
class A {...}

public class B: A {...}
```
<span data-ttu-id="b2eb8-349">il `B` classe genera un errore in fase di compilazione in quanto `A` non è accessibile almeno quanto come `B`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-349">the `B` class results in a compile-time error because `A` is not at least as accessible as `B`.</span></span>

<span data-ttu-id="b2eb8-350">Analogamente, nell'esempio</span><span class="sxs-lookup"><span data-stu-id="b2eb8-350">Likewise, in the example</span></span>
```csharp
class A {...}

public class B
{
    A F() {...}

    internal A G() {...}

    public A H() {...}
}
```
<span data-ttu-id="b2eb8-351">il `H` nel metodo `B` genera un errore in fase di compilazione perché il tipo restituito `A` non è accessibile almeno quanto il metodo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-351">the `H` method in `B` results in a compile-time error because the return type `A` is not at least as accessible as the method.</span></span>

## <a name="signatures-and-overloading"></a><span data-ttu-id="b2eb8-352">Firme e overload</span><span class="sxs-lookup"><span data-stu-id="b2eb8-352">Signatures and overloading</span></span>

<span data-ttu-id="b2eb8-353">I metodi, costruttori di istanza, indicizzatori e gli operatori sono caratterizzati da loro ***firme***:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-353">Methods, instance constructors, indexers, and operators are characterized by their ***signatures***:</span></span>

*  <span data-ttu-id="b2eb8-354">La firma di un metodo è costituito il nome del metodo, il numero di parametri di tipo e dal tipo (valore, riferimento o output) della ognuno dei parametri formali, considerati in ordine da sinistra a destra.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-354">The signature of a method consists of the name of the method, the number of type parameters and the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="b2eb8-355">A tale scopo, viene identificato qualsiasi parametro di tipo del metodo che si verifica nel tipo di un parametro formale non in base al nome, ma in base alla posizione ordinale nell'elenco di argomenti tipo del metodo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-355">For these purposes, any type parameter of the method that occurs in the type of a formal parameter is identified not by its name, but by its ordinal position in the type argument list of the method.</span></span> <span data-ttu-id="b2eb8-356">La firma di un metodo, in particolare, non include il tipo restituito, il `params` modificatore che può essere specificato per il parametro all'estrema destra, né i vincoli del parametro di tipo facoltativi.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-356">The signature of a method specifically does not include the return type, the `params` modifier that may be specified for the right-most parameter, nor the optional type parameter constraints.</span></span>
*  <span data-ttu-id="b2eb8-357">La firma di un costruttore di istanza è costituita dal tipo (valore, riferimento o output) della ognuno dei parametri formali, considerati in ordine da sinistra a destra.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-357">The signature of an instance constructor consists of the type and kind (value, reference, or output) of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="b2eb8-358">La firma di un costruttore di istanza, in particolare, non include il `params` modificatore che può essere specificato per il parametro più a destra.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-358">The signature of an instance constructor specifically does not include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="b2eb8-359">La firma di un indicizzatore è costituita dal tipo della ognuno dei parametri formali, considerati in ordine da sinistra a destra.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-359">The signature of an indexer consists of the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="b2eb8-360">La firma di un indicizzatore, in particolare, non include il tipo di elemento, né include la `params` modificatore che può essere specificato per il parametro più a destra.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-360">The signature of an indexer specifically does not include the element type, nor does it include the `params` modifier that may be specified for the right-most parameter.</span></span>
*  <span data-ttu-id="b2eb8-361">La firma di un operatore è costituito il nome dell'operatore e il tipo della ognuno dei parametri formali, considerati in ordine da sinistra a destra.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-361">The signature of an operator consists of the name of the operator and the type of each of its formal parameters, considered in the order left to right.</span></span> <span data-ttu-id="b2eb8-362">In particolare, la firma di un operatore non include il tipo di risultato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-362">The signature of an operator specifically does not include the result type.</span></span>

<span data-ttu-id="b2eb8-363">Le firme sono il meccanismo di attivazione per ***overload*** dei membri di classi, struct e interfacce:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-363">Signatures are the enabling mechanism for ***overloading*** of members in classes, structs, and interfaces:</span></span>

*  <span data-ttu-id="b2eb8-364">L'overload dei metodi consente a una classe, struct o interfaccia per dichiarare più metodi con lo stesso nome, purché le relative firme siano univoche all'interno di tale classe, struct o interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-364">Overloading of methods permits a class, struct, or interface to declare multiple methods with the same name, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="b2eb8-365">L'overload dei costruttori di istanza consente a una classe o struct per dichiarare più costruttori di istanza, purché le relative firme siano univoche all'interno di tale classe o struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-365">Overloading of instance constructors permits a class or struct to declare multiple instance constructors, provided their signatures are unique within that class or struct.</span></span>
*  <span data-ttu-id="b2eb8-366">L'overload di indicizzatori consente a una classe, struct o interfaccia per dichiarare più indicizzatori purché le relative firme siano univoche all'interno di tale classe, struct o interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-366">Overloading of indexers permits a class, struct, or interface to declare multiple indexers, provided their signatures are unique within that class, struct, or interface.</span></span>
*  <span data-ttu-id="b2eb8-367">Overload degli operatori consente a una classe o struct per dichiarare più operatori con lo stesso nome, purché le relative firme siano univoche all'interno di tale classe o struct.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-367">Overloading of operators permits a class or struct to declare multiple operators with the same name, provided their signatures are unique within that class or struct.</span></span>

<span data-ttu-id="b2eb8-368">Sebbene `out` e `ref` modificatori di parametro sono considerati parte di una firma, i membri dichiarati in un solo tipo non può essere diversa nella firma esclusivamente dalla `ref` e `out`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-368">Although `out` and `ref` parameter modifiers are considered part of a signature, members declared in a single type cannot differ in signature solely by `ref` and `out`.</span></span> <span data-ttu-id="b2eb8-369">Si verifica un errore in fase di compilazione se due membri vengono dichiarati nello stesso tipo con firme che sarebbe la stessa se tutti i parametri in entrambi i metodi con `out` modificatori sono stati modificati per `ref` modificatori.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-369">A compile-time error occurs if two members are declared in the same type with signatures that would be the same if all parameters in both methods with `out` modifiers were changed to `ref` modifiers.</span></span> <span data-ttu-id="b2eb8-370">Per altri scopi di firma corrispondente (ad esempio, nascondere o si esegue l'override), `ref` e `out` sono considerate parte della firma e non corrispondono tra loro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-370">For other purposes of signature matching (e.g., hiding or overriding), `ref` and `out` are considered part of the signature and do not match each other.</span></span> <span data-ttu-id="b2eb8-371">(Questa limitazione consiste nel consentire C# ai programmi di essere tradotta con facilità per l'esecuzione su di Common Language Infrastructure (CLI), che non fornisce un modo per definire metodi che differiscono unicamente nella `ref` e `out`.)</span><span class="sxs-lookup"><span data-stu-id="b2eb8-371">(This restriction is to allow C#  programs to be easily translated to run on the Common Language Infrastructure (CLI), which does not provide a way to define methods that differ solely in `ref` and `out`.)</span></span>

<span data-ttu-id="b2eb8-372">Ai fini di firme, i tipi `object` e `dynamic` sono considerati uguali.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-372">For the purposes of signatures, the types `object` and `dynamic` are considered the same.</span></span> <span data-ttu-id="b2eb8-373">I membri dichiarati in un unico tipo può essere pertanto non diverso nella firma esclusivamente dalla `object` e `dynamic`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-373">Members declared in a single type can therefore not differ in signature solely by `object` and `dynamic`.</span></span>

<span data-ttu-id="b2eb8-374">Nell'esempio seguente mostra un set di dichiarazioni di metodo di overload e le relative firme.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-374">The following example shows a set of overloaded method declarations along with their signatures.</span></span>
```csharp
interface ITest
{
    void F();                        // F()

    void F(int x);                   // F(int)

    void F(ref int x);               // F(ref int)

    void F(out int x);               // F(out int)      error

    void F(int x, int y);            // F(int, int)

    int F(string s);                 // F(string)

    int F(int x);                    // F(int)          error

    void F(string[] a);              // F(string[])

    void F(params string[] a);       // F(string[])     error
}
```

<span data-ttu-id="b2eb8-375">Si noti che eventuali `ref` e `out` modificatori di parametro ([i parametri del metodo](classes.md#method-parameters)) fanno parte di una firma.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-375">Note that any `ref` and `out` parameter modifiers ([Method parameters](classes.md#method-parameters)) are part of a signature.</span></span> <span data-ttu-id="b2eb8-376">Pertanto `F(int)` e `F(ref int)` sono firme univoche.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-376">Thus, `F(int)` and `F(ref int)` are unique signatures.</span></span> <span data-ttu-id="b2eb8-377">Tuttavia `F(ref int)` e `F(out int)` non possono essere dichiarati all'interno dell'interfaccia stessa, dal momento che differiscono dal `ref` e `out`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-377">However, `F(ref int)` and `F(out int)` cannot be declared within the same interface because their signatures differ solely by `ref` and `out`.</span></span> <span data-ttu-id="b2eb8-378">Inoltre, tenere presente che il tipo restituito e il `params` modificatore non fanno parte di una firma, pertanto non è possibile eseguire l'overload esclusivamente in base al tipo restituito o di inclusione o esclusione del `params` modificatore.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-378">Also, note that the return type and the `params` modifier are not part of a signature, so it is not possible to overload solely based on return type or on the inclusion or exclusion of the `params` modifier.</span></span> <span data-ttu-id="b2eb8-379">Pertanto, le dichiarazioni dei metodi `F(int)` e `F(params string[])` identificato in precedenza generano un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-379">As such, the declarations of the methods `F(int)` and `F(params string[])` identified above result in a compile-time error.</span></span>

## <a name="scopes"></a><span data-ttu-id="b2eb8-380">Ambiti</span><span class="sxs-lookup"><span data-stu-id="b2eb8-380">Scopes</span></span>

<span data-ttu-id="b2eb8-381">Il ***ambito*** è l'area di testo di programma all'interno del quale è possibile fare riferimento a entità dichiarata tramite il nome senza qualifica del nome di un nome.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-381">The ***scope*** of a name is the region of program text within which it is possible to refer to the entity declared by the name without qualification of the name.</span></span> <span data-ttu-id="b2eb8-382">Gli ambiti possono essere ***nidificata***, e un ambito interno possa dichiarare di nuovo il significato di un nome da un ambito esterno (questa operazione non, tuttavia, rimuove la restrizione imposta dal [dichiarazioni](basic-concepts.md#declarations) che all'interno di un blocco annidato non è è possibile eseguire per dichiarare una variabile locale con lo stesso nome come una variabile locale in un blocco di inclusione).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-382">Scopes can be ***nested***, and an inner scope may redeclare the meaning of a name from an outer scope (this does not, however, remove the restriction imposed by [Declarations](basic-concepts.md#declarations) that within a nested block it is not possible to declare a local variable with the same name as a local variable in an enclosing block).</span></span> <span data-ttu-id="b2eb8-383">Il nome utilizzato nell'ambito esterno viene quindi definito ***nascosto*** nell'area del programma di testo coperto da ambito interno e l'accesso per il nome esterno è solo possibile qualificando il nome.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-383">The name from the outer scope is then said to be ***hidden*** in the region of program text covered by the inner scope, and access to the outer name is only possible by qualifying the name.</span></span>

*  <span data-ttu-id="b2eb8-384">L'ambito di un membro dello spazio dei nomi dichiarato tramite un *namespace_member_declaration* ([membri Namespace](namespaces.md#namespace-members)) con alcun tipo di inclusione *namespace_declaration* è l'intero programma testo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-384">The scope of a namespace member declared by a *namespace_member_declaration* ([Namespace members](namespaces.md#namespace-members)) with no enclosing *namespace_declaration* is the entire program text.</span></span>
*  <span data-ttu-id="b2eb8-385">L'ambito di un membro dello spazio dei nomi dichiarato tramite un *namespace_member_declaration* all'interno di un *namespace_declaration* il cui nome completo è `N` è il *namespace_body*  di ogni *namespace_declaration* il cui nome completo è `N` o inizia con `N`, seguito da un punto.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-385">The scope of a namespace member declared by a *namespace_member_declaration* within a *namespace_declaration* whose fully qualified name is `N` is the *namespace_body* of every *namespace_declaration* whose fully qualified name is `N` or starts with `N`, followed by a period.</span></span>
*  <span data-ttu-id="b2eb8-386">L'ambito del nome definito da un *extern_alias_directive* consente di estendere tramite il *using_directive*s, *global_attributes* e *namespace_member_ dichiarazione*s della relativa compilazione unità oppure lo spazio dei nomi nel corpo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-386">The scope of name defined by an *extern_alias_directive* extends over the *using_directive*s, *global_attributes* and *namespace_member_declaration*s of its immediately containing compilation unit or namespace body.</span></span> <span data-ttu-id="b2eb8-387">Un' *extern_alias_directive* non include alcun nuovo membro allo spazio di dichiarazione sottostante.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-387">An *extern_alias_directive* does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="b2eb8-388">In altre parole, un' *extern_alias_directive* non è transitiva, ma, invece, interessa solo la compilazione unità oppure lo spazio dei nomi del corpo in cui si verifica.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-388">In other words, an *extern_alias_directive* is not transitive, but, rather, affects only the compilation unit or namespace body in which it occurs.</span></span>
*  <span data-ttu-id="b2eb8-389">L'ambito di un nome definito né importato da un *using_directive* ([direttive Using](namespaces.md#using-directives)) si estende il *namespace_member_declaration*s del  *compilation_unit* oppure *namespace_body* in cui il *using_directive* si verifica.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-389">The scope of a name defined or imported by a *using_directive* ([Using directives](namespaces.md#using-directives)) extends over the *namespace_member_declaration*s of the *compilation_unit* or *namespace_body* in which the *using_directive* occurs.</span></span> <span data-ttu-id="b2eb8-390">Oggetto *using_directive* può rendere disponibili all'interno di un particolare oggetto zero o più nomi di spazio dei nomi, tipo o membro *compilation_unit* oppure *namespace_body*, ma non contribuire con nuovi membri allo spazio di dichiarazione sottostante.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-390">A *using_directive* may make zero or more namespace, type or member names available within a particular *compilation_unit* or *namespace_body*, but does not contribute any new members to the underlying declaration space.</span></span> <span data-ttu-id="b2eb8-391">In altre parole, una *using_directive* non è transitiva, ma piuttosto interessa solo le *compilation_unit* oppure *namespace_body* in cui si trova.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-391">In other words, a *using_directive* is not transitive but rather affects only the *compilation_unit* or *namespace_body* in which it occurs.</span></span>
*  <span data-ttu-id="b2eb8-392">L'ambito di un parametro di tipo dichiarato tramite un *type_parameter_list* in un *class_declaration* ([le dichiarazioni di classe](classes.md#class-declarations)) è il *class_base*, *type_parameter_constraints_clause*s, e *class_body* di tale *class_declaration*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-392">The scope of a type parameter declared by a *type_parameter_list* on a *class_declaration* ([Class declarations](classes.md#class-declarations)) is the *class_base*, *type_parameter_constraints_clause*s, and *class_body* of that *class_declaration*.</span></span>
*  <span data-ttu-id="b2eb8-393">L'ambito di un parametro di tipo dichiarato tramite un *type_parameter_list* in un *struct_declaration* ([dichiarazioni Struct](structs.md#struct-declarations)) è il *struct_interfaces* , *type_parameter_constraints_clause*s, e *struct_body* di tale *struct_declaration*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-393">The scope of a type parameter declared by a *type_parameter_list* on a *struct_declaration* ([Struct declarations](structs.md#struct-declarations)) is the *struct_interfaces*, *type_parameter_constraints_clause*s, and *struct_body* of that *struct_declaration*.</span></span>
*  <span data-ttu-id="b2eb8-394">L'ambito di un parametro di tipo dichiarato tramite un *type_parameter_list* in un *interface_declaration* ([dichiarazioni di interfaccia](interfaces.md#interface-declarations)) è il *interface_base* , *type_parameter_constraints_clause*s, e *interface_body* di tale *interface_declaration*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-394">The scope of a type parameter declared by a *type_parameter_list* on an *interface_declaration* ([Interface declarations](interfaces.md#interface-declarations)) is the *interface_base*, *type_parameter_constraints_clause*s, and *interface_body* of that *interface_declaration*.</span></span>
*  <span data-ttu-id="b2eb8-395">L'ambito di un parametro di tipo dichiarato tramite un *type_parameter_list* in un *delegate_declaration* ([dichiarazioni Delegate](delegates.md#delegate-declarations)) è il *return_type*, *formal_parameter_list*, e *type_parameter_constraints_clause*s di tale *delegate_declaration*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-395">The scope of a type parameter declared by a *type_parameter_list* on a *delegate_declaration* ([Delegate declarations](delegates.md#delegate-declarations)) is the *return_type*, *formal_parameter_list*, and *type_parameter_constraints_clause*s of that *delegate_declaration*.</span></span>
*  <span data-ttu-id="b2eb8-396">L'ambito di un membro dichiarato tramite un *class_member_declaration* ([classe corpo](classes.md#class-body)) è la *class_body* in cui si trova la dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-396">The scope of a member declared by a *class_member_declaration* ([Class body](classes.md#class-body)) is the *class_body* in which the declaration occurs.</span></span> <span data-ttu-id="b2eb8-397">Inoltre, l'ambito di un membro di classe si estende per il *class_body* di tali classi derivate che sono inclusi nel dominio di accessibilità ([domini accessibilità](basic-concepts.md#accessibility-domains)) del membro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-397">In addition, the scope of a class member extends to the *class_body* of those derived classes that are included in the accessibility domain ([Accessibility domains](basic-concepts.md#accessibility-domains)) of the member.</span></span>
*  <span data-ttu-id="b2eb8-398">L'ambito di un membro dichiarato tramite un *struct_member_declaration* ([i membri Struct](structs.md#struct-members)) è la *struct_body* in cui si trova la dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-398">The scope of a member declared by a *struct_member_declaration* ([Struct members](structs.md#struct-members)) is the *struct_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="b2eb8-399">L'ambito di un membro dichiarato tramite un *enum_member_declaration* ([membri Enum](enums.md#enum-members)) è la *enum_body* in cui si trova la dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-399">The scope of a member declared by an *enum_member_declaration*  ([Enum members](enums.md#enum-members)) is the *enum_body* in which the declaration occurs.</span></span>
*  <span data-ttu-id="b2eb8-400">L'ambito di un parametro dichiarato in un *method_declaration* ([metodi](classes.md#methods)) è la *method_body* ciò *method_declaration*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-400">The scope of a parameter declared in a *method_declaration* ([Methods](classes.md#methods)) is the *method_body* of that *method_declaration*.</span></span>
*  <span data-ttu-id="b2eb8-401">L'ambito di un parametro dichiarato in un' *indexer_declaration* ([indicizzatori](classes.md#indexers)) è la *accessor_declarations* ciò *indexer_declaration*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-401">The scope of a parameter declared in an *indexer_declaration* ([Indexers](classes.md#indexers)) is the *accessor_declarations* of that *indexer_declaration*.</span></span>
*  <span data-ttu-id="b2eb8-402">L'ambito di un parametro dichiarato in un' *operator_declaration* ([operatori](classes.md#operators)) è la *blocco* di tale *operator_declaration*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-402">The scope of a parameter declared in an *operator_declaration* ([Operators](classes.md#operators)) is the *block* of that *operator_declaration*.</span></span>
*  <span data-ttu-id="b2eb8-403">L'ambito di un parametro dichiarato in un *constructor_declaration* ([costruttori di istanze](classes.md#instance-constructors)) è la *constructor_initializer* e *blocco* ciò *constructor_declaration*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-403">The scope of a parameter declared in a *constructor_declaration* ([Instance constructors](classes.md#instance-constructors)) is the *constructor_initializer* and *block* of that *constructor_declaration*.</span></span>
*  <span data-ttu-id="b2eb8-404">L'ambito di un parametro dichiarato in un *lambda_expression* ([espressioni di funzioni anonime](expressions.md#anonymous-function-expressions)) è la *anonymous_function_body* ciò *lambda_ espressione*</span><span class="sxs-lookup"><span data-stu-id="b2eb8-404">The scope of a parameter declared in a *lambda_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *anonymous_function_body* of that *lambda_expression*</span></span>
*  <span data-ttu-id="b2eb8-405">L'ambito di un parametro dichiarato in un' *anonymous_method_expression* ([espressioni di funzioni anonime](expressions.md#anonymous-function-expressions)) è la *blocco* ciò *anonymous_method _expression*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-405">The scope of a parameter declared in an *anonymous_method_expression* ([Anonymous function expressions](expressions.md#anonymous-function-expressions)) is the *block* of that *anonymous_method_expression*.</span></span>
*  <span data-ttu-id="b2eb8-406">L'ambito di un'etichetta dichiarati in un *labeled_statement* ([con etichetta istruzioni](statements.md#labeled-statements)) è la *blocco* in cui si trova la dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-406">The scope of a label declared in a *labeled_statement* ([Labeled statements](statements.md#labeled-statements)) is the *block* in which the declaration occurs.</span></span>
*  <span data-ttu-id="b2eb8-407">L'ambito di una variabile locale dichiarata un *local_variable_declaration* ([dichiarazioni di variabili locali](statements.md#local-variable-declarations)) è il blocco in cui si trova la dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-407">The scope of a local variable declared in a *local_variable_declaration* ([Local variable declarations](statements.md#local-variable-declarations)) is the block in which the declaration occurs.</span></span>
*  <span data-ttu-id="b2eb8-408">L'ambito di una variabile locale dichiarata un *switch_block* di un `switch` istruzione ([istruzione switch](statements.md#the-switch-statement)) è il *switch_block*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-408">The scope of a local variable declared in a *switch_block* of a `switch` statement ([The switch statement](statements.md#the-switch-statement)) is the *switch_block*.</span></span>
*  <span data-ttu-id="b2eb8-409">L'ambito di una variabile locale dichiarata un *for_initializer* di un `for` istruzione ([i per l'istruzione](statements.md#the-for-statement)) è il *for_initializer*, la  *for_condition*, il *for_iterator*e i contenuti *istruzione* del `for` istruzione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-409">The scope of a local variable declared in a *for_initializer* of a `for` statement ([The for statement](statements.md#the-for-statement)) is the *for_initializer*, the *for_condition*, the *for_iterator*, and the contained *statement* of the `for` statement.</span></span>
*  <span data-ttu-id="b2eb8-410">L'ambito di una costante locale dichiarato in un *local_constant_declaration* ([dichiarazioni locali costante](statements.md#local-constant-declarations)) è il blocco in cui si trova la dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-410">The scope of a local constant declared in a *local_constant_declaration* ([Local constant declarations](statements.md#local-constant-declarations)) is the block in which the declaration occurs.</span></span> <span data-ttu-id="b2eb8-411">Tratta di un errore in fase di compilazione per fare riferimento a una costante locale in una posizione di testo che precede relativi *constant_declarator*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-411">It is a compile-time error to refer to a local constant in a textual position that precedes its *constant_declarator*.</span></span>
*  <span data-ttu-id="b2eb8-412">L'ambito di una variabile dichiarata come parte di un *foreach_statement*, *using_statement*, *lock_statement* oppure *query_expression* è determinato dall'espansione del costrutto specifico.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-412">The scope of a variable declared as part of a *foreach_statement*, *using_statement*, *lock_statement* or *query_expression* is determined by the expansion of the given construct.</span></span>

<span data-ttu-id="b2eb8-413">All'interno dell'ambito di un membro dello spazio dei nomi, classe, struct o enumerazione è possibile fare riferimento al membro in una posizione di testo che precede la dichiarazione del membro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-413">Within the scope of a namespace, class, struct, or enumeration member it is possible to refer to the member in a textual position that precedes the declaration of the member.</span></span> <span data-ttu-id="b2eb8-414">Esempio:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-414">For example</span></span>
```csharp
class A
{
    void F() {
        i = 1;
    }

    int i = 0;
}
```
<span data-ttu-id="b2eb8-415">In questo caso, è valido per `F` per fare riferimento a `i` prima che sia dichiarata.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-415">Here, it is valid for `F` to refer to `i` before it is declared.</span></span>

<span data-ttu-id="b2eb8-416">Nell'ambito di una variabile locale, è un errore in fase di compilazione per fare riferimento alla variabile locale in una posizione di testo che precede il *local_variable_declarator* della variabile locale.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-416">Within the scope of a local variable, it is a compile-time error to refer to the local variable in a textual position that precedes the *local_variable_declarator* of the local variable.</span></span> <span data-ttu-id="b2eb8-417">Esempio:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-417">For example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        i = 1;                  // Error, use precedes declaration
        int i;
        i = 2;
    }

    void G() {
        int j = (j = 1);        // Valid
    }

    void H() {
        int a = 1, b = ++a;    // Valid
    }
}
```

<span data-ttu-id="b2eb8-418">Nel `F` metodo precedente, la prima assegnazione a `i` non fa riferimento al campo dichiarato nell'ambito esterno.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-418">In the `F` method above, the first assignment to `i` specifically does not refer to the field declared in the outer scope.</span></span> <span data-ttu-id="b2eb8-419">Invece, fa riferimento alla variabile locale e generato un errore in fase di compilazione poiché testualmente precede la dichiarazione della variabile.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-419">Rather, it refers to the local variable and it results in a compile-time error because it textually precedes the declaration of the variable.</span></span> <span data-ttu-id="b2eb8-420">Nel `G` metodo, l'uso del `j` nell'inizializzatore per la dichiarazione di `j` è valido perché l'uso non precede la *local_variable_declarator*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-420">In the `G` method, the use of `j` in the initializer for the declaration of `j` is valid because the use does not precede the *local_variable_declarator*.</span></span> <span data-ttu-id="b2eb8-421">Nel `H` metodo, una successiva *local_variable_declarator* correttamente fa riferimento a una variabile locale dichiarata in una sessione *local_variable_declarator* all'interno della stessa  *local_variable_declaration*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-421">In the `H` method, a subsequent *local_variable_declarator* correctly refers to a local variable declared in an earlier *local_variable_declarator* within the same *local_variable_declaration*.</span></span>

<span data-ttu-id="b2eb8-422">Le regole di ambito per le variabili locali sono progettate per garantire che il significato di un nome usato nel contesto di un'espressione è sempre lo stesso all'interno di un blocco.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-422">The scoping rules for local variables are designed to guarantee that the meaning of a name used in an expression context is always the same within a block.</span></span> <span data-ttu-id="b2eb8-423">Se l'ambito di una variabile locale per estendere solo dalla relativa dichiarazione alla fine del blocco, quindi nell'esempio precedente, è necessario assegnare la prima assegnazione alla variabile di istanza e la seconda assegnazione è necessario assegnare alla variabile locale, causando eventualmente errori di compilazione se fosse successive riordinare le istruzioni del blocco.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-423">If the scope of a local variable were to extend only from its declaration to the end of the block, then in the example above, the first assignment would assign to the instance variable and the second assignment would assign to the local variable, possibly leading to compile-time errors if the statements of the block were later to be rearranged.</span></span>

<span data-ttu-id="b2eb8-424">Il significato di un nome all'interno di un blocco può variare in base al contesto in cui viene utilizzato il nome.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-424">The meaning of a name within a block may differ based on the context in which the name is used.</span></span> <span data-ttu-id="b2eb8-425">Nell'esempio</span><span class="sxs-lookup"><span data-stu-id="b2eb8-425">In the example</span></span>
```csharp
using System;

class A {}

class Test
{
    static void Main() {
        string A = "hello, world";
        string s = A;                            // expression context

        Type t = typeof(A);                      // type context

        Console.WriteLine(s);                    // writes "hello, world"
        Console.WriteLine(t);                    // writes "A"
    }
}
```
<span data-ttu-id="b2eb8-426">il nome `A` viene usato nel contesto di un'espressione per fare riferimento alla variabile locale `A` e in un contesto di tipo per fare riferimento alla classe `A`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-426">the name `A` is used in an expression context to refer to the local variable `A` and in a type context to refer to the class `A`.</span></span>

### <a name="name-hiding"></a><span data-ttu-id="b2eb8-427">Nascondere il nome</span><span class="sxs-lookup"><span data-stu-id="b2eb8-427">Name hiding</span></span>

<span data-ttu-id="b2eb8-428">L'ambito di un'entità include in genere più testo di programma rispetto allo spazio di dichiarazione dell'entità.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-428">The scope of an entity typically encompasses more program text than the declaration space of the entity.</span></span> <span data-ttu-id="b2eb8-429">In particolare, l'ambito di un'entità può includere dichiarazioni che introducono nuovi spazi di dichiarazione che contiene le entità con lo stesso nome.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-429">In particular, the scope of an entity may include declarations that introduce new declaration spaces containing entities of the same name.</span></span> <span data-ttu-id="b2eb8-430">Tali dichiarazioni rendono l'entità originale diventare ***nascosto***.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-430">Such declarations cause the original entity to become ***hidden***.</span></span> <span data-ttu-id="b2eb8-431">Per contro, un'entità è detta ***visibile*** quando non è nascosto.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-431">Conversely, an entity is said to be ***visible*** when it is not hidden.</span></span>

<span data-ttu-id="b2eb8-432">Nascondere il nome si verifica quando si sovrappongono ambiti mediante l'annidamento e quando gli ambiti si sovrappongono attraverso l'ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-432">Name hiding occurs when scopes overlap through nesting and when scopes overlap through inheritance.</span></span> <span data-ttu-id="b2eb8-433">Nelle sezioni seguenti vengono descritte le caratteristiche dei due tipi di mascheramento.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-433">The characteristics of the two types of hiding are described in the following sections.</span></span>

#### <a name="hiding-through-nesting"></a><span data-ttu-id="b2eb8-434">Disattivazione della visualizzazione tramite l'annidamento</span><span class="sxs-lookup"><span data-stu-id="b2eb8-434">Hiding through nesting</span></span>

<span data-ttu-id="b2eb8-435">Un nome nascosto tramite annidamento può verificarsi a causa di annidamento degli spazi dei nomi o tipi all'interno di spazi dei nomi, come risultato di annidamento dei tipi all'interno di classi o struct e in seguito a parametro e dichiarazioni di variabile locale.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-435">Name hiding through nesting can occur as a result of nesting namespaces or types within namespaces, as a result of nesting types within classes or structs, and as a result of parameter and local variable declarations.</span></span>

<span data-ttu-id="b2eb8-436">Nell'esempio</span><span class="sxs-lookup"><span data-stu-id="b2eb8-436">In the example</span></span>
```csharp
class A
{
    int i = 0;

    void F() {
        int i = 1;
    }

    void G() {
        i = 1;
    }
}
```
<span data-ttu-id="b2eb8-437">all'interno di `F` metodo, la variabile di istanza `i` è nascosto per la variabile locale `i`, ma entro la `G` metodo, `i` fa ancora riferimento alla variabile di istanza.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-437">within the `F` method, the instance variable `i` is hidden by the local variable `i`, but within the `G` method, `i` still refers to the instance variable.</span></span>

<span data-ttu-id="b2eb8-438">Quando un nome in un ambito interno nasconde un nome in un ambito esterno, nasconde tutte le occorrenze di overload di tale nome.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-438">When a name in an inner scope hides a name in an outer scope, it hides all overloaded occurrences of that name.</span></span> <span data-ttu-id="b2eb8-439">Nell'esempio</span><span class="sxs-lookup"><span data-stu-id="b2eb8-439">In the example</span></span>
```csharp
class Outer
{
    static void F(int i) {}

    static void F(string s) {}

    class Inner
    {
        void G() {
            F(1);              // Invokes Outer.Inner.F
            F("Hello");        // Error
        }

        static void F(long l) {}
    }
}
```
<span data-ttu-id="b2eb8-440">la chiamata `F(1)` richiama il `F` dichiarato in `Inner` perché tutte le occorrenze esterne di `F` sono nascosti dalla dichiarazione interna.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-440">the call `F(1)` invokes the `F` declared in `Inner` because all outer occurrences of `F` are hidden by the inner declaration.</span></span> <span data-ttu-id="b2eb8-441">Per lo stesso motivo, la chiamata `F("Hello")` genera un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-441">For the same reason, the call `F("Hello")` results in a compile-time error.</span></span>

#### <a name="hiding-through-inheritance"></a><span data-ttu-id="b2eb8-442">Nascosto tramite ereditarietà</span><span class="sxs-lookup"><span data-stu-id="b2eb8-442">Hiding through inheritance</span></span>

<span data-ttu-id="b2eb8-443">Un nome nascosto tramite ereditarietà si verifica quando le classi o struct dichiarare nuovamente i nomi di quelli ereditati dalle classi di base.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-443">Name hiding through inheritance occurs when classes or structs redeclare names that were inherited from base classes.</span></span> <span data-ttu-id="b2eb8-444">Questo tipo di nascondere il nome accetta uno dei formati seguenti:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-444">This type of name hiding takes one of the following forms:</span></span>

*  <span data-ttu-id="b2eb8-445">Una costante, campo, proprietà, eventi o tipo introdotto in una classe o uno struct nasconde tutti i membri di classe di base con lo stesso nome.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-445">A constant, field, property, event, or type introduced in a class or struct hides all base class members with the same name.</span></span>
*  <span data-ttu-id="b2eb8-446">Un metodo inserito in una classe o uno struct nasconde tutti i membri di classe di base non metodo con lo stesso nome e tutti i metodi della classe base con la stessa firma (nome del metodo e numero di parametri, i modificatori e tipi).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-446">A method introduced in a class or struct hides all non-method base class members with the same name, and all base class methods with the same signature (method name and parameter count, modifiers, and types).</span></span>
*  <span data-ttu-id="b2eb8-447">Un indicizzatore inserito in una classe o uno struct nasconde tutti gli indicizzatori di classe di base con la stessa firma (numero di parametri e tipi).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-447">An indexer introduced in a class or struct hides all base class indexers with the same signature (parameter count and types).</span></span>

<span data-ttu-id="b2eb8-448">Le regole che controllano le dichiarazioni di operatore ([operatori](classes.md#operators)) rende impossibile per una classe derivata dichiarare un operatore con la stessa firma di un operatore in una classe di base.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-448">The rules governing operator declarations ([Operators](classes.md#operators)) make it impossible for a derived class to declare an operator with the same signature as an operator in a base class.</span></span> <span data-ttu-id="b2eb8-449">Di conseguenza, gli operatori non è mai nascondono tra loro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-449">Thus, operators never hide one another.</span></span>

<span data-ttu-id="b2eb8-450">Contrariamente a nascondere un nome da un ambito esterno, se si nasconde un nome accessibile da un ambito ereditato genera un avviso da segnalare.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-450">Contrary to hiding a name from an outer scope, hiding an accessible name from an inherited scope causes a warning to be reported.</span></span> <span data-ttu-id="b2eb8-451">Nell'esempio</span><span class="sxs-lookup"><span data-stu-id="b2eb8-451">In the example</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    public void F() {}        // Warning, hiding an inherited name
}
```
<span data-ttu-id="b2eb8-452">la dichiarazione di `F` in `Derived` genera un avviso da segnalare.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-452">the declaration of `F` in `Derived` causes a warning to be reported.</span></span> <span data-ttu-id="b2eb8-453">Nascondere un nome ereditato in particolare non è un errore, in quanto verrebbe preclusa evoluzione separata di classi di base.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-453">Hiding an inherited name is specifically not an error, since that would preclude separate evolution of base classes.</span></span> <span data-ttu-id="b2eb8-454">Ad esempio, la situazione precedente potrebbe essersi verificata perché una versione successiva di `Base` introdotta un' `F` metodo che non era presente in una versione precedente della classe.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-454">For example, the above situation might have come about because a later version of `Base` introduced an `F` method that wasn't present in an earlier version of the class.</span></span> <span data-ttu-id="b2eb8-455">La situazione precedente fosse stata un errore, quindi eventuali modifiche apportate a una classe base in una libreria di classi con controllo delle versioni separatamente potrebbe potenzialmente causare alle classi derivate di diventano non validi.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-455">Had the above situation been an error, then any change made to a base class in a separately versioned class library could potentially cause derived classes to become invalid.</span></span>

<span data-ttu-id="b2eb8-456">Avviso restituito da nascondere un nome ereditato può essere eliminata tramite l'uso del `new` modificatore:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-456">The warning caused by hiding an inherited name can be eliminated through use of the `new` modifier:</span></span>
```csharp
class Base
{
    public void F() {}
}

class Derived: Base
{
    new public void F() {}
}
```

<span data-ttu-id="b2eb8-457">Il `new` modificatore indica che il `F` in `Derived` è "new" e che in effetti consente di nascondere il membro ereditato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-457">The `new` modifier indicates that the `F` in `Derived` is "new", and that it is indeed intended to hide the inherited member.</span></span>

<span data-ttu-id="b2eb8-458">Una dichiarazione di un nuovo membro nasconde un membro ereditato solo all'interno dell'ambito del nuovo membro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-458">A declaration of a new member hides an inherited member only within the scope of the new member.</span></span>

```csharp
class Base
{
    public static void F() {}
}

class Derived: Base
{
    new private static void F() {}    // Hides Base.F in Derived only
}

class MoreDerived: Derived
{
    static void G() { F(); }          // Invokes Base.F
}
```

<span data-ttu-id="b2eb8-459">Nell'esempio precedente, la dichiarazione di `F` in `Derived` nasconde il `F` che è stata ereditata da `Base`, ma, poiché il nuovo `F` in `Derived` con accesso privato, l'ambito non si estende a `MoreDerived` .</span><span class="sxs-lookup"><span data-stu-id="b2eb8-459">In the example above, the declaration of `F` in `Derived` hides the `F` that was inherited from `Base`, but since the new `F` in `Derived` has private access, its scope does not extend to `MoreDerived`.</span></span> <span data-ttu-id="b2eb8-460">Di conseguenza, la chiamata `F()` nelle `MoreDerived.G` valido e richiamerà `Base.F`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-460">Thus, the call `F()` in `MoreDerived.G` is valid and will invoke `Base.F`.</span></span>

## <a name="namespace-and-type-names"></a><span data-ttu-id="b2eb8-461">Namespace e dei tipi</span><span class="sxs-lookup"><span data-stu-id="b2eb8-461">Namespace and type names</span></span>

<span data-ttu-id="b2eb8-462">Contesti diversi in un C# programma richiede una *namespace_name* o un *type_name* specificare.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-462">Several contexts in a C# program require a *namespace_name* or a *type_name* to be specified.</span></span>

```antlr
namespace_name
    : namespace_or_type_name
    ;

type_name
    : namespace_or_type_name
    ;

namespace_or_type_name
    : identifier type_argument_list?
    | namespace_or_type_name '.' identifier type_argument_list?
    | qualified_alias_member
    ;
```

<span data-ttu-id="b2eb8-463">Oggetto *namespace_name* è un *namespace_or_type_name* che fa riferimento a uno spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-463">A *namespace_name* is a *namespace_or_type_name* that refers to a namespace.</span></span> <span data-ttu-id="b2eb8-464">Come descritto di seguito, il *namespace_or_type_name* di un *namespace_name* deve fare riferimento a uno spazio dei nomi, o in caso contrario, verrà generato un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-464">Following resolution as described below, the *namespace_or_type_name* of a *namespace_name* must refer to a namespace, or otherwise a compile-time error occurs.</span></span> <span data-ttu-id="b2eb8-465">Nessun argomento di tipo ([gli argomenti di tipo](types.md#type-arguments)) possono essere presenti in un *namespace_name* (solo i tipi possono avere argomenti tipo).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-465">No type arguments ([Type arguments](types.md#type-arguments)) can be present in a *namespace_name* (only types can have type arguments).</span></span>

<span data-ttu-id="b2eb8-466">Oggetto *type_name* è un *namespace_or_type_name* che fa riferimento a un tipo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-466">A *type_name* is a *namespace_or_type_name* that refers to a type.</span></span> <span data-ttu-id="b2eb8-467">Come descritto di seguito, il *namespace_or_type_name* di un *type_name* deve fare riferimento a un tipo, o in caso contrario, verrà generato un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-467">Following resolution as described below, the *namespace_or_type_name* of a *type_name* must refer to a type, or otherwise a compile-time error occurs.</span></span>

<span data-ttu-id="b2eb8-468">Se il *namespace_or_type_name* è qualificato-alias-membro relativo significato è, come descritto [qualificatori di alias Namespace](namespaces.md#namespace-alias-qualifiers).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-468">If the *namespace_or_type_name* is a qualified-alias-member its meaning is as described in [Namespace alias qualifiers](namespaces.md#namespace-alias-qualifiers).</span></span> <span data-ttu-id="b2eb8-469">In caso contrario, un *namespace_or_type_name* dispone di una delle quattro forme:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-469">Otherwise, a *namespace_or_type_name* has one of four forms:</span></span>

*  `I`
*  `I<A1, ..., Ak>`
*  `N.I`
*  `N.I<A1, ..., Ak>`

<span data-ttu-id="b2eb8-470">in cui `I` è un identificatore singolo `N` è un *namespace_or_type_name* e `<A1, ..., Ak>` è facoltativo *type_argument_list*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-470">where `I` is a single identifier, `N` is a *namespace_or_type_name* and `<A1, ..., Ak>` is an optional *type_argument_list*.</span></span> <span data-ttu-id="b2eb8-471">Se non si specifica *type_argument_list* è specificato, prendere in considerazione `k` sia pari a zero.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-471">When no *type_argument_list* is specified, consider `k` to be zero.</span></span>

<span data-ttu-id="b2eb8-472">Il significato di un *namespace_or_type_name* viene determinata come segue:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-472">The meaning of a *namespace_or_type_name* is determined as follows:</span></span>

*   <span data-ttu-id="b2eb8-473">Se il *namespace_or_type_name* è nel formato `I` o del form `I<A1, ..., Ak>`:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-473">If the *namespace_or_type_name* is of the form `I` or of the form `I<A1, ..., Ak>`:</span></span>
    * <span data-ttu-id="b2eb8-474">Se `K` è uguale a zero e il *namespace_or_type_name* viene visualizzato all'interno di una dichiarazione di metodo generico ([metodi](classes.md#methods)) e se tale dichiarazione include un parametro di tipo ([tipo i parametri](classes.md#type-parameters)) con nome `I`, il *namespace_or_type_name* fa riferimento a tale parametro di tipo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-474">If `K` is zero and the *namespace_or_type_name* appears within a generic method declaration ([Methods](classes.md#methods)) and if that declaration includes a type parameter ([Type parameters](classes.md#type-parameters)) with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
    * <span data-ttu-id="b2eb8-475">In caso contrario, se il *namespace_or_type_name* viene visualizzato all'interno di una dichiarazione del tipo, quindi per ogni tipo di istanza `T` ([il tipo di istanza](classes.md#the-instance-type)), che inizia con il tipo di istanza di tale tipo dichiarazione e continuare con il tipo di istanza di ogni dichiarazione di classe o struct che lo contiene (se presente):</span><span class="sxs-lookup"><span data-stu-id="b2eb8-475">Otherwise, if the *namespace_or_type_name* appears within a type declaration, then for each instance type `T` ([The instance type](classes.md#the-instance-type)), starting with the instance type of that type declaration and continuing with the instance type of each enclosing class or struct declaration (if any):</span></span>
        * <span data-ttu-id="b2eb8-476">Se `K` è zero e la dichiarazione di `T` include un parametro di tipo con nome `I`, quindi il *namespace_or_type_name* fa riferimento a tale parametro di tipo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-476">If `K` is zero and the declaration of `T` includes a type parameter with name `I`, then the *namespace_or_type_name* refers to that type parameter.</span></span>
        * <span data-ttu-id="b2eb8-477">In caso contrario, se il *namespace_or_type_name* viene visualizzato all'interno del corpo della dichiarazione del tipo, e `T` o uno qualsiasi dei tipi di base contiene un tipo annidato accessibile con nome `I` e `K`  parametri di tipo, il *namespace_or_type_name* fa riferimento a tale tipo costruito con gli argomenti di tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-477">Otherwise, if the *namespace_or_type_name* appears within the body of the type declaration, and `T` or any of its base types contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="b2eb8-478">Se è presente più di un tale tipo, viene selezionato il tipo dichiarato all'interno del tipo più derivato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-478">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="b2eb8-479">Si noti che i membri non di tipo (le costanti, campi, metodi, proprietà, indicizzatori, operatori, costruttori di istanze, distruttori e i costruttori statici) e i membri dei tipi con un numero diverso di parametri di tipo vengono ignorati quando si determina il significato del *namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-479">Note that non-type members (constants, fields, methods, properties, indexers, operators, instance constructors, destructors, and static constructors) and type members with a different number of type parameters are ignored when determining the meaning of the *namespace_or_type_name*.</span></span>
    * <span data-ttu-id="b2eb8-480">Se i passaggi precedenti hanno avuto esito positivo, per ogni spazio dei nomi `N`, che inizia con lo spazio dei nomi in cui la *namespace_or_type_name* si verifica, procedere con ogni spazio dei nomi contenitore (se presente) e terminando con il spazio dei nomi globale, la procedura seguente viene valutata fino a quando non viene individuata un'entità:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-480">If the previous steps were unsuccessful then, for each namespace `N`, starting with the namespace in which the *namespace_or_type_name* occurs, continuing with each enclosing namespace (if any), and ending with the global namespace, the following steps are evaluated until an entity is located:</span></span>
        * <span data-ttu-id="b2eb8-481">Se `K` è uguale a zero e `I` è il nome di uno spazio dei nomi in `N`, quindi:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-481">If `K` is zero and `I` is the name of a namespace in `N`, then:</span></span>
            * <span data-ttu-id="b2eb8-482">Se la posizione in cui il *namespace_or_type_name* si verifica è racchiuso da una dichiarazione dello spazio dei nomi per `N` e la dichiarazione dello spazio dei nomi contiene un' *extern_alias_directive* o*using_alias_directive* che associa il nome `I` con uno spazio dei nomi o un tipo, il *namespace_or_type_name* è ambiguo e si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-482">If the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="b2eb8-483">In caso contrario, il *namespace_or_type_name* fa riferimento allo spazio dei nomi denominato `I` in `N`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-483">Otherwise, the *namespace_or_type_name* refers to the namespace named `I` in `N`.</span></span>
        * <span data-ttu-id="b2eb8-484">In caso contrario, se `N` contiene un tipo accessibile con nome `I` e `K`  parametri di tipo, quindi:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-484">Otherwise, if `N` contains an accessible type having name `I` and `K` type parameters, then:</span></span>
            * <span data-ttu-id="b2eb8-485">Se `K` è zero e il percorso in cui la *namespace_or_type_name* si verifica è racchiuso da una dichiarazione dello spazio dei nomi per `N` e la dichiarazione dello spazio dei nomi contiene un *extern_alias_directive*  oppure *using_alias_directive* che associa il nome `I` con uno spazio dei nomi o un tipo, il *namespace_or_type_name* è ambiguo e una fase di compilazione si verifica l'errore.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-485">If `K` is zero and the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N` and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with a namespace or type, then the *namespace_or_type_name* is ambiguous and a compile-time error occurs.</span></span>
            * <span data-ttu-id="b2eb8-486">In caso contrario, il *namespace_or_type_name* fa riferimento al tipo costruito con gli argomenti di tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-486">Otherwise, the *namespace_or_type_name* refers to the type constructed with the given type arguments.</span></span>
        * <span data-ttu-id="b2eb8-487">In caso contrario, se la posizione in cui il *namespace_or_type_name* si verifica è racchiuso da una dichiarazione dello spazio dei nomi per `N`:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-487">Otherwise, if the location where the *namespace_or_type_name* occurs is enclosed by a namespace declaration for `N`:</span></span>
            * <span data-ttu-id="b2eb8-488">Se `K` è uguale a zero e la dichiarazione dello spazio dei nomi contiene un *extern_alias_directive* oppure *using_alias_directive* che associa il nome `I` con uno spazio dei nomi importato o tipo, il *namespace_or_type_name* fa riferimento a tale spazio dei nomi o tipo.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-488">If `K` is zero and the namespace declaration contains an *extern_alias_directive* or *using_alias_directive* that associates the name `I` with an imported namespace or type, then the *namespace_or_type_name* refers to that namespace or type.</span></span>
            * <span data-ttu-id="b2eb8-489">In caso contrario, se le dichiarazioni degli spazi dei nomi e il tipo importato per la *using_namespace_directive*s e *using_alias_directive*s della dichiarazione dello spazio dei nomi contiene esattamente un tipo accessibile con nome `I` e `K`  parametri di tipo, il *namespace_or_type_name* fa riferimento a tale tipo costruito con gli argomenti di tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-489">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain exactly one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
            * <span data-ttu-id="b2eb8-490">In caso contrario, se le dichiarazioni degli spazi dei nomi e il tipo importato per la *using_namespace_directive*s e *using_alias_directive*s della dichiarazione dello spazio dei nomi contiene più di un tipo accessibile con nome `I` e `K`  parametri di tipo, il *namespace_or_type_name* è ambiguo e si verifica un errore.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-490">Otherwise, if the namespaces and type declarations imported by the *using_namespace_directive*s and *using_alias_directive*s of the namespace declaration contain more than one accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* is ambiguous and an error occurs.</span></span>
    * <span data-ttu-id="b2eb8-491">In caso contrario, il *namespace_or_type_name* è non definito e si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-491">Otherwise, the *namespace_or_type_name* is undefined and a compile-time error occurs.</span></span>
*  <span data-ttu-id="b2eb8-492">In caso contrario, il *namespace_or_type_name* è nel formato `N.I` o del form `N.I<A1, ..., Ak>`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-492">Otherwise, the *namespace_or_type_name* is of the form `N.I` or of the form `N.I<A1, ..., Ak>`.</span></span> <span data-ttu-id="b2eb8-493">`N` viene prima risolto come un *namespace_or_type_name*.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-493">`N` is first resolved as a *namespace_or_type_name*.</span></span> <span data-ttu-id="b2eb8-494">Se la risoluzione di `N` non ha esito positivo, si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-494">If the resolution of `N` is not successful, a compile-time error occurs.</span></span> <span data-ttu-id="b2eb8-495">In caso contrario, `N.I` o `N.I<A1, ..., Ak>` viene risolto come segue:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-495">Otherwise, `N.I` or `N.I<A1, ..., Ak>` is resolved as follows:</span></span>
    * <span data-ttu-id="b2eb8-496">Se `K` è uguale a zero e `N` fa riferimento a uno spazio dei nomi e `N` contiene uno spazio dei nomi annidato con nome `I`, il *namespace_or_type_name* fa riferimento allo spazio dei nomi annidato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-496">If `K` is zero and `N` refers to a namespace and `N` contains a nested namespace with name `I`, then the *namespace_or_type_name* refers to that nested namespace.</span></span>
    * <span data-ttu-id="b2eb8-497">In caso contrario, se `N` fa riferimento a uno spazio dei nomi e `N` contiene un tipo accessibile con nome `I` e `K`  parametri di tipo, il *namespace_or_type_name* fa riferimento a tale tipo costruito con gli argomenti di tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-497">Otherwise, if `N` refers to a namespace and `N` contains an accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span>
    * <span data-ttu-id="b2eb8-498">In caso contrario, se `N` fa riferimento a un tipo di classe o struct (possibilmente costruito) e `N` o una delle relative classi di base contiene un tipo annidato accessibile con nome `I` e `K`  digitare i parametri, quindi il *namespace_or_type_name* fa riferimento a tale tipo costruito con gli argomenti di tipo specificato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-498">Otherwise, if `N` refers to a (possibly constructed) class or struct type and `N` or any of its base classes contain a nested accessible type having name `I` and `K` type parameters, then the *namespace_or_type_name* refers to that type constructed with the given type arguments.</span></span> <span data-ttu-id="b2eb8-499">Se è presente più di un tale tipo, viene selezionato il tipo dichiarato all'interno del tipo più derivato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-499">If there is more than one such type, the type declared within the more derived type is selected.</span></span> <span data-ttu-id="b2eb8-500">Si noti che se il significato dei `N.I` determinare come parte di risolvere la specifica della classe base `N` quindi la classe base diretta `N` viene considerato come un oggetto ([classi di Base](classes.md#base-classes)).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-500">Note that if the meaning of `N.I` is being determined as part of resolving the base class specification of `N` then the direct base class of `N` is considered to be object ([Base classes](classes.md#base-classes)).</span></span>
    * <span data-ttu-id="b2eb8-501">In caso contrario, `N.I` è un valore non valido *namespace_or_type_name*, e si verifica un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-501">Otherwise, `N.I` is an invalid *namespace_or_type_name*, and a compile-time error occurs.</span></span>

<span data-ttu-id="b2eb8-502">Oggetto *namespace_or_type_name* è la possibilità di fare riferimento a una classe statica ([classi statiche](classes.md#static-classes)) solo se</span><span class="sxs-lookup"><span data-stu-id="b2eb8-502">A *namespace_or_type_name* is permitted to reference a static class ([Static classes](classes.md#static-classes)) only if</span></span>

*  <span data-ttu-id="b2eb8-503">Il *namespace_or_type_name* è la `T` in un *namespace_or_type_name* del form `T.I`, o</span><span class="sxs-lookup"><span data-stu-id="b2eb8-503">The *namespace_or_type_name* is the `T` in a *namespace_or_type_name* of the form `T.I`, or</span></span>
*  <span data-ttu-id="b2eb8-504">Il *namespace_or_type_name* è la `T` in un *typeof_expression* ([elenchi di argomenti](expressions.md#argument-lists)1) nel formato `typeof(T)`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-504">The *namespace_or_type_name* is the `T` in a *typeof_expression* ([Argument lists](expressions.md#argument-lists)1) of the form `typeof(T)`.</span></span>

### <a name="fully-qualified-names"></a><span data-ttu-id="b2eb8-505">Nomi completi</span><span class="sxs-lookup"><span data-stu-id="b2eb8-505">Fully qualified names</span></span>

<span data-ttu-id="b2eb8-506">Ogni spazio dei nomi e il tipo ha un ***nome completo***, che identifica in modo univoco il tipo tra tutti gli altri utenti o dello spazio dei nomi.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-506">Every namespace and type has a ***fully qualified name***, which uniquely identifies the namespace or type amongst all others.</span></span> <span data-ttu-id="b2eb8-507">Il nome completo di un tipo o dello spazio dei nomi `N` viene determinata come segue:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-507">The fully qualified name of a namespace or type `N` is determined as follows:</span></span>

*  <span data-ttu-id="b2eb8-508">Se `N` è un membro dello spazio dei nomi globali, il nome completo è `N`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-508">If `N` is a member of the global namespace, its fully qualified name is `N`.</span></span>
*  <span data-ttu-id="b2eb8-509">In caso contrario, il nome completo è `S.N`, dove `S` è il nome completo dello spazio dei nomi o tipo in cui `N` viene dichiarato.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-509">Otherwise, its fully qualified name is `S.N`, where `S` is the fully qualified name of the namespace or type in which `N` is declared.</span></span>

<span data-ttu-id="b2eb8-510">In altre parole, il nome completo del `N` è il percorso gerarchico completo degli identificatori che portano a `N`, a partire dallo spazio dei nomi globale.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-510">In other words, the fully qualified name of `N` is the complete hierarchical path of identifiers that lead to `N`, starting from the global namespace.</span></span> <span data-ttu-id="b2eb8-511">Poiché ogni membro di un tipo o dello spazio dei nomi deve avere un nome univoco, ne consegue che il nome completo di un tipo o dello spazio dei nomi sia sempre univoco.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-511">Because every member of a namespace or type must have a unique name, it follows that the fully qualified name of a namespace or type is always unique.</span></span>

<span data-ttu-id="b2eb8-512">L'esempio seguente illustra diverse dichiarazioni dello spazio dei nomi e tipo di insieme ai rispettivi nomi associate nome completi.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-512">The example below shows several namespace and type declarations along with their associated fully qualified names.</span></span>
```csharp
class A {}                // A

namespace X               // X
{
    class B               // X.B
    {
        class C {}        // X.B.C
    }

    namespace Y           // X.Y
    {
        class D {}        // X.Y.D
    }
}

namespace X.Y             // X.Y
{
    class E {}            // X.Y.E
}
```

## <a name="automatic-memory-management"></a><span data-ttu-id="b2eb8-513">Gestione automatica della memoria</span><span class="sxs-lookup"><span data-stu-id="b2eb8-513">Automatic memory management</span></span>

<span data-ttu-id="b2eb8-514">C# usa la gestione automatica della memoria, che libera gli sviluppatori da allocare e liberare la memoria occupata dagli oggetti manualmente.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-514">C# employs automatic memory management, which frees developers from manually allocating and freeing the memory occupied by objects.</span></span> <span data-ttu-id="b2eb8-515">I criteri di gestione automatica della memoria vengono implementati da una ***garbage collector***.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-515">Automatic memory management policies are implemented by a ***garbage collector***.</span></span> <span data-ttu-id="b2eb8-516">Il ciclo di vita di gestione della memoria di un oggetto è come segue:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-516">The memory management life cycle of an object is as follows:</span></span>

1. <span data-ttu-id="b2eb8-517">Quando viene creato l'oggetto, di memoria allocata per il costruttore viene eseguito e l'oggetto viene considerato in tempo reale.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-517">When the object is created, memory is allocated for it, the constructor is run, and the object is considered live.</span></span>
2. <span data-ttu-id="b2eb8-518">Se l'oggetto, o parte di esso, non è accessibile da qualsiasi possibile continuazione dell'esecuzione, sia l'esecuzione dei distruttori, l'oggetto viene considerato non più in uso e diventa idoneo per l'eliminazione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-518">If the object, or any part of it, cannot be accessed by any possible continuation of execution, other than the running of destructors, the object is considered no longer in use, and it becomes eligible for destruction.</span></span> <span data-ttu-id="b2eb8-519">Il compilatore C# e il garbage collector potrebbe scegliere di analizzare il codice per determinare che fa riferimento a un oggetto può essere usato in futuro.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-519">The C# compiler and the garbage collector may choose to analyze code to determine which references to an object may be used in the future.</span></span> <span data-ttu-id="b2eb8-520">Ad esempio, se una variabile locale che si trova nell'ambito è l'unico riferimento a un oggetto, ma tale variabile locale non viene mai al punto della procedura qualsiasi possibile continuazione dell'esecuzione dell'esecuzione corrente, il garbage collector può (ma non è obbligatorio per) trattare l'oggetto come non più in uso.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-520">For instance, if a local variable that is in scope is the only existing reference to an object, but that local variable is never referred to in any possible continuation of execution from the current execution point in the procedure, the garbage collector may (but is not required to) treat the object as no longer in use.</span></span>
3. <span data-ttu-id="b2eb8-521">Una volta che l'oggetto è idoneo per l'eliminazione, alcune non viene specificato in un secondo momento di tempo il distruttore ([distruttori](classes.md#destructors)) (se presente) per l'oggetto è in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-521">Once the object is eligible for destruction, at some unspecified later time the destructor ([Destructors](classes.md#destructors)) (if any) for the object is run.</span></span> <span data-ttu-id="b2eb8-522">In circostanze normali il distruttore per l'oggetto viene eseguito una sola volta, anche se API specifiche dell'implementazione possono consentire di eseguire l'override di questo comportamento.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-522">Under normal circumstances the destructor for the object is run once only, though implementation-specific APIs may allow this behavior to be overridden.</span></span>
4. <span data-ttu-id="b2eb8-523">Una volta che viene eseguito il distruttore per un oggetto, se tale oggetto, o parte di esso, non è accessibile da qualsiasi possibile continuazione dell'esecuzione, compresa l'esecuzione dei distruttori, dell'oggetto diventa inaccessibile e l'oggetto diventa idoneo per la raccolta.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-523">Once the destructor for an object is run, if that object, or any part of it, cannot be accessed by any possible continuation of execution, including the running of destructors, the object is considered inaccessible and the object becomes eligible for collection.</span></span>
5. <span data-ttu-id="b2eb8-524">Infine, in un momento dopo l'oggetto diventa idoneo per la raccolta, il garbage collector libera la memoria associata a quell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-524">Finally, at some time after the object becomes eligible for collection, the garbage collector frees the memory associated with that object.</span></span>

<span data-ttu-id="b2eb8-525">Il garbage collector mantiene le informazioni sull'uso degli oggetti e utilizza queste informazioni per prendere decisioni di gestione, di memoria, ad esempio la posizione in memoria per individuare un oggetto appena creato, quando per spostare un oggetto e, quando un oggetto non è più in uso o non accessibile.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-525">The garbage collector maintains information about object usage, and uses this information to make memory management decisions, such as where in memory to locate a newly created object, when to relocate an object, and when an object is no longer in use or inaccessible.</span></span>

<span data-ttu-id="b2eb8-526">Come altri linguaggi che presuppongono l'esistenza di un garbage collector, C# è progettato in modo che il garbage collector può implementare un'ampia gamma di criteri di gestione della memoria.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-526">Like other languages that assume the existence of a garbage collector, C# is designed so that the garbage collector may implement a wide range of memory management policies.</span></span> <span data-ttu-id="b2eb8-527">Ad esempio, C# non richiede che i distruttori eseguire o che gli oggetti raccolti, non appena sono idonei, o eseguire i distruttori in un ordine specifico, o in qualsiasi thread specifico.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-527">For instance, C# does not require that destructors be run or that objects be collected as soon as they are eligible, or that destructors be run in any particular order, or on any particular thread.</span></span>

<span data-ttu-id="b2eb8-528">Controllare il comportamento del garbage collector può essere in certa misura, tramite i metodi statici sulla classe `System.GC`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-528">The behavior of the garbage collector can be controlled, to some degree, via static methods on the class `System.GC`.</span></span> <span data-ttu-id="b2eb8-529">Questa classe può essere usata per richiedere una raccolta, occorre che i distruttori per essere eseguire (o meno) e così via.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-529">This class can be used to request a collection to occur, destructors to be run (or not run), and so forth.</span></span>

<span data-ttu-id="b2eb8-530">Poiché il garbage collector viene lasciato ampia scelta per decidere quando raccogliere oggetti ed eseguire i distruttori, un'implementazione conforme può produrre l'output è diverso da quello indicato dal codice seguente.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-530">Since the garbage collector is allowed wide latitude in deciding when to collect objects and run destructors, a conforming implementation may produce output that differs from that shown by the following code.</span></span> <span data-ttu-id="b2eb8-531">Il programma</span><span class="sxs-lookup"><span data-stu-id="b2eb8-531">The program</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }
}

class B
{
    object Ref;

    public B(object o) {
        Ref = o;
    }

    ~B() {
        Console.WriteLine("Destruct instance of B");
    }
}

class Test
{
    static void Main() {
        B b = new B(new A());
        b = null;
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}
```
<span data-ttu-id="b2eb8-532">Crea un'istanza della classe `A` e un'istanza della classe `B`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-532">creates an instance of class `A` and an instance of class `B`.</span></span> <span data-ttu-id="b2eb8-533">Questi oggetti diventano idonei per garbage collection quando la variabile `b` viene assegnato il valore `null`, poiché dopo questo periodo di tempo non è possibile per il codice scritto dall'utente per accedere a essi.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-533">These objects become eligible for garbage collection when the variable `b` is assigned the value `null`, since after this time it is impossible for any user-written code to access them.</span></span> <span data-ttu-id="b2eb8-534">L'output potrebbe essere</span><span class="sxs-lookup"><span data-stu-id="b2eb8-534">The output could be either</span></span>
```
Destruct instance of A
Destruct instance of B
```
<span data-ttu-id="b2eb8-535">oppure</span><span class="sxs-lookup"><span data-stu-id="b2eb8-535">or</span></span>
```
Destruct instance of B
Destruct instance of A
```
<span data-ttu-id="b2eb8-536">Poiché il linguaggio non impone alcun vincolo nell'ordine in cui gli oggetti vengono sottoposti a garbage collection.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-536">because the language imposes no constraints on the order in which objects are garbage collected.</span></span>

<span data-ttu-id="b2eb8-537">In alcuni casi, la distinzione tra "idonei per l'eliminazione definitiva" e "idoneo per la raccolta" può essere importante.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-537">In subtle cases, the distinction between "eligible for destruction" and "eligible for collection" can be important.</span></span> <span data-ttu-id="b2eb8-538">Ad esempio,</span><span class="sxs-lookup"><span data-stu-id="b2eb8-538">For example,</span></span>
```csharp
using System;

class A
{
    ~A() {
        Console.WriteLine("Destruct instance of A");
    }

    public void F() {
        Console.WriteLine("A.F");
        Test.RefA = this;
    }
}

class B
{
    public A Ref;

    ~B() {
        Console.WriteLine("Destruct instance of B");
        Ref.F();
    }
}

class Test
{
    public static A RefA;
    public static B RefB;

    static void Main() {
        RefB = new B();
        RefA = new A();
        RefB.Ref = RefA;
        RefB = null;
        RefA = null;

        // A and B now eligible for destruction
        GC.Collect();
        GC.WaitForPendingFinalizers();

        // B now eligible for collection, but A is not
        if (RefA != null)
            Console.WriteLine("RefA is not null");
    }
}
```

<span data-ttu-id="b2eb8-539">Nel programma precedente, se il garbage collector sceglie di eseguire il distruttore di `A` prima del distruttore di `B`, potrebbe essere l'output di questo programma:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-539">In the above program, if the garbage collector chooses to run the destructor of `A` before the destructor of `B`, then the output of this program might be:</span></span>
```
Destruct instance of A
Destruct instance of B
A.F
RefA is not null
```

<span data-ttu-id="b2eb8-540">Si noti che anche se l'istanza di `A` non è stato utilizzato e `A`del distruttore è stato eseguito, è comunque possibile chiamare i metodi di `A` (in questo caso, `F`) essere chiamato dal distruttore un'altra.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-540">Note that although the instance of `A` was not in use and `A`'s destructor was run, it is still possible for methods of `A` (in this case, `F`) to be called from another destructor.</span></span> <span data-ttu-id="b2eb8-541">Si noti inoltre che l'esecuzione di un distruttore potrebbe essere un oggetto diventi utilizzabile nel programma principale.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-541">Also, note that running of a destructor may cause an object to become usable from the mainline program again.</span></span> <span data-ttu-id="b2eb8-542">In questo caso, l'esecuzione di `B`del distruttore ha causato un'istanza di `A` che è stato in precedenza non è in uso per diventano accessibili dal riferimento in tempo reale `Test.RefA`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-542">In this case, the running of `B`'s destructor caused an instance of `A` that was previously not in use to become accessible from the live reference `Test.RefA`.</span></span> <span data-ttu-id="b2eb8-543">Dopo la chiamata a `WaitForPendingFinalizers`, l'istanza di `B` idoneo per la raccolta, ma l'istanza di `A` non lo è, a causa del riferimento `Test.RefA`.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-543">After the call to `WaitForPendingFinalizers`, the instance of `B` is eligible for collection, but the instance of `A` is not, because of the reference `Test.RefA`.</span></span>

<span data-ttu-id="b2eb8-544">Per evitare confusione e un comportamento imprevisto, è in genere una buona idea per i distruttori per eseguire solo la pulizia dei dati memorizzati nei rispettivi campi dell'oggetto e non per eseguire azioni su oggetti di riferimento o campi statici.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-544">To avoid confusion and unexpected behavior, it is generally a good idea for destructors to only perform cleanup on data stored in their object's own fields, and not to perform any actions on referenced objects or static fields.</span></span>

<span data-ttu-id="b2eb8-545">È un'alternativa all'uso di distruttori per consentire una classe implementa il `System.IDisposable` interfaccia.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-545">An alternative to using destructors is to let a class implement the `System.IDisposable` interface.</span></span> <span data-ttu-id="b2eb8-546">In questo modo il client dell'oggetto definire quando rilasciare le risorse dell'oggetto, in genere eseguendo l'accesso all'oggetto come una risorsa in un `using` istruzione ([l'istruzione using](statements.md#the-using-statement)).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-546">This allows the client of the object to determine when to release the resources of the object, typically by accessing the object as a resource in a `using` statement ([The using statement](statements.md#the-using-statement)).</span></span>

## <a name="execution-order"></a><span data-ttu-id="b2eb8-547">Ordine di esecuzione</span><span class="sxs-lookup"><span data-stu-id="b2eb8-547">Execution order</span></span>

<span data-ttu-id="b2eb8-548">Esecuzione di un programma C# consente di passare in modo che gli effetti collaterali di ogni thread in esecuzione vengono mantenuti in corrispondenza di punti critici di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-548">Execution of a C# program proceeds such that the side effects of each executing thread are preserved at critical execution points.</span></span> <span data-ttu-id="b2eb8-549">Oggetto ***effetto collaterale*** è definito come di lettura o scrittura di un campo volatile, la scrittura in una variabile non-volatile, la scrittura in una risorsa esterna e la generazione di un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-549">A ***side effect*** is defined as a read or write of a volatile field, a write to a non-volatile variable, a write to an external resource, and the throwing of an exception.</span></span> <span data-ttu-id="b2eb8-550">I punti critici di esecuzione in corrispondenza del quale deve essere mantenuto l'ordine di questi effetti collaterali sono riferimenti a campi volatili ([campi volatili](classes.md#volatile-fields)), `lock` istruzioni ([istruzione lock](statements.md#the-lock-statement)), e la creazione del thread e la chiusura.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-550">The critical execution points at which the order of these side effects must be preserved are references to volatile fields ([Volatile fields](classes.md#volatile-fields)), `lock` statements ([The lock statement](statements.md#the-lock-statement)), and thread creation and termination.</span></span> <span data-ttu-id="b2eb8-551">L'ambiente di esecuzione è gratuito modificare l'ordine di esecuzione di un programma C#, soggetto ai vincoli seguenti:</span><span class="sxs-lookup"><span data-stu-id="b2eb8-551">The execution environment is free to change the order of execution of a C# program, subject to the following constraints:</span></span>

*  <span data-ttu-id="b2eb8-552">Dipendenza dei dati viene mantenuta all'interno di un thread di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-552">Data dependence is preserved within a thread of execution.</span></span> <span data-ttu-id="b2eb8-553">Vale a dire, il valore di ogni variabile viene calcolato come se tutte le istruzioni nel thread sono state eseguite nell'ordine del programma originale.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-553">That is, the value of each variable is computed as if all statements in the thread were executed in original program order.</span></span>
*  <span data-ttu-id="b2eb8-554">Inizializzazione di ordinamento vengono mantenute le regole di ([inizializzazione del campo](classes.md#field-initialization) e [inizializzatori](classes.md#variable-initializers)).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-554">Initialization ordering rules are preserved ([Field initialization](classes.md#field-initialization) and [Variable initializers](classes.md#variable-initializers)).</span></span>
*  <span data-ttu-id="b2eb8-555">L'ordinamento degli effetti collaterali viene mantenuto per letture e scritture ([campi volatili](classes.md#volatile-fields)).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-555">The ordering of side effects is preserved with respect to volatile reads and writes ([Volatile fields](classes.md#volatile-fields)).</span></span> <span data-ttu-id="b2eb8-556">Inoltre, l'ambiente di esecuzione non è necessario valutare parte di un'espressione se è possibile dedurre che il valore dell'espressione non viene utilizzato e che nessun effetto collaterale necessario vengono prodotte (incluse quelle dovuta a chiamate a un metodo o l'accesso a un campo volatile).</span><span class="sxs-lookup"><span data-stu-id="b2eb8-556">Additionally, the execution environment need not evaluate part of an expression if it can deduce that that expression's value is not used and that no needed side effects are produced (including any caused by calling a method or accessing a volatile field).</span></span> <span data-ttu-id="b2eb8-557">Quando l'esecuzione del programma viene interrotta da un evento asincrono (ad esempio, un'eccezione generata da un altro thread), non è garantito che gli effetti collaterali osservabili siano visibili nell'ordine programma originale.</span><span class="sxs-lookup"><span data-stu-id="b2eb8-557">When program execution is interrupted by an asynchronous event (such as an exception thrown by another thread), it is not guaranteed that the observable side effects are visible in the original program order.</span></span>
