---
ms.openlocfilehash: ecdad8c863d0695bc901e4d96d9ca3decbc248eb
ms.sourcegitcommit: 94a3d151c438d34ede1d99de9eb4ebdc07ba4699
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/25/2019
ms.locfileid: "79484615"
---
# <a name="nullable-reference-types-in-c"></a><span data-ttu-id="d2b07-101">Tipi di riferimento nullable inC#</span><span class="sxs-lookup"><span data-stu-id="d2b07-101">Nullable reference types in C#</span></span> #

<span data-ttu-id="d2b07-102">L'obiettivo di questa funzionalità è:</span><span class="sxs-lookup"><span data-stu-id="d2b07-102">The goal of this feature is to:</span></span>

* <span data-ttu-id="d2b07-103">Consente agli sviluppatori di esprimere se una variabile, un parametro o un risultato di un tipo di riferimento è destinato a essere null o meno.</span><span class="sxs-lookup"><span data-stu-id="d2b07-103">Allow developers to express whether a variable, parameter or result of a reference type is intended to be null or not.</span></span>
* <span data-ttu-id="d2b07-104">Fornire avvisi quando tali variabili, parametri e risultati non vengono utilizzati in base a tale finalità.</span><span class="sxs-lookup"><span data-stu-id="d2b07-104">Provide warnings when such variables, parameters and results are not used according to that intent.</span></span>

## <a name="expression-of-intent"></a><span data-ttu-id="d2b07-105">Espressione di finalità</span><span class="sxs-lookup"><span data-stu-id="d2b07-105">Expression of intent</span></span>

<span data-ttu-id="d2b07-106">Il linguaggio contiene già la sintassi `T?` per i tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="d2b07-106">The language already contains the `T?` syntax for value types.</span></span> <span data-ttu-id="d2b07-107">È semplice estendere questa sintassi ai tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="d2b07-107">It is straightforward to extend this syntax to reference types.</span></span>

<span data-ttu-id="d2b07-108">Si presuppone che lo scopo di un tipo di riferimento non decorato `T` non sia null.</span><span class="sxs-lookup"><span data-stu-id="d2b07-108">It is assumed that the intent of an unadorned reference type `T` is for it to be non-null.</span></span>

## <a name="checking-of-nullable-references"></a><span data-ttu-id="d2b07-109">Controllo dei riferimenti Nullable</span><span class="sxs-lookup"><span data-stu-id="d2b07-109">Checking of nullable references</span></span>

<span data-ttu-id="d2b07-110">Un'analisi di flusso tiene traccia delle variabili di riferimento Nullable.</span><span class="sxs-lookup"><span data-stu-id="d2b07-110">A flow analysis tracks nullable reference variables.</span></span> <span data-ttu-id="d2b07-111">Se l'analisi considera che non sarebbero null (ad esempio, dopo un controllo o un'assegnazione), il relativo valore verrà considerato un riferimento non null.</span><span class="sxs-lookup"><span data-stu-id="d2b07-111">Where the analysis deems that they would not be null (e.g. after a check or an assignment), their value will be considered a non-null reference.</span></span>

<span data-ttu-id="d2b07-112">Un riferimento Nullable può essere trattato anche in modo esplicito come non null con l'operatore suffisso `x!` (l'operatore "dannazione"), quando l'analisi dei flussi non è in grado di stabilire una situazione non null che lo sviluppatore conosce è presente.</span><span class="sxs-lookup"><span data-stu-id="d2b07-112">A nullable reference can also explicitly be treated as non-null with the postfix `x!` operator (the "dammit" operator), for when flow analysis cannot establish a non-null situation that the developer knows is there.</span></span>

<span data-ttu-id="d2b07-113">In caso contrario, viene fornito un avviso se un riferimento Nullable è dereferenziato o viene convertito in un tipo non null.</span><span class="sxs-lookup"><span data-stu-id="d2b07-113">Otherwise, a warning is given if a nullable reference is dereferenced, or is converted to a non-null type.</span></span>

<span data-ttu-id="d2b07-114">Quando si esegue la conversione da `S[]` a `T?[]` e da `S?[]` a `T[]`, viene visualizzato un avviso.</span><span class="sxs-lookup"><span data-stu-id="d2b07-114">A warning is given when converting from `S[]` to `T?[]` and from `S?[]` to `T[]`.</span></span>

<span data-ttu-id="d2b07-115">Viene fornito un avviso quando si esegue la conversione da `C<S>` a `C<T?>` tranne quando il parametro di tipo è covariante (`out`) e quando si esegue la conversione da `C<S?>` a `C<T>` tranne quando il parametro di tipo è controvariante (`in`).</span><span class="sxs-lookup"><span data-stu-id="d2b07-115">A warning is given when converting from `C<S>` to `C<T?>` except when the type parameter is covariant (`out`), and when converting from `C<S?>` to `C<T>` except when the type parameter is contravariant (`in`).</span></span>

<span data-ttu-id="d2b07-116">Viene visualizzato un avviso in `C<T?>` se il parametro di tipo presenta vincoli non null.</span><span class="sxs-lookup"><span data-stu-id="d2b07-116">A warning is given on `C<T?>` if the type parameter has non-null constraints.</span></span> 

## <a name="checking-of-non-null-references"></a><span data-ttu-id="d2b07-117">Verifica dei riferimenti non null</span><span class="sxs-lookup"><span data-stu-id="d2b07-117">Checking of non-null references</span></span>

<span data-ttu-id="d2b07-118">Viene fornito un avviso se un valore letterale null viene assegnato a una variabile non null o passato come parametro non null.</span><span class="sxs-lookup"><span data-stu-id="d2b07-118">A warning is given if a null literal is assigned to a non-null variable or passed as a non-null parameter.</span></span>

<span data-ttu-id="d2b07-119">Viene inoltre fornito un avviso se un costruttore non inizializza in modo esplicito i campi di riferimento non null.</span><span class="sxs-lookup"><span data-stu-id="d2b07-119">A warning is also given if a constructor does not explicitly initialize non-null reference fields.</span></span>

<span data-ttu-id="d2b07-120">Non è possibile rilevare adeguatamente che vengono inizializzati tutti gli elementi di una matrice di riferimenti non null.</span><span class="sxs-lookup"><span data-stu-id="d2b07-120">We cannot adequately track that all elements of an array of non-null references are initialized.</span></span> <span data-ttu-id="d2b07-121">Tuttavia, è possibile emettere un avviso se nessun elemento di una matrice appena creata viene assegnato a prima che la matrice venga letta o passata.</span><span class="sxs-lookup"><span data-stu-id="d2b07-121">However, we could issue a warning if no element of a newly created array is assigned to before the array is read from or passed on.</span></span> <span data-ttu-id="d2b07-122">Questo potrebbe gestire il caso comune senza essere troppo rumoroso.</span><span class="sxs-lookup"><span data-stu-id="d2b07-122">That might handle the common case without being too noisy.</span></span>

<span data-ttu-id="d2b07-123">È necessario decidere se `default(T)` genera un avviso o semplicemente essere considerato come il tipo `T?`.</span><span class="sxs-lookup"><span data-stu-id="d2b07-123">We need to decide whether `default(T)` generates a warning, or is simply treated as being of the type `T?`.</span></span>

## <a name="metadata-representation"></a><span data-ttu-id="d2b07-124">Rappresentazione dei metadati</span><span class="sxs-lookup"><span data-stu-id="d2b07-124">Metadata representation</span></span>

<span data-ttu-id="d2b07-125">Le aree di strumenti per il supporto di valori null devono essere rappresentate nei metadati come attributi.</span><span class="sxs-lookup"><span data-stu-id="d2b07-125">Nullability adornments should be represented in metadata as attributes.</span></span> <span data-ttu-id="d2b07-126">Ciò significa che i compilatori di livello inferiore li ignoreranno.</span><span class="sxs-lookup"><span data-stu-id="d2b07-126">This means that downlevel compilers will ignore them.</span></span>

<span data-ttu-id="d2b07-127">È necessario decidere se sono incluse solo le annotazioni nullable o se è presente anche un'indicazione relativa alla presenza di valori non null nell'assembly.</span><span class="sxs-lookup"><span data-stu-id="d2b07-127">We need to decide if only nullable annotations are included, or there's also some indication of whether non-null was "on" in the assembly.</span></span>

## <a name="generics"></a><span data-ttu-id="d2b07-128">Generics</span><span class="sxs-lookup"><span data-stu-id="d2b07-128">Generics</span></span>

<span data-ttu-id="d2b07-129">Se un parametro di tipo `T` presenta vincoli non nullable, viene considerato come non nullable all'interno del relativo ambito.</span><span class="sxs-lookup"><span data-stu-id="d2b07-129">If a type parameter `T` has non-nullable constraints, it is treated as non-nullable within its scope.</span></span>

<span data-ttu-id="d2b07-130">Se un parametro di tipo non è vincolato o ha solo vincoli Nullable, la situazione è un po' più complessa: ciò significa che l'argomento di tipo corrispondente *potrebbe essere nullable o non nullable.*</span><span class="sxs-lookup"><span data-stu-id="d2b07-130">If a type parameter is unconstrained or has only nullable constraints, the situation is a little more complex: this means that the corresponding type argument could be *either* nullable or non-nullable.</span></span> <span data-ttu-id="d2b07-131">La cosa più sicura da fare in questa situazione consiste nel considerare il parametro di *tipo come Nullable* e non nullable, fornendo avvisi quando uno dei due viene violato.</span><span class="sxs-lookup"><span data-stu-id="d2b07-131">The safe thing to do in that situation is to treat the type parameter as *both* nullable and non-nullable, giving warnings when either is violated.</span></span> 

<span data-ttu-id="d2b07-132">Vale la pena considerare se devono essere consentiti i vincoli espliciti Nullable Reference.</span><span class="sxs-lookup"><span data-stu-id="d2b07-132">It is worth considering whether explicit nullable reference constraints should be allowed.</span></span> <span data-ttu-id="d2b07-133">Si noti, tuttavia, che non è possibile evitare che i tipi di riferimento Nullable siano *implicitamente* vincoli in determinati casi (vincoli ereditati).</span><span class="sxs-lookup"><span data-stu-id="d2b07-133">Note, however, that we cannot avoid having nullable reference types *implicitly* be constraints in certain cases (inherited constraints).</span></span>

<span data-ttu-id="d2b07-134">Il vincolo `class` è diverso da null.</span><span class="sxs-lookup"><span data-stu-id="d2b07-134">The `class` constraint is non-null.</span></span> <span data-ttu-id="d2b07-135">È possibile considerare se `class?` deve essere un vincolo Nullable valido che indica "tipo di riferimento Nullable".</span><span class="sxs-lookup"><span data-stu-id="d2b07-135">We can consider whether `class?` should be a valid nullable constraint denoting "nullable reference type".</span></span>

## <a name="type-inference"></a><span data-ttu-id="d2b07-136">Inferenza del tipo</span><span class="sxs-lookup"><span data-stu-id="d2b07-136">Type inference</span></span>

<span data-ttu-id="d2b07-137">Nell'inferenza del tipo, se un tipo che contribuisce è un tipo di riferimento Nullable, il tipo risultante deve essere nullable.</span><span class="sxs-lookup"><span data-stu-id="d2b07-137">In type inference, if a contributing type is a nullable reference type, the resulting type should be nullable.</span></span> <span data-ttu-id="d2b07-138">In altre parole, viene propagato un valore null.</span><span class="sxs-lookup"><span data-stu-id="d2b07-138">In other words, nullness is propagated.</span></span>

<span data-ttu-id="d2b07-139">È necessario valutare se il valore letterale `null` come espressione partecipante debba contribuire a un valore null.</span><span class="sxs-lookup"><span data-stu-id="d2b07-139">We should consider whether the `null` literal as a participating expression should contribute nullness.</span></span> <span data-ttu-id="d2b07-140">Non è oggi: per i tipi di valore genera un errore, mentre per i tipi di riferimento il valore null viene convertito correttamente nel tipo normale.</span><span class="sxs-lookup"><span data-stu-id="d2b07-140">It doesn't today: for value types it leads to an error, whereas for reference types the null successfully converts to the plain type.</span></span> 

```csharp
string? n = "world";
var x = b ? "Hello" : n; // string?
var y = b ? "Hello" : null; // string? or error
var z = b ? 7 : null; // Error today, could be int?
```

## <a name="breaking-changes"></a><span data-ttu-id="d2b07-141">Modifiche di rilievo</span><span class="sxs-lookup"><span data-stu-id="d2b07-141">Breaking changes</span></span>

<span data-ttu-id="d2b07-142">Gli avvisi non null rappresentano una modifica ovvia del codice esistente e devono essere accompagnati da un meccanismo di consenso esplicito.</span><span class="sxs-lookup"><span data-stu-id="d2b07-142">Non-null warnings are an obvious breaking change on existing code, and should be accompanied with an opt-in mechanism.</span></span>

<span data-ttu-id="d2b07-143">Meno ovviamente, gli avvisi dei tipi Nullable (come descritto in precedenza) rappresentano una modifica sostanziale del codice esistente in determinati scenari in cui il supporto di valori null è implicito:</span><span class="sxs-lookup"><span data-stu-id="d2b07-143">Less obviously, warnings from nullable types (as described above) are a breaking change on existing code in certain scenarios where the nullability is implicit:</span></span>

* <span data-ttu-id="d2b07-144">I parametri di tipo non vincolati verranno considerati implicitamente Nullable, quindi l'assegnazione a `object` o l'accesso ad, ad esempio `ToString` genererà avvisi.</span><span class="sxs-lookup"><span data-stu-id="d2b07-144">Unconstrained type parameters will be treated as implicitly nullable, so assigning them to `object` or accessing e.g. `ToString` will yield warnings.</span></span>
* <span data-ttu-id="d2b07-145">Se l'inferenza del tipo deduce un valore null dalle espressioni `null`, il codice esistente a volte restituisce Nullable anziché i tipi non nullable, che possono causare nuovi avvisi.</span><span class="sxs-lookup"><span data-stu-id="d2b07-145">if type inference infers nullness from `null` expressions, then existing code will sometimes yield nullable rather than non-nullable types, which can lead to new warnings.</span></span>

<span data-ttu-id="d2b07-146">Pertanto, gli avvisi nullable devono anche essere facoltativi</span><span class="sxs-lookup"><span data-stu-id="d2b07-146">So nullable warnings also need to be optional</span></span>

<span data-ttu-id="d2b07-147">Infine, l'aggiunta di annotazioni a un'API esistente sarà una modifica sostanziale per gli utenti che hanno scelto gli avvisi quando eseguono l'aggiornamento della libreria.</span><span class="sxs-lookup"><span data-stu-id="d2b07-147">Finally, adding annotations to an existing API will be a breaking change to users who have opted in to warnings, when they upgrade the library.</span></span> <span data-ttu-id="d2b07-148">Questo, inoltre, merita la possibilità di acconsentire esplicitamente o meno. "Desidero correggere le correzioni di bug, ma non sono pronto per gestire le nuove annotazioni"</span><span class="sxs-lookup"><span data-stu-id="d2b07-148">This, too, merits the ability to opt in or out. "I want the bug fixes, but I am not ready to deal with their new annotations"</span></span>

<span data-ttu-id="d2b07-149">In breve, è necessario essere in grado di acconsentire esplicitamente o meno:</span><span class="sxs-lookup"><span data-stu-id="d2b07-149">In summary, you need to be able to opt in/out of:</span></span>
* <span data-ttu-id="d2b07-150">Avvisi Nullable</span><span class="sxs-lookup"><span data-stu-id="d2b07-150">Nullable warnings</span></span>
* <span data-ttu-id="d2b07-151">Avvisi non null</span><span class="sxs-lookup"><span data-stu-id="d2b07-151">Non-null warnings</span></span>
* <span data-ttu-id="d2b07-152">Avvisi da annotazioni in altri file</span><span class="sxs-lookup"><span data-stu-id="d2b07-152">Warnings from annotations in other files</span></span>

<span data-ttu-id="d2b07-153">La granularità del consenso esplicito suggerisce un modello di tipo analizzatore, in cui le porzioni di codice possono acconsentire esplicitamente e uscire con i pragma e i livelli di gravità possono essere scelti dall'utente.</span><span class="sxs-lookup"><span data-stu-id="d2b07-153">The granularity of the opt-in suggests an analyzer-like model, where swaths of code can opt in and out with pragmas and severity levels can be chosen by the user.</span></span> <span data-ttu-id="d2b07-154">Inoltre, le opzioni per libreria ("Ignora le annotazioni da JSON.NET fino a quando non si è pronti a gestire il calo") possono essere esprimibile nel codice come attributi.</span><span class="sxs-lookup"><span data-stu-id="d2b07-154">Additionally, per-library options ("ignore the annotations from JSON.NET until I'm ready to deal with the fall out") may be expressible in code as attributes.</span></span>

<span data-ttu-id="d2b07-155">La progettazione dell'esperienza di consenso esplicito/transizione è fondamentale per il successo e l'utilità di questa funzionalità.</span><span class="sxs-lookup"><span data-stu-id="d2b07-155">The design of the opt-in/transition experience is crucial to the success and usefulness of this feature.</span></span> <span data-ttu-id="d2b07-156">È necessario assicurarsi che:</span><span class="sxs-lookup"><span data-stu-id="d2b07-156">We need to make sure that:</span></span>

* <span data-ttu-id="d2b07-157">Gli utenti possono adottare gradualmente il controllo dei valori null come desiderano</span><span class="sxs-lookup"><span data-stu-id="d2b07-157">Users can adopt nullability checking gradually as they want to</span></span>
* <span data-ttu-id="d2b07-158">Gli autori di librerie possono aggiungere annotazioni di supporto per i valori null senza timore di compromettere</span><span class="sxs-lookup"><span data-stu-id="d2b07-158">Library authors can add nullability annotations without fear of breaking customers</span></span>
* <span data-ttu-id="d2b07-159">Nonostante queste, non c'è un senso di "incubo per la configurazione"</span><span class="sxs-lookup"><span data-stu-id="d2b07-159">Despite these, there is not a sense of "configuration nightmare"</span></span>

## <a name="tweaks"></a><span data-ttu-id="d2b07-160">Tweaks</span><span class="sxs-lookup"><span data-stu-id="d2b07-160">Tweaks</span></span>

<span data-ttu-id="d2b07-161">È possibile considerare di non usare le annotazioni `?` sulle variabili locali, ma solo di osservare se vengono usate in base a ciò che viene assegnato.</span><span class="sxs-lookup"><span data-stu-id="d2b07-161">We could consider not using the `?` annotations on locals, but just observing whether they are used in accordance with what gets assigned to them.</span></span> <span data-ttu-id="d2b07-162">Non prediligo questo problema; Credo che dovremmo esprimere in modo uniforme le loro finalità.</span><span class="sxs-lookup"><span data-stu-id="d2b07-162">I don't favor this; I think we should uniformly let people express their intent.</span></span>

<span data-ttu-id="d2b07-163">È possibile considerare una sintassi abbreviata `T! x` sui parametri, che genera automaticamente un controllo null in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="d2b07-163">We could consider a shorthand `T! x` on parameters, that auto-generates a runtime null check.</span></span>

<span data-ttu-id="d2b07-164">Alcuni modelli sui tipi generici, ad esempio `FirstOrDefault` o `TryGet`, hanno un comportamento leggermente strano con argomenti di tipo non nullable, perché producono in modo esplicito valori predefiniti in determinate situazioni.</span><span class="sxs-lookup"><span data-stu-id="d2b07-164">Certain patterns on generic types, such as `FirstOrDefault` or `TryGet`, have slightly weird behavior with non-nullable type arguments, because they explicitly yield default values in certain situations.</span></span> <span data-ttu-id="d2b07-165">Potremmo provare a sfumare il sistema di tipi per adattarlo meglio.</span><span class="sxs-lookup"><span data-stu-id="d2b07-165">We could try to nuance the type system to accommodate these better.</span></span> <span data-ttu-id="d2b07-166">Ad esempio, è possibile consentire `?` sui parametri di tipo non vincolati, anche se l'argomento di tipo potrebbe già ammettere valori null.</span><span class="sxs-lookup"><span data-stu-id="d2b07-166">For instance, we could allow `?` on unconstrained type parameters, even though the type argument could already be nullable.</span></span> <span data-ttu-id="d2b07-167">Dubito che valga la pena e che comporti stranezze correlate all'interazione con I tipi di *valore* Nullable.</span><span class="sxs-lookup"><span data-stu-id="d2b07-167">I doubt that it is worth it, and it leads to weirdness related to interaction with nullable *value* types.</span></span> 

## <a name="nullable-value-types"></a><span data-ttu-id="d2b07-168">Tipi valore nullable</span><span class="sxs-lookup"><span data-stu-id="d2b07-168">Nullable value types</span></span>

<span data-ttu-id="d2b07-169">È possibile prendere in considerazione l'adozione di parte della semantica precedente anche per i tipi di valore Nullable.</span><span class="sxs-lookup"><span data-stu-id="d2b07-169">We could consider adopting some of the above semantics for nullable value types as well.</span></span>

<span data-ttu-id="d2b07-170">È già stata indicata l'inferenza del tipo, in cui è possibile dedurre `int?` da `(7, null)`, anziché semplicemente restituire un errore.</span><span class="sxs-lookup"><span data-stu-id="d2b07-170">We already mentioned type inference, where we could infer `int?` from `(7, null)`, instead of just giving an error.</span></span>

<span data-ttu-id="d2b07-171">Un'altra opportunità consiste nell'applicare l'analisi del flusso ai tipi di valore Nullable.</span><span class="sxs-lookup"><span data-stu-id="d2b07-171">Another opportunity is to apply the flow analysis to nullable value types.</span></span> <span data-ttu-id="d2b07-172">Quando vengono ritenuti non null, si potrebbe effettivamente consentire l'uso di come tipo non nullable in determinati modi, ad esempio l'accesso ai membri.</span><span class="sxs-lookup"><span data-stu-id="d2b07-172">When they are deemed non-null, we could actually allow using as the non-nullable type in certain ways (e.g. member access).</span></span> <span data-ttu-id="d2b07-173">È sufficiente prestare attenzione che siano preferibili gli elementi che *è possibile eseguire* in un tipo di valore Nullable, per motivi di compatibilità.</span><span class="sxs-lookup"><span data-stu-id="d2b07-173">We just have to be careful that the things that you can *already* do on a nullable value type will be preferred, for back compat reasons.</span></span>
