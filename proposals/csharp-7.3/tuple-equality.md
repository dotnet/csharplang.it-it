---
ms.openlocfilehash: 0ad15753b0bfbaa6901a443fbbb461b56ed88b4d
ms.sourcegitcommit: 6f244db799642274fafce6897dae169edae0c788
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/25/2020
ms.locfileid: "85372015"
---
# <a name="support-for--and--on-tuple-types"></a><span data-ttu-id="4547b-101">Supporto per = = e! = sui tipi di tupla</span><span class="sxs-lookup"><span data-stu-id="4547b-101">Support for == and != on tuple types</span></span>

<span data-ttu-id="4547b-102">Consenti le `t1 == t2` espressioni `t1` in cui e `t2` sono tuple o tipi di tupla Nullable della stessa cardinalità e li valutano approssimativamente come `temp1.Item1 == temp2.Item1 && temp1.Item2 == temp2.Item2` (presupponendo `var temp1 = t1; var temp2 = t2;` ).</span><span class="sxs-lookup"><span data-stu-id="4547b-102">Allow expressions `t1 == t2` where `t1` and `t2` are tuple or nullable tuple types of same cardinality, and evaluate them roughly as `temp1.Item1 == temp2.Item1 && temp1.Item2 == temp2.Item2` (assuming `var temp1 = t1; var temp2 = t2;`).</span></span>

<span data-ttu-id="4547b-103">Viceversa, consentirebbe `t1 != t2` e valuterà il risultato come `temp1.Item1 != temp2.Item1 || temp1.Item2 != temp2.Item2` .</span><span class="sxs-lookup"><span data-stu-id="4547b-103">Conversely it would allow `t1 != t2` and evaluate it as `temp1.Item1 != temp2.Item1 || temp1.Item2 != temp2.Item2`.</span></span>

<span data-ttu-id="4547b-104">Nel caso nullable vengono usati ulteriori controlli per `temp1.HasValue` e `temp2.HasValue` .</span><span class="sxs-lookup"><span data-stu-id="4547b-104">In the nullable case, additional checks for `temp1.HasValue` and `temp2.HasValue` are used.</span></span> <span data-ttu-id="4547b-105">Ad esempio, `nullableT1 == nullableT2` restituisce `temp1.HasValue == temp2.HasValue ? (temp1.HasValue ? ... : true) : false` .</span><span class="sxs-lookup"><span data-stu-id="4547b-105">For instance, `nullableT1 == nullableT2` evaluates as `temp1.HasValue == temp2.HasValue ? (temp1.HasValue ? ... : true) : false`.</span></span>

<span data-ttu-id="4547b-106">Quando un confronto con elementi restituisce un risultato non bool, ad esempio quando viene usato un oggetto non bool definito dall'utente `operator ==` o `operator !=` in un confronto dinamico, il risultato verrà convertito `bool` o eseguito tramite `operator true` o `operator false` per ottenere un oggetto `bool` .</span><span class="sxs-lookup"><span data-stu-id="4547b-106">When an element-wise comparison returns a non-bool result (for instance, when a non-bool user-defined `operator ==` or `operator !=` is used, or in a dynamic comparison), then that result will be either converted to `bool` or run through `operator true` or `operator false` to get a `bool`.</span></span> <span data-ttu-id="4547b-107">Il confronto della tupla termina sempre con la restituzione di un oggetto `bool` .</span><span class="sxs-lookup"><span data-stu-id="4547b-107">The tuple comparison always ends up returning a `bool`.</span></span>

<span data-ttu-id="4547b-108">A partire da C# 7,2, tale codice genera un errore ( `error CS0019: Operator '==' cannot be applied to operands of type '(...)' and '(...)'` ), a meno che non esista un oggetto definito dall'utente `operator==` .</span><span class="sxs-lookup"><span data-stu-id="4547b-108">As of C# 7.2, such code produces an error (`error CS0019: Operator '==' cannot be applied to operands of type '(...)' and '(...)'`), unless there is a user-defined `operator==`.</span></span>

## <a name="details"></a><span data-ttu-id="4547b-109">Dettagli</span><span class="sxs-lookup"><span data-stu-id="4547b-109">Details</span></span>

<span data-ttu-id="4547b-110">Quando si associa l' `==` operatore (o `!=` ), le regole esistenti sono: (1) case dinamico, (2) risoluzione dell'overload e (3) hanno esito negativo.</span><span class="sxs-lookup"><span data-stu-id="4547b-110">When binding the `==` (or `!=`) operator, the existing rules are: (1) dynamic case, (2) overload resolution, and (3) fail.</span></span>
<span data-ttu-id="4547b-111">Questa proposta aggiunge un case di tupla compreso tra (1) e (2): se entrambi gli operandi di un operatore di confronto sono Tuple (i tipi di tupla o sono valori letterali di tupla) e hanno cardinalità corrispondente, il confronto viene eseguito per elemento.</span><span class="sxs-lookup"><span data-stu-id="4547b-111">This proposal adds a tuple case between (1) and (2): if both operands of a comparison operator are tuples (have tuple types or are tuple literals) and have matching cardinality, then the comparison is performed element-wise.</span></span> <span data-ttu-id="4547b-112">Questa uguaglianza di tupla viene inoltre sollevata sulle tuple Nullable.</span><span class="sxs-lookup"><span data-stu-id="4547b-112">This tuple equality is also lifted onto nullable tuples.</span></span>

<span data-ttu-id="4547b-113">Entrambi gli operandi (e, nel caso dei valori letterali di tupla, i rispettivi elementi) vengono valutati in ordine da sinistra a destra.</span><span class="sxs-lookup"><span data-stu-id="4547b-113">Both operands (and, in the case of tuple literals, their elements) are evaluated in order from left to right.</span></span> <span data-ttu-id="4547b-114">Ogni coppia di elementi viene quindi utilizzata come operandi per associare l'operatore `==` (o) in modo `!=` ricorsivo.</span><span class="sxs-lookup"><span data-stu-id="4547b-114">Each pair of elements is then used as operands to bind the operator `==` (or `!=`), recursively.</span></span> <span data-ttu-id="4547b-115">Tutti gli elementi con tipo in fase di compilazione `dynamic` generano un errore.</span><span class="sxs-lookup"><span data-stu-id="4547b-115">Any elements with compile-time type `dynamic` cause an error.</span></span> <span data-ttu-id="4547b-116">I risultati di questi confronti per elementi vengono utilizzati come operandi in una catena di operatori condizionali AND (or).</span><span class="sxs-lookup"><span data-stu-id="4547b-116">The results of those element-wise comparisons are used as operands in a chain of conditional AND (or OR) operators.</span></span>

<span data-ttu-id="4547b-117">Nel contesto di, ad esempio `(int, (int, int)) t1, t2;` , `t1 == (1, (2, 3))` verrebbe valutato come `temp1.Item1 == temp2.Item1 && temp1.Item2.Item1 == temp2.Item2.Item1 && temp1.Item2.Item2 == temp2.Item2.Item2` .</span><span class="sxs-lookup"><span data-stu-id="4547b-117">For instance, in the context of `(int, (int, int)) t1, t2;`, `t1 == (1, (2, 3))` would evaluate as `temp1.Item1 == temp2.Item1 && temp1.Item2.Item1 == temp2.Item2.Item1 && temp1.Item2.Item2 == temp2.Item2.Item2`.</span></span>

<span data-ttu-id="4547b-118">Quando un valore letterale di tupla viene usato come operando (su entrambi i lati), riceve un tipo di tupla convertito formato dalle conversioni degli elementi che vengono introdotte durante l'associazione dell'operatore `==` (o `!=` ) elemento per elemento.</span><span class="sxs-lookup"><span data-stu-id="4547b-118">When a tuple literal is used as operand (on either side), it receives a converted tuple type formed by the element-wise conversions which are introduced when binding the operator `==` (or `!=`) element-wise.</span></span> 

<span data-ttu-id="4547b-119">In, ad esempio, `(1L, 2, "hello") == (1, 2L, null)` il tipo convertito per entrambi i valori letterali di tupla è `(long, long, string)` e il secondo valore letterale non ha un tipo naturale.</span><span class="sxs-lookup"><span data-stu-id="4547b-119">For instance, in `(1L, 2, "hello") == (1, 2L, null)`, the converted type for both tuple literals is `(long, long, string)` and the second literal has no natural type.</span></span>


### <a name="deconstruction-and-conversions-to-tuple"></a><span data-ttu-id="4547b-120">Decostruzione e conversioni in tupla</span><span class="sxs-lookup"><span data-stu-id="4547b-120">Deconstruction and conversions to tuple</span></span>
<span data-ttu-id="4547b-121">In `(a, b) == x` il fatto che `x` può decostruire in due elementi non svolge un ruolo.</span><span class="sxs-lookup"><span data-stu-id="4547b-121">In `(a, b) == x`, the fact that `x` can deconstruct into two elements does not play a role.</span></span> <span data-ttu-id="4547b-122">Questo potrebbe essere in una proposta futura, anche se potrebbe generare domande su `x == y` (si tratta di un confronto semplice o di un confronto elemento per elementi e, in caso affermativo, usando la cardinalità?).</span><span class="sxs-lookup"><span data-stu-id="4547b-122">That could conceivably be in a future proposal, although it would raise questions about `x == y` (is this a simple comparison or an element-wise comparison, and if so using what cardinality?).</span></span>
<span data-ttu-id="4547b-123">Analogamente, le conversioni in tupla non svolgono alcun ruolo.</span><span class="sxs-lookup"><span data-stu-id="4547b-123">Similarly, conversions to tuple play no role.</span></span>

### <a name="tuple-element-names"></a><span data-ttu-id="4547b-124">Nomi di elementi di tupla</span><span class="sxs-lookup"><span data-stu-id="4547b-124">Tuple element names</span></span>

<span data-ttu-id="4547b-125">Quando si converte un valore letterale di tupla, viene visualizzato un avviso quando nel valore letterale è stato specificato un nome di elemento di tupla esplicito, ma non corrisponde al nome dell'elemento della tupla</span><span class="sxs-lookup"><span data-stu-id="4547b-125">When converting a tuple literal, we warn when an explicit tuple element name was provided in the literal, but it doesn't match the target tuple element name.</span></span>
<span data-ttu-id="4547b-126">Si usa la stessa regola nel confronto tra tuple, in modo che si supponga di ricevere un `(int a, int b) t` avviso `d` in `t == (c, d: 0)` .</span><span class="sxs-lookup"><span data-stu-id="4547b-126">We use the same rule in tuple comparison, so that assuming `(int a, int b) t` we warn on `d` in `t == (c, d: 0)`.</span></span>

### <a name="non-bool-element-wise-comparison-results"></a><span data-ttu-id="4547b-127">Risultati di confronto elemento non bool</span><span class="sxs-lookup"><span data-stu-id="4547b-127">Non-bool element-wise comparison results</span></span>

<span data-ttu-id="4547b-128">Se un confronto a livello di elemento è dinamico in un'uguaglianza di tupla, viene usata una chiamata dinamica dell'operatore `false` e si nega che per ottenere `bool` e continuare con ulteriori confronti per elementi.</span><span class="sxs-lookup"><span data-stu-id="4547b-128">If an element-wise comparison is dynamic in a tuple equality, we use a dynamic invocation of the operator `false` and negate that to get a `bool` and continue with further element-wise comparisons.</span></span> 

<span data-ttu-id="4547b-129">Se un confronto con elementi restituisce un altro tipo non bool in un'uguaglianza di tupla, esistono due casi:</span><span class="sxs-lookup"><span data-stu-id="4547b-129">If an element-wise comparison returns some other non-bool type in a tuple equality, there are two cases:</span></span>
- <span data-ttu-id="4547b-130">Se il tipo non bool viene convertito in `bool` , viene applicata la conversione.</span><span class="sxs-lookup"><span data-stu-id="4547b-130">if the non-bool type converts to `bool`, we apply that conversion,</span></span>
- <span data-ttu-id="4547b-131">Se non esiste una conversione di questo tipo, ma il tipo ha un operatore `false` , verrà usato e il risultato verrà negato.</span><span class="sxs-lookup"><span data-stu-id="4547b-131">if there is no such conversion, but the type has an operator `false`, we'll use that and negate the result.</span></span>

<span data-ttu-id="4547b-132">In una tupla di disuguaglianza, valgono le stesse regole, con la differenza che verrà usato l'operatore `true` (senza negazione) anziché l'operatore `false` .</span><span class="sxs-lookup"><span data-stu-id="4547b-132">In a tuple inequality, the same rules apply except that we'll use the operator `true` (without negation) instead of the operator `false`.</span></span>

<span data-ttu-id="4547b-133">Tali regole sono simili alle regole necessarie per l'utilizzo di un tipo non bool in un' `if` istruzione e in altri contesti esistenti.</span><span class="sxs-lookup"><span data-stu-id="4547b-133">Those rules are similar to the rules involved for using a non-bool type in an `if` statement and some other existing contexts.</span></span>

## <a name="evaluation-order-and-special-cases"></a><span data-ttu-id="4547b-134">Ordine di valutazione e casi speciali</span><span class="sxs-lookup"><span data-stu-id="4547b-134">Evaluation order and special cases</span></span>
<span data-ttu-id="4547b-135">Il valore del lato sinistro viene valutato per primo, quindi il valore del lato destro, quindi i confronti elemento per elemento da sinistra a destra (incluse le conversioni e con inizio uscita in base alle regole esistenti per gli operatori condizionali e/o).</span><span class="sxs-lookup"><span data-stu-id="4547b-135">The left-hand-side value is evaluated first, then the right-hand-side value, then the element-wise comparisons from left to right (including conversions, and with early exit based on existing rules for conditional AND/OR operators).</span></span>

<span data-ttu-id="4547b-136">Ad esempio, se è presente una conversione dal tipo `A` al tipo `B` e da un metodo `(A, A) GetTuple()` , la valutazione `(new A(1), (new B(2), new B(3))) == (new B(4), GetTuple())` significa:</span><span class="sxs-lookup"><span data-stu-id="4547b-136">For instance, if there is a conversion from type `A` to type `B` and a method `(A, A) GetTuple()`, evaluating `(new A(1), (new B(2), new B(3))) == (new B(4), GetTuple())` means:</span></span>
- `new A(1)`
- `new B(2)`
- `new B(3)`
- `new B(4)`
- `GetTuple()`
- <span data-ttu-id="4547b-137">vengono quindi valutate le conversioni e i confronti e la logica condizionale degli elementi, ovvero la conversione `new A(1)` nel tipo `B` , quindi il confronto con `new B(4)` e così via.</span><span class="sxs-lookup"><span data-stu-id="4547b-137">then the element-wise conversions and comparisons and conditional logic is evaluated (convert `new A(1)` to type `B`, then compare it with `new B(4)`, and so on).</span></span>

### <a name="comparing-null-to-null"></a><span data-ttu-id="4547b-138">Confronto `null` con`null`</span><span class="sxs-lookup"><span data-stu-id="4547b-138">Comparing `null` to `null`</span></span>

<span data-ttu-id="4547b-139">Si tratta di un caso speciale di confronti regolari, che si riferisce ai confronti di tupla.</span><span class="sxs-lookup"><span data-stu-id="4547b-139">This is a special case from regular comparisons, that carries over to tuple comparisons.</span></span> <span data-ttu-id="4547b-140">Il `null == null` confronto è consentito e i `null` valori letterali non ottengono alcun tipo.</span><span class="sxs-lookup"><span data-stu-id="4547b-140">The `null == null` comparison is allowed, and the `null` literals do not get any type.</span></span>
<span data-ttu-id="4547b-141">Nell'uguaglianza della tupla, ciò significa `(0, null) == (0, null)` che è consentito anche e i `null` valori letterali di tupla e non ottengono un tipo.</span><span class="sxs-lookup"><span data-stu-id="4547b-141">In tuple equality, this means, `(0, null) == (0, null)` is also allowed and the `null` and tuple literals don't get a type either.</span></span>

### <a name="comparing-a-nullable-struct-to-null-without-operator"></a><span data-ttu-id="4547b-142">Confronto tra uno struct nullable e `null` senza`operator==`</span><span class="sxs-lookup"><span data-stu-id="4547b-142">Comparing a nullable struct to `null` without `operator==`</span></span>

<span data-ttu-id="4547b-143">Si tratta di un altro caso speciale dei confronti regolari, che viene riportato ai confronti di Tuple.</span><span class="sxs-lookup"><span data-stu-id="4547b-143">This is another special case from regular comparisons, that carries over to tuple comparisons.</span></span>
<span data-ttu-id="4547b-144">Se si dispone di un oggetto `struct S` senza `operator==` , il `(S?)x == null` confronto è consentito e viene interpretato come `((S?).x).HasValue` .</span><span class="sxs-lookup"><span data-stu-id="4547b-144">If you have a `struct S` without `operator==`, the `(S?)x == null` comparison is allowed, and it is interpreted as `((S?).x).HasValue`.</span></span>
<span data-ttu-id="4547b-145">Nell'uguaglianza della tupla viene applicata la stessa regola, pertanto `(0, (S?)x) == (0, null)` è consentita.</span><span class="sxs-lookup"><span data-stu-id="4547b-145">In tuple equality, the same rule is applied, so `(0, (S?)x) == (0, null)` is allowed.</span></span>

## <a name="compatibility"></a><span data-ttu-id="4547b-146">Compatibilità</span><span class="sxs-lookup"><span data-stu-id="4547b-146">Compatibility</span></span>

<span data-ttu-id="4547b-147">Se un utente ha scritto `ValueTuple` tipi propri con un'implementazione dell'operatore di confronto, sarebbe stato prelevato in precedenza dalla risoluzione dell'overload.</span><span class="sxs-lookup"><span data-stu-id="4547b-147">If someone wrote their own `ValueTuple` types with  an implementation of the comparison operator, it would have previously been picked up by overload resolution.</span></span> <span data-ttu-id="4547b-148">Tuttavia, poiché il nuovo caso di tupla precede la risoluzione dell'overload, questo caso verrà gestito con il confronto delle tuple invece di basarsi sul confronto definito dall'utente.</span><span class="sxs-lookup"><span data-stu-id="4547b-148">But since the new tuple case comes before overload resolution, we would handle this case with tuple comparison instead of relying on the user-defined comparison.</span></span>

----

<span data-ttu-id="4547b-149">Si riferisce agli [operatori relazionali e di test del tipo](../../spec/expressions.md#relational-and-type-testing-operators) che si riferiscono a [#190](https://github.com/dotnet/csharplang/issues/190)</span><span class="sxs-lookup"><span data-stu-id="4547b-149">Relates to [relational and type testing operators](../../spec/expressions.md#relational-and-type-testing-operators) Relates to [#190](https://github.com/dotnet/csharplang/issues/190)</span></span>
