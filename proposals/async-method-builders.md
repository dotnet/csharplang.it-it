---
ms.openlocfilehash: fd8159145e235fc7a26b304ef6adcbddb4c05e96
ms.sourcegitcommit: 4c8b0a1c815f6ed5f69e2bdff94da354b2908fed
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 11/05/2020
ms.locfileid: "93406341"
---
# <a name="per-method-asyncmethodbuilders"></a><span data-ttu-id="c7d44-101">Per-Method AsyncMethodBuilders</span><span class="sxs-lookup"><span data-stu-id="c7d44-101">Per-Method AsyncMethodBuilders</span></span>

* <span data-ttu-id="c7d44-102">[x] proposto</span><span class="sxs-lookup"><span data-stu-id="c7d44-102">[x] Proposed</span></span>
* <span data-ttu-id="c7d44-103">[] Prototipo: non avviato</span><span class="sxs-lookup"><span data-stu-id="c7d44-103">[ ] Prototype: Not Started</span></span>
* <span data-ttu-id="c7d44-104">[] Implementazione: non avviata</span><span class="sxs-lookup"><span data-stu-id="c7d44-104">[ ] Implementation: Not Started</span></span>
* <span data-ttu-id="c7d44-105">[] Specifica: non avviata</span><span class="sxs-lookup"><span data-stu-id="c7d44-105">[ ] Specification: Not Started</span></span>

## <a name="summary"></a><span data-ttu-id="c7d44-106">Riepilogo</span><span class="sxs-lookup"><span data-stu-id="c7d44-106">Summary</span></span>
[summary]: #summary

<span data-ttu-id="c7d44-107">Estendere il generatore di metodi asincroni esistente per supportare l'attribuzione per metodo oltre al supporto per il tipo per restituito esistente.</span><span class="sxs-lookup"><span data-stu-id="c7d44-107">Extend the existing async method builder to support attribution per-method in addition to the existing per-return type support.</span></span>

## <a name="motivation"></a><span data-ttu-id="c7d44-108">Motivazione</span><span class="sxs-lookup"><span data-stu-id="c7d44-108">Motivation</span></span>
[motivation]: #motivation

<span data-ttu-id="c7d44-109">Attualmente, i generatori di metodi asincroni sono collegati a un tipo specificato usato come tipo restituito di un metodo asincrono.</span><span class="sxs-lookup"><span data-stu-id="c7d44-109">Today, async method builders are tied to a given type used as a return type of an async method.</span></span>  <span data-ttu-id="c7d44-110">Ad esempio, qualsiasi metodo dichiarato come `async Task` utilizza `AsyncTaskMethodBuilder` e qualsiasi metodo dichiarato come `async ValueTask<T>` utilizza `AsyncValueTaskMethodBuilder<T>` .</span><span class="sxs-lookup"><span data-stu-id="c7d44-110">For example, any method that's declared as `async Task` uses `AsyncTaskMethodBuilder`, and any method that's declared as `async ValueTask<T>` uses `AsyncValueTaskMethodBuilder<T>`.</span></span>  <span data-ttu-id="c7d44-111">Questo è dovuto all' `[AsyncMethodBuilder(Type)]` attributo del tipo utilizzato come tipo restituito, ad esempio, `ValueTask<T>` è attribuito come `[AsyncMethodBuilder(typeof(AsyncValueTaskMethodBuilder<>))]` .</span><span class="sxs-lookup"><span data-stu-id="c7d44-111">This is due to the `[AsyncMethodBuilder(Type)]` attribute on the type used as a return type, e.g. `ValueTask<T>` is attributed as `[AsyncMethodBuilder(typeof(AsyncValueTaskMethodBuilder<>))]`.</span></span> <span data-ttu-id="c7d44-112">Questo risolve la maggior parte dei casi comuni, ma lascia alcuni buchi rilevanti per gli scenari avanzati.</span><span class="sxs-lookup"><span data-stu-id="c7d44-112">This addresses the majority common case, but it leaves a few notable holes for advanced scenarios.</span></span>

<span data-ttu-id="c7d44-113">In .NET 5 è stata fornita una funzionalità sperimentale che fornisce due modalità in cui `AsyncValueTaskMethodBuilder` e `AsyncValueTaskMethodBuilder<T>` operano.</span><span class="sxs-lookup"><span data-stu-id="c7d44-113">In .NET 5, an experimental feature was shipped that provides two modes in which `AsyncValueTaskMethodBuilder` and `AsyncValueTaskMethodBuilder<T>` operate.</span></span>  <span data-ttu-id="c7d44-114">La modalità attiva per impostazione predefinita è identica a quella in cui è stata introdotta la funzionalità: quando la macchina a stati deve essere sollevata nell'heap, viene allocato un oggetto per archiviare lo stato e il metodo asincrono restituisce un oggetto `ValueTask{<T>}` supportato da `Task{<T>}` .</span><span class="sxs-lookup"><span data-stu-id="c7d44-114">The on-by-default mode is the same as has been there since the functionality was introduced: when the state machine needs to be lifted to the heap, an object is allocated to store the state, and the async method returns a `ValueTask{<T>}` backed by a `Task{<T>}`.</span></span>  <span data-ttu-id="c7d44-115">Tuttavia, se viene impostata una variabile di ambiente, tutti i generatori del processo passano a una modalità in cui, invece, le `ValueTask{<T>}` istanze sono supportate dalle implementazioni riutilizzabili in `IValueTaskSource{<T>}` pool.</span><span class="sxs-lookup"><span data-stu-id="c7d44-115">However, if an environment variable is set, all builders in the process switch to a mode where, instead, the `ValueTask{<T>}` instances are backed by reusable `IValueTaskSource{<T>}` implementations that are pooled.</span></span>  <span data-ttu-id="c7d44-116">Ogni metodo asincrono dispone di un proprio pool con un numero massimo fisso di istanze consentite per il pool e, a condizione che non venga mai restituito un numero maggiore di tale numero al pool, in modo che venga ripreso in pool contemporaneamente, i `async ValueTask<{T}>` metodi diventano senza alcun sovraccarico di allocazione GC.</span><span class="sxs-lookup"><span data-stu-id="c7d44-116">Each async method has its own pool with a fixed maximum number of instances allowed to be pooled, and as long as no more than that number are ever returned to the pool to be pooled at the same time, `async ValueTask<{T}>` methods effectively become free of any GC allocation overhead.</span></span>

<span data-ttu-id="c7d44-117">Esistono diversi problemi con questa modalità sperimentale, tuttavia, che è il motivo per cui è disattivata per impostazione predefinita e b) è probabile che venga rimossa in una versione futura, a meno che non siano presenti nuove informazioni molto interessanti ( https://github.com/dotnet/runtime/issues/13633) .</span><span class="sxs-lookup"><span data-stu-id="c7d44-117">There are several problems with this experimental mode, however, which is both why a) it's off by default and b) we're likely to remove it in a future release unless very compelling new information emerges (https://github.com/dotnet/runtime/issues/13633).</span></span>  
- <span data-ttu-id="c7d44-118">Introduce una differenza comportamentale per i consumer dell'oggetto restituito `ValueTask{<T>}` se `ValueTask` non viene utilizzato in base alla specifica.  Quando è supportato da `Task` , è possibile eseguire le `ValueTask` operazioni con un `Task` , ad esempio await it più volte, await it simultaneamente, blocca in attesa del completamento e così via.  Tuttavia, quando è supportato da un arbitrario `IValueTaskSource` , queste operazioni non sono consentite e il cambio automatico dal primo al secondo può causare bug.</span><span class="sxs-lookup"><span data-stu-id="c7d44-118">It introduces a behavioral difference for consumers of the returned `ValueTask{<T>}` if that `ValueTask` isn't being consumed according to spec.  When it's backed by a `Task`, you can do with the `ValueTask` things you can do with a `Task`, like await it multiple times, await it concurrently, block waiting for it to complete, etc.  But when it's backed by an arbitrary `IValueTaskSource`, such operations are prohibited, and automatically switching from the former to the latter can lead to bugs.</span></span>  <span data-ttu-id="c7d44-119">Con l'opzione a livello di processo e che interessano tutti i `async ValueTask` metodi del processo, indipendentemente dal fatto che vengano controllate o meno, il martello è troppo grande.</span><span class="sxs-lookup"><span data-stu-id="c7d44-119">With the switch at the process level and affecting all `async ValueTask` methods in the process, whether you control them or not, it's too big a hammer.</span></span>
- <span data-ttu-id="c7d44-120">Non è necessariamente una vittoria sulle prestazioni e può rappresentare una regressione in alcune situazioni.</span><span class="sxs-lookup"><span data-stu-id="c7d44-120">It's not necessarily a performance win, and could represent a regression in some situations.</span></span>  <span data-ttu-id="c7d44-121">L'implementazione sta commerciando il costo del pool (l'accesso a un pool non è gratuito) con il costo di GC e in varie situazioni il GC può vincere.</span><span class="sxs-lookup"><span data-stu-id="c7d44-121">The implementation is trading the cost of pooling (accessing a pool isn't free) with the cost of GC, and in various situations the GC can win.</span></span>  <span data-ttu-id="c7d44-122">Anche in questo caso, l'applicazione del pool a tutti i `async ValueTask` metodi del processo, anziché essere selettiva rispetto a quelli che trarrebbero maggiore vantaggio, è troppo grande.</span><span class="sxs-lookup"><span data-stu-id="c7d44-122">Again, applying the pooling to all `async ValueTask` methods in the process rather than being selective about the ones it would most benefit is too big a hammer.</span></span>
- <span data-ttu-id="c7d44-123">Aggiunge alla dimensione IL di un'applicazione tagliata, anche se il flag non è impostato, quindi alla dimensione ASM risultante.</span><span class="sxs-lookup"><span data-stu-id="c7d44-123">It adds to the IL size of a trimmed application, even if the flag isn't set, and then to the resulting asm size.</span></span>  <span data-ttu-id="c7d44-124">È possibile che sia possibile aggirare i miglioramenti apportati all'implementazione per indicare che per una distribuzione specifica la variabile di ambiente sarà sempre falsa, ma, come attualmente, ogni `async ValueTask` metodo ha visto, ad esempio, un aumento del footprint binario di ~ 2K nelle immagini AOT a causa di questa opzione, e, ancora una volta, che si applica a tutti i `async ValueTask` metodi nell'intera chiusura dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="c7d44-124">It's possible that can be worked around with improvements to the implementation to teach it that for a given deployment the environment variable will always be false, but as it stands today, every `async ValueTask` method saw for example an ~2K binary footprint increase in aot images due to this option, and, again, that applies to all `async ValueTask` methods in the whole application closure.</span></span>
- <span data-ttu-id="c7d44-125">Metodi diversi possono trarre vantaggio da diversi livelli di controllo, ad esempio le dimensioni del pool utilizzate a causa della conoscenza del metodo e della relativa modalità di utilizzo, ma la stessa impostazione viene applicata a tutti gli utilizzi del generatore.</span><span class="sxs-lookup"><span data-stu-id="c7d44-125">Different methods may benefit from differing levels of control, e.g. the size of the pool employed because of knowledge of the method and how it's used, but the same setting is applied to all uses of the builder.</span></span>  <span data-ttu-id="c7d44-126">Si può immaginare di aggirare il problema, in modo che il codice del generatore usi la reflection in fase di esecuzione per cercare un attributo, ma che aggiunga spese di run-time significative e probabilmente nel percorso di avvio.</span><span class="sxs-lookup"><span data-stu-id="c7d44-126">One could imagine working around that by having the builder code use reflection at runtime to look for some attribute, but that adds significant run-time expense, and likely on the startup path.</span></span>

<span data-ttu-id="c7d44-127">Oltre a tutti questi problemi con il pool esistente, è anche possibile impedire agli sviluppatori di scrivere i propri generatori personalizzati per i tipi di cui non sono proprietari.</span><span class="sxs-lookup"><span data-stu-id="c7d44-127">On top of all of these issues with the existing pooling, it's also the case that developers are prevented from writing their own customized builders for types they don't own.</span></span>  <span data-ttu-id="c7d44-128">Se, ad esempio, uno sviluppatore desidera implementare il proprio supporto per la creazione di pool, deve presentare anche un nuovo tipo simile a un'attività, anziché semplicemente poter utilizzare `{Value}Task{<T>}` , perché l'attributo che specifica il generatore è solo specificabile nella dichiarazione di tipo del tipo restituito.</span><span class="sxs-lookup"><span data-stu-id="c7d44-128">If, for example, a developer wants to implement their own pooling support, they also have to introduce a brand new task-like type, rather than just being able to use `{Value}Task{<T>}`, because the attribute specifying the builder is only specifiable on the type declaration of the return type.</span></span>

<span data-ttu-id="c7d44-129">È necessario un modo per consentire a un singolo metodo asincrono di acconsentire esplicitamente a un generatore specifico.</span><span class="sxs-lookup"><span data-stu-id="c7d44-129">We need a way to have an individual async method opt-in to a specific builder.</span></span>

## <a name="detailed-design"></a><span data-ttu-id="c7d44-130">Progettazione dettagliata</span><span class="sxs-lookup"><span data-stu-id="c7d44-130">Detailed design</span></span>
[design]: #detailed-design

#### <a name="p0-asyncmethodbuilderattribute-applicable-to-methods"></a><span data-ttu-id="c7d44-131">P0: AsyncMethodBuilderAttribute applicabile ai metodi</span><span class="sxs-lookup"><span data-stu-id="c7d44-131">P0: AsyncMethodBuilderAttribute applicable to methods</span></span>

<span data-ttu-id="c7d44-132">In DotNet/Runtime modificare `AsyncMethodBuilderAttribute` AttributeUsage da:</span><span class="sxs-lookup"><span data-stu-id="c7d44-132">In dotnet/runtime, change `AsyncMethodBuilderAttribute`'s AttributeUsage from:</span></span>
```C#
AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface | AttributeTargets.Delegate | AttributeTargets.Enum
```
<span data-ttu-id="c7d44-133">per includere anche il metodo:</span><span class="sxs-lookup"><span data-stu-id="c7d44-133">to also include Method:</span></span>
```C#
AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface | AttributeTargets.Delegate | AttributeTargets.Enum | AttributeTargets.Method
```
<span data-ttu-id="c7d44-134">in modo che possa essere applicato anche ai metodi.</span><span class="sxs-lookup"><span data-stu-id="c7d44-134">so that it may be applied to methods as well.</span></span>  <span data-ttu-id="c7d44-135">In alternativa, introdurre un nuovo attributo specifico dei metodi, se questo è ritenuto migliore per qualche motivo.</span><span class="sxs-lookup"><span data-stu-id="c7d44-135">(Alternatively, introduce a new attribute specific to methods, if that's deemed better for some reason.)</span></span>

<span data-ttu-id="c7d44-136">Nel compilatore C# preferiscono l'attributo nel metodo quando si determina il generatore da usare rispetto a quello definito nel tipo.</span><span class="sxs-lookup"><span data-stu-id="c7d44-136">In the C# compiler, prefer the attribute on the method when determining what builder to use over the one defined on the type.</span></span>  <span data-ttu-id="c7d44-137">Ad esempio, oggi se un metodo viene definito come:</span><span class="sxs-lookup"><span data-stu-id="c7d44-137">For example, today if a method is defined as:</span></span>
```C#
public async ValueTask<T> ExampleAsync() { ... }
```
<span data-ttu-id="c7d44-138">il compilatore genererà codice analogo al seguente:</span><span class="sxs-lookup"><span data-stu-id="c7d44-138">the compiler will generate code akin to:</span></span>
```C#
[AsyncStateMachine(typeof(<ExampleAsync>d__29))]
[CompilerGenerated]
static ValueTask<int> ExampleAsync()
{
    <ExampleAsync>d__29 stateMachine;
    stateMachine.<>t__builder = AsyncValueTaskMethodBuilder<int>.Create();
    stateMachine.<>1__state = -1;
    stateMachine.<>t__builder.Start(ref stateMachine);
    return stateMachine.<>t__builder.Task;
}
```
<span data-ttu-id="c7d44-139">Con questa modifica, se lo sviluppatore ha scritto:</span><span class="sxs-lookup"><span data-stu-id="c7d44-139">With this change, if the developer wrote:</span></span>
```C#
[AsyncMethodBuilder(typeof(PoolingAsyncValueTaskMethodBuilder<int>))] // new, referring to some custom builder type
static async ValueTask<int> ExampleAsync() { ... }
```
<span data-ttu-id="c7d44-140">verrebbe invece compilato in:</span><span class="sxs-lookup"><span data-stu-id="c7d44-140">it would instead be compiled to:</span></span>
```C#
[AsyncStateMachine(typeof(<ExampleAsync>d__29))]
[CompilerGenerated]
[AsyncMethodBuilder(typeof(PoolingAsyncValueTaskMethodBuilder<int>))] // retained but not necessary anymore
static ValueTask<int> ExampleAsync()
{
    <ExampleAsync>d__29 stateMachine;
    stateMachine.<>t__builder = PoolingAsyncValueTaskMethodBuilder<int>.Create(); // <>t__builder now a different type
    stateMachine.<>1__state = -1;
    stateMachine.<>t__builder.Start(ref stateMachine);
    return stateMachine.<>t__builder.Task;
}
```

<span data-ttu-id="c7d44-141">Solo le piccole aggiunte consentono:</span><span class="sxs-lookup"><span data-stu-id="c7d44-141">Just those small additions enable:</span></span>
- <span data-ttu-id="c7d44-142">Chiunque scriva il proprio generatore che può essere applicato a metodi asincroni che restituiscono `Task{T}` e `ValueTask{<T>}`</span><span class="sxs-lookup"><span data-stu-id="c7d44-142">Anyone to write their own builder that can be applied to async methods that return `Task{T}` and `ValueTask{<T>}`</span></span>
- <span data-ttu-id="c7d44-143">Come "chiunque", il runtime per fornire il supporto del generatore sperimentale come nuovi tipi di generatore pubblici che possono essere scelti in base al metodo; il supporto esistente verrebbe rimosso dai generatori esistenti.</span><span class="sxs-lookup"><span data-stu-id="c7d44-143">As "anyone", the runtime to ship the experimental builder support as new public builder types that can be opted into on a method-by-method basis; the existing support would be removed from the existing builders.</span></span>  <span data-ttu-id="c7d44-144">I metodi, inclusi quelli che si occupano delle librerie principali, possono quindi essere attribuiti a caso per caso per usare il supporto del pool, senza alcun effetto su altri metodi non attribuiti.</span><span class="sxs-lookup"><span data-stu-id="c7d44-144">Methods (including some we care about in the core libraries) can then be attributed on a case-by-case basis to use the pooling support, without impacting any other unattributed methods.</span></span>

<span data-ttu-id="c7d44-145">e con modifiche minime alla superficie di attacco o funzioni nel compilatore.</span><span class="sxs-lookup"><span data-stu-id="c7d44-145">and with minimal surface area changes or feature work in the compiler.</span></span>

#### <a name="p1-asyncmethodbuilderattribute-arguments-forward-to-create"></a><span data-ttu-id="c7d44-146">P1: AsyncMethodBuilderAttribute argomenti in futuro da creare</span><span class="sxs-lookup"><span data-stu-id="c7d44-146">P1: AsyncMethodBuilderAttribute arguments forward to Create</span></span>

<span data-ttu-id="c7d44-147">All'attributo viene assegnato un costruttore aggiuntivo:</span><span class="sxs-lookup"><span data-stu-id="c7d44-147">The attribute would be given an additional constructor:</span></span>
```C#
public AsyncMethodBuilderAttribute(Type builderType, params object[] createArguments);
```
<span data-ttu-id="c7d44-148">Se vengono specificati argomenti di questo tipo, il compilatore si aspetta che il generatore disponga di un `Create` metodo che può essere associato a tali argomenti, ad esempio se uno sviluppatore USA:</span><span class="sxs-lookup"><span data-stu-id="c7d44-148">If any such arguments are specified, the compiler would expect the builder to have a `Create` method that could bind with those arguments, e.g. if a developer used:</span></span>
```C#
[AsyncMethodBuilder(typeof(PoolingAsyncValueTaskMethodBuilder<>), 16)]
```
<span data-ttu-id="c7d44-149">il compilatore consentirebbe la compilazione a causa `PoolingAsyncValueTaskMethodBuilder<>` dell'esposizione dell' `Create` Overload seguente:</span><span class="sxs-lookup"><span data-stu-id="c7d44-149">the compiler would allow compilation due to `PoolingAsyncValueTaskMethodBuilder<>` exposing the following `Create` overload:</span></span>
```
public static PoolingAsyncValueTaskMethodBuilder<T> Create(int poolCapacity);
```
<span data-ttu-id="c7d44-150">e utilizzerebbe tale `Create` Overload invece di un senza parametri `Create` che altrimenti sarebbe previsto e utilizzerebbe, ad esempio:</span><span class="sxs-lookup"><span data-stu-id="c7d44-150">and would use that `Create` overload instead of a parameterless `Create` that it would otherwise expect and use, e.g. this:</span></span>
```C#
[AsyncMethodBuilder(typeof(PoolingAsyncValueTaskMethodBuilder<>), 16)]
static async ValueTask<int> ExampleAsync() { ... }
```
<span data-ttu-id="c7d44-151">verrà compilato in:</span><span class="sxs-lookup"><span data-stu-id="c7d44-151">would be compiled to:</span></span>
```C#
[AsyncStateMachine(typeof(<ExampleAsync>d__29))]
[CompilerGenerated]
[AsyncMethodBuilder(typeof(PoolingAsyncValueTaskMethodBuilder<>), 16)]
static ValueTask<int> ExampleAsync()
{
    <ExampleAsync>d__29 stateMachine;
    stateMachine.<>t__builder = PoolingAsyncValueTaskMethodBuilder<int>.Create(16); // attr arguments passed to Create
    stateMachine.<>1__state = -1;
    stateMachine.<>t__builder.Start(ref stateMachine);
    return stateMachine.<>t__builder.Task;
}
```
<span data-ttu-id="c7d44-152">Tale supporto potrebbe consentire ai generatori personalizzati di essere parametrizzati per ogni sito di chiamata, senza richiedere al generatore di eseguire una reflection complessa e costosa.</span><span class="sxs-lookup"><span data-stu-id="c7d44-152">Such support would enable custom builders to be parameterized per call site, without requiring the builder to perform complicated and expensive reflection.</span></span>

#### <a name="p2-enable-at-the-module-and-type-level-as-well"></a><span data-ttu-id="c7d44-153">P2: abilitare anche a livello di modulo (e digitare?)</span><span class="sxs-lookup"><span data-stu-id="c7d44-153">P2: Enable at the module (and type?) level as well</span></span>

<span data-ttu-id="c7d44-154">Uno sviluppatore che desidera utilizzare un generatore personalizzato specifico per tutti i relativi metodi può eseguire questa operazione inserendo l'attributo pertinente per ogni metodo.</span><span class="sxs-lookup"><span data-stu-id="c7d44-154">A developer that wants to using a specific custom builder for all of their methods can do so by putting the relevant attribute on each method.</span></span>  <span data-ttu-id="c7d44-155">Tuttavia, è anche possibile consentire l'attribuzione a livello di modulo o di tipo, nel qual caso ogni metodo pertinente all'interno di tale ambito si comporterebbe come se fosse annotato direttamente, ad esempio</span><span class="sxs-lookup"><span data-stu-id="c7d44-155">But we could also enable attributing at the module or type level, in which case every relevant method within that scope would behave as if it were directly annotated, e.g.</span></span>
```C#
[module: PoolingAsyncValueTaskMethodBuilder]
[module: PoolingAsyncValueTaskMethodBuilder<>]

class MyClass
{
    public async ValueTask Method1Async() { ... } // would use PoolingAsyncValueTaskMethodBuilder
    public async ValueTask<int> Method2Async() { ... } // would use PoolingAsyncValueTaskMethodBuilder<int>
    public async ValueTask<string> Method3Async() { ... } // would use PoolingAsyncValueTaskMethodBuilder<string>
}
```

<span data-ttu-id="c7d44-156">Questa operazione non solo renderebbe più semplice l'inserimento dell'attributo su ogni metodo, ma renderebbe più semplice l'utilizzo di compilazioni diverse che usavano diversi generatori.</span><span class="sxs-lookup"><span data-stu-id="c7d44-156">This would not only make it more convenient than putting the attribute on every method, it would also make it easier to employ different builds that used different builders.</span></span>  <span data-ttu-id="c7d44-157">Una compilazione ottimizzata per la velocità effettiva potrebbe includere, ad esempio, un file con estensione cs che specifica un generatore di pool in un attributo a livello di modulo, mentre una compilazione ottimizzata per le dimensioni potrebbe includere un file con estensione cs che specifica un generatore minimalista che sceglie di usare più allocazione/conversione boxing anziché numerose ottimizzazioni della velocità effettiva e della specializzazione del codice.</span><span class="sxs-lookup"><span data-stu-id="c7d44-157">For example, a build optimized for throughput might include a .cs file that specifies a pooling builder in a module-level attribute, whereas a build optimized for size might a include a .cs file that specifies a minimalistic builder that opts to use more allocation/boxing instead of lots of generic specialization and throughput optimizations that lead to code bloat.</span></span>


## <a name="drawbacks"></a><span data-ttu-id="c7d44-158">Svantaggi</span><span class="sxs-lookup"><span data-stu-id="c7d44-158">Drawbacks</span></span>
[drawbacks]: #drawbacks

* <span data-ttu-id="c7d44-159">La sintassi per l'applicazione di tale attributo a un metodo è Verbose.</span><span class="sxs-lookup"><span data-stu-id="c7d44-159">The syntax for applying such an attribute to a method is verbose.</span></span>  <span data-ttu-id="c7d44-160">Si tratta di una funzionalità avanzata, ma uno sviluppatore che lo usa spesso potrebbe creare un proprio attributo derivato da quello che interessa e quindi usare tale attributo derivato per semplificare, ad esempio</span><span class="sxs-lookup"><span data-stu-id="c7d44-160">This is an advanced feature, but a developer using it frequently could create their own attribute derived from the one they care about, and then use that derived attribute to simplify, e.g.</span></span>
```C#
class Pool<T> : AsyncMethodBuilderAttribute<T>
{
    public Pool() : base(typeof(AsyncValueTaskMethodBuilder<T>)) { }
}
...
[Pool]
internal async ValueTask<int> ExampleAsync() { ... }
```
<span data-ttu-id="c7d44-161">Tuttavia, non so esattamente come questa operazione può essere eseguita con il supporto createArguments.</span><span class="sxs-lookup"><span data-stu-id="c7d44-161">I don't know exactly how this could be made to work with the createArguments support, though.</span></span>  <span data-ttu-id="c7d44-162">L'attributo derivato può anche accettare una matrice params e passarla alla base, ma il compilatore deve essere in grado di riconoscerlo.</span><span class="sxs-lookup"><span data-stu-id="c7d44-162">The derived attribute could also accept a params array and pass it down to the base, but the compiler would need to be able to recognize it.</span></span>  <span data-ttu-id="c7d44-163">Forse un approccio euristico di un oggetto params speciale [] alla fine di un attributo derivato da AsyncMethodBuilder.</span><span class="sxs-lookup"><span data-stu-id="c7d44-163">Maybe a heuristic of special-casing any params object[] at the end of an AsyncMethodBuilder-derived attribute.</span></span>

## <a name="alternatives"></a><span data-ttu-id="c7d44-164">Alternativi</span><span class="sxs-lookup"><span data-stu-id="c7d44-164">Alternatives</span></span>
[alternatives]: #alternatives

- <span data-ttu-id="c7d44-165">Implementare un tipo diverso per l'attività e esporre la differenza ai consumer.</span><span class="sxs-lookup"><span data-stu-id="c7d44-165">Implement a different task-like type and expose that difference to consumers.</span></span>  <span data-ttu-id="c7d44-166">`ValueTask` è stata resa estendibile tramite l' `IValueTaskSource` interfaccia per evitare tale necessità.</span><span class="sxs-lookup"><span data-stu-id="c7d44-166">`ValueTask` was made extensible via the `IValueTaskSource` interface to avoid that need, however.</span></span>
- <span data-ttu-id="c7d44-167">Risolvere solo la parte del problema relativa al pool di ValueTask, abilitando l'esperimento come implementazione on-by-default-only.</span><span class="sxs-lookup"><span data-stu-id="c7d44-167">Address just the ValueTask pooling part of the issue by enabling the experiment as the on-by-default-and-only implementation.</span></span>  <span data-ttu-id="c7d44-168">Questo non risolve altri aspetti, ad esempio la configurazione del pool, o l'abilitazione di un altro utente a fornire il proprio generatore.</span><span class="sxs-lookup"><span data-stu-id="c7d44-168">That doesn't address other aspects, such as configuring the pooling, or enabling someone else to provide their own builder.</span></span>

## <a name="unresolved-questions"></a><span data-ttu-id="c7d44-169">Domande non risolte</span><span class="sxs-lookup"><span data-stu-id="c7d44-169">Unresolved questions</span></span>
[unresolved]: #unresolved-questions

1. <span data-ttu-id="c7d44-170">**Attributo.**</span><span class="sxs-lookup"><span data-stu-id="c7d44-170">**Attribute.**</span></span> <span data-ttu-id="c7d44-171">È necessario riutilizzare `[AsyncMethodBuilder(typeof(...))]` o introdurre ancora un altro attributo?</span><span class="sxs-lookup"><span data-stu-id="c7d44-171">Should we reuse `[AsyncMethodBuilder(typeof(...))]` or introduce yet another attribute?</span></span>
2. <span data-ttu-id="c7d44-172">**Sostituire o creare anche.**</span><span class="sxs-lookup"><span data-stu-id="c7d44-172">**Replace or also create.**</span></span> <span data-ttu-id="c7d44-173">Tutti gli esempi di questa proposta sono relativi alla sostituzione di un generatore di tipo attività compilabile.</span><span class="sxs-lookup"><span data-stu-id="c7d44-173">All of the examples in this proposal are about replacing a buildable task-like's builder.</span></span>  <span data-ttu-id="c7d44-174">L'ambito della funzionalità dovrebbe essere sufficiente?</span><span class="sxs-lookup"><span data-stu-id="c7d44-174">Should the feature be scoped to just that?</span></span> <span data-ttu-id="c7d44-175">In alternativa, è possibile usare questo attributo in un metodo con un tipo restituito che non dispone già di un generatore (ad esempio, un'interfaccia comune)?</span><span class="sxs-lookup"><span data-stu-id="c7d44-175">Or should you be able to use this attribute on a method with a return type that doesn't already have a builder (e.g. some common interface)?</span></span>  <span data-ttu-id="c7d44-176">Che può influisca sulla risoluzione dell'overload.</span><span class="sxs-lookup"><span data-stu-id="c7d44-176">That could impact overload resolution.</span></span>
3. <span data-ttu-id="c7d44-177">**Virtuals/Interfaces.**</span><span class="sxs-lookup"><span data-stu-id="c7d44-177">**Virtuals / Interfaces.**</span></span> <span data-ttu-id="c7d44-178">Qual è il comportamento se l'attributo viene specificato in un metodo di interfaccia?</span><span class="sxs-lookup"><span data-stu-id="c7d44-178">What is the behavior if the attribute is specified on an interface method?</span></span>  <span data-ttu-id="c7d44-179">Credo che debba essere un NOP o un avviso o un errore del compilatore, ma non dovrebbe influisca sulle implementazioni dell'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="c7d44-179">I think it should either be a nop or a compiler warning/error, but it shouldn't impact implementations of the interface.</span></span>  <span data-ttu-id="c7d44-180">Esiste una domanda simile per i metodi di base sottoposti a override e di nuovo non credo che l'attributo nel metodo di base debba influisca sul comportamento di un'implementazione di override.</span><span class="sxs-lookup"><span data-stu-id="c7d44-180">A similar question exists for base methods that are overridden, and there again I don't think the attribute on the base method should impact how an override implementation behaves.</span></span> <span data-ttu-id="c7d44-181">Si noti che l'attributo corrente ha ereditato = false sul relativo AttributeUsage.</span><span class="sxs-lookup"><span data-stu-id="c7d44-181">Note the current attribute has Inherited = false on its AttributeUsage.</span></span>
4. <span data-ttu-id="c7d44-182">**Precedenza.**</span><span class="sxs-lookup"><span data-stu-id="c7d44-182">**Precedence.**</span></span> <span data-ttu-id="c7d44-183">Se si vuole eseguire l'annotazione a livello di modulo o di tipo, è necessario decidere quale sia l'attribuzione vincente nel caso in cui siano state applicate più, ad esempio una sul metodo, una sul modulo contenitore.</span><span class="sxs-lookup"><span data-stu-id="c7d44-183">If we wanted to do the module/type-level annotation, we would need to decide on which attribution wins in the case where multiple ones applied (e.g. one on the method, one on the containing module).</span></span>  <span data-ttu-id="c7d44-184">È anche necessario determinare se questa operazione richiederebbe l'uso di un attributo diverso (vedere (1) sopra), ad esempio quale sarebbe il comportamento se un tipo simile a un'attività era nello stesso ambito?</span><span class="sxs-lookup"><span data-stu-id="c7d44-184">We would also need to determine if this would necessitate using a different attribute (see (1) above), e.g. what would the behavior be if a task-like type was in the same scope?</span></span>  <span data-ttu-id="c7d44-185">In alternativa, se un'attività compilabile, ad esempio, aveva metodi asincroni su di essa, verrebbe influenzato dall'attributo applicato al tipo simile a un'attività per specificare il generatore predefinito?</span><span class="sxs-lookup"><span data-stu-id="c7d44-185">Or if a buildable task-like itself had async methods on it, would they be influenced by the attributed applied to the task-like type to specify its default builder?</span></span>
5. <span data-ttu-id="c7d44-186">**Generatori privati**.</span><span class="sxs-lookup"><span data-stu-id="c7d44-186">**Private Builders**.</span></span> <span data-ttu-id="c7d44-187">Il compilatore deve supportare i generatori di metodi asincroni non pubblici?</span><span class="sxs-lookup"><span data-stu-id="c7d44-187">Should the compiler support non-public async method builders?</span></span> <span data-ttu-id="c7d44-188">Questa non è una specifica di oggi, ma sperimentale sono supportate solo quelle pubbliche.</span><span class="sxs-lookup"><span data-stu-id="c7d44-188">This is not spec'd today, but experimentally we only support public ones.</span></span>  <span data-ttu-id="c7d44-189">Questo ha senso quando l'attributo viene applicato a un tipo per controllare quale generatore viene usato con quel tipo, perché chiunque scriva un metodo asincrono con quel tipo come tipo restituito dovrebbe avere accesso al generatore.</span><span class="sxs-lookup"><span data-stu-id="c7d44-189">That makes some sense when the attribute is applied to a type to control what builder is used with that type, since anyone writing an async method with that type as the return type would need access to the builder.</span></span>  <span data-ttu-id="c7d44-190">Tuttavia, con questa nuova funzionalità, quando l'attributo viene applicato a un metodo, influisca solo sull'implementazione di tale metodo e pertanto può fare ragionevolmente riferimento a un generatore non pubblico.</span><span class="sxs-lookup"><span data-stu-id="c7d44-190">However, with this new feature, when that attribute is applied to a method, it only impacts the implementation of that method, and thus could reasonably reference a non-public builder.</span></span>  <span data-ttu-id="c7d44-191">È probabile che si desideri supportare gli autori di librerie con quelli non pubblici che vogliono usare.</span><span class="sxs-lookup"><span data-stu-id="c7d44-191">Likely we will want to support library authors who have non-public ones they want to use.</span></span>

## <a name="design-meetings"></a><span data-ttu-id="c7d44-192">Riunioni di progettazione</span><span class="sxs-lookup"><span data-stu-id="c7d44-192">Design meetings</span></span>

<span data-ttu-id="c7d44-193">Collegamento alle note sulla progettazione che interessano questa proposta e descrivono in una frase per ogni modifica apportata.</span><span class="sxs-lookup"><span data-stu-id="c7d44-193">Link to design notes that affect this proposal, and describe in one sentence for each what changes they led to.</span></span>