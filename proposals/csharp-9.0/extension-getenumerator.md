---
ms.openlocfilehash: a774e370a14373ccf308c2cba9944305c0053c05
ms.sourcegitcommit: c3df20406f43fcd460cfedd1cd61b6cc47d27250
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/08/2020
ms.locfileid: "89557578"
---
# <a name="extension-getenumerator-support-for-foreach-loops"></a><span data-ttu-id="02c3d-101">`GetEnumerator`Supporto dell'estensione per i `foreach` cicli.</span><span class="sxs-lookup"><span data-stu-id="02c3d-101">Extension `GetEnumerator` support for `foreach` loops.</span></span>

## <a name="summary"></a><span data-ttu-id="02c3d-102">Riepilogo</span><span class="sxs-lookup"><span data-stu-id="02c3d-102">Summary</span></span>
[summary]: #summary

<span data-ttu-id="02c3d-103">Consentire ai cicli foreach di riconoscere un metodo di estensione GetEnumerator che altrimenti soddisfa il modello foreach ed eseguire il ciclo sull'espressione quando sarebbe altrimenti un errore.</span><span class="sxs-lookup"><span data-stu-id="02c3d-103">Allow foreach loops to recognize an extension method GetEnumerator method that otherwise satisfies the foreach pattern, and loop over the expression when it would otherwise be an error.</span></span>

## <a name="motivation"></a><span data-ttu-id="02c3d-104">Motivazione</span><span class="sxs-lookup"><span data-stu-id="02c3d-104">Motivation</span></span>
[motivation]: #motivation

<span data-ttu-id="02c3d-105">In questo modo, foreach inline verrà implementato come altre funzionalità in C#, tra cui la decostruzione asincrona e basata su modelli.</span><span class="sxs-lookup"><span data-stu-id="02c3d-105">This will bring foreach inline with how other features in C# are implemented, including async and pattern-based deconstruction.</span></span>

## <a name="detailed-design"></a><span data-ttu-id="02c3d-106">Progettazione dettagliata</span><span class="sxs-lookup"><span data-stu-id="02c3d-106">Detailed design</span></span>
[design]: #detailed-design

<span data-ttu-id="02c3d-107">La modifica delle specifiche è relativamente semplice.</span><span class="sxs-lookup"><span data-stu-id="02c3d-107">The spec change is relatively straightforward.</span></span> <span data-ttu-id="02c3d-108">`The foreach statement`La sezione viene modificata in questo testo:</span><span class="sxs-lookup"><span data-stu-id="02c3d-108">We modify `The foreach statement` section to this text:</span></span>

><span data-ttu-id="02c3d-109">L'elaborazione in fase di compilazione di un'istruzione foreach determina innanzitutto il tipo di ***raccolta***, il tipo di ***enumeratore*** e il ***tipo di elemento*** dell'espressione.</span><span class="sxs-lookup"><span data-stu-id="02c3d-109">The compile-time processing of a foreach statement first determines the ***collection type***, ***enumerator type*** and ***element type*** of the expression.</span></span> <span data-ttu-id="02c3d-110">Questa determinazione procede come segue:</span><span class="sxs-lookup"><span data-stu-id="02c3d-110">This determination proceeds as follows:</span></span>
>
>*  <span data-ttu-id="02c3d-111">Se il tipo `X` di *espressione* è un tipo di matrice, esiste una conversione implicita del riferimento da `X` all' `IEnumerable` interfaccia (poiché `System.Array` implementa questa interfaccia).</span><span class="sxs-lookup"><span data-stu-id="02c3d-111">If the type `X` of *expression* is an array type then there is an implicit reference conversion from `X` to the `IEnumerable` interface (since `System.Array` implements this interface).</span></span> <span data-ttu-id="02c3d-112">Il ***tipo di raccolta*** è l' `IEnumerable` interfaccia, il ***tipo di enumeratore*** è l' `IEnumerator` interfaccia e il tipo di ***elemento*** è il tipo di elemento del tipo di matrice `X` .</span><span class="sxs-lookup"><span data-stu-id="02c3d-112">The ***collection type*** is the `IEnumerable` interface, the ***enumerator type*** is the `IEnumerator` interface and the ***element type*** is the element type of the array type `X`.</span></span>
>*  <span data-ttu-id="02c3d-113">Se il tipo `X` di *espressione* è, `dynamic` esiste una conversione implicita dall' *espressione* all' `IEnumerable` interfaccia ([conversioni dinamiche implicite](conversions.md#implicit-dynamic-conversions)).</span><span class="sxs-lookup"><span data-stu-id="02c3d-113">If the type `X` of *expression* is `dynamic` then there is an implicit conversion from *expression* to the `IEnumerable` interface ([Implicit dynamic conversions](conversions.md#implicit-dynamic-conversions)).</span></span> <span data-ttu-id="02c3d-114">Il ***tipo di raccolta*** è l' `IEnumerable` interfaccia e il ***tipo di enumeratore*** è l' `IEnumerator` interfaccia.</span><span class="sxs-lookup"><span data-stu-id="02c3d-114">The ***collection type*** is the `IEnumerable` interface and the ***enumerator type*** is the `IEnumerator` interface.</span></span> <span data-ttu-id="02c3d-115">Se l' `var` identificatore viene fornito come *local_variable_type* , il ***tipo di elemento*** è; `dynamic` in caso contrario, è `object` .</span><span class="sxs-lookup"><span data-stu-id="02c3d-115">If the `var` identifier is given as the *local_variable_type* then the ***element type*** is `dynamic`, otherwise it is `object`.</span></span>
>*  <span data-ttu-id="02c3d-116">In caso contrario, determinare se il tipo `X` dispone di un `GetEnumerator` metodo appropriato:</span><span class="sxs-lookup"><span data-stu-id="02c3d-116">Otherwise, determine whether the type `X` has an appropriate `GetEnumerator` method:</span></span>
>    * <span data-ttu-id="02c3d-117">Eseguire la ricerca di membri sul tipo `X` con identificatore `GetEnumerator` e nessun argomento di tipo.</span><span class="sxs-lookup"><span data-stu-id="02c3d-117">Perform member lookup on the type `X` with identifier `GetEnumerator` and no type arguments.</span></span> <span data-ttu-id="02c3d-118">Se la ricerca dei membri non produce una corrispondenza o produce un'ambiguità o produce una corrispondenza che non è un gruppo di metodi, verificare la presenza di un'interfaccia enumerabile come descritto di seguito.</span><span class="sxs-lookup"><span data-stu-id="02c3d-118">If the member lookup does not produce a match, or it produces an ambiguity, or produces a match that is not a method group, check for an enumerable interface as described below.</span></span> <span data-ttu-id="02c3d-119">Si consiglia di emettere un avviso se la ricerca di membri produce qualsiasi elemento tranne un gruppo di metodi o nessuna corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="02c3d-119">It is recommended that a warning be issued if member lookup produces anything except a method group or no match.</span></span>
>    * <span data-ttu-id="02c3d-120">Eseguire la risoluzione dell'overload usando il gruppo di metodi risultante e un elenco di argomenti vuoto.</span><span class="sxs-lookup"><span data-stu-id="02c3d-120">Perform overload resolution using the resulting method group and an empty argument list.</span></span> <span data-ttu-id="02c3d-121">Se la risoluzione dell'overload non produce metodi applicabili, comporta un'ambiguità o produce un unico metodo migliore, ma tale metodo è statico o non pubblico, verificare la presenza di un'interfaccia enumerabile come descritto di seguito.</span><span class="sxs-lookup"><span data-stu-id="02c3d-121">If overload resolution results in no applicable methods, results in an ambiguity, or results in a single best method but that method is either static or not public, check for an enumerable interface as described below.</span></span> <span data-ttu-id="02c3d-122">Si consiglia di emettere un avviso se la risoluzione dell'overload produce qualsiasi elemento tranne un metodo di istanza pubblica non ambiguo o senza metodi applicabili.</span><span class="sxs-lookup"><span data-stu-id="02c3d-122">It is recommended that a warning be issued if overload resolution produces anything except an unambiguous public instance method or no applicable methods.</span></span>
>    * <span data-ttu-id="02c3d-123">Se il tipo restituito `E` del `GetEnumerator` metodo non è una classe, uno struct o un tipo di interfaccia, viene generato un errore e non vengono eseguiti altri passaggi.</span><span class="sxs-lookup"><span data-stu-id="02c3d-123">If the return type `E` of the `GetEnumerator` method is not a class, struct or interface type, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="02c3d-124">La ricerca del membro viene eseguita `E` con l'identificatore `Current` e nessun argomento di tipo.</span><span class="sxs-lookup"><span data-stu-id="02c3d-124">Member lookup is performed on `E` with the identifier `Current` and no type arguments.</span></span> <span data-ttu-id="02c3d-125">Se la ricerca dei membri non produce corrispondenze, il risultato è un errore o il risultato è qualsiasi eccezione, ad eccezione di una proprietà di istanza pubblica che consente la lettura, viene generato un errore e non vengono eseguiti altri passaggi.</span><span class="sxs-lookup"><span data-stu-id="02c3d-125">If the member lookup produces no match, the result is an error, or the result is anything except a public instance property that permits reading, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="02c3d-126">La ricerca del membro viene eseguita `E` con l'identificatore `MoveNext` e nessun argomento di tipo.</span><span class="sxs-lookup"><span data-stu-id="02c3d-126">Member lookup is performed on `E` with the identifier `MoveNext` and no type arguments.</span></span> <span data-ttu-id="02c3d-127">Se la ricerca dei membri non produce corrispondenze, il risultato è un errore o il risultato è qualsiasi eccezione a un gruppo di metodi, viene generato un errore e non vengono eseguiti altri passaggi.</span><span class="sxs-lookup"><span data-stu-id="02c3d-127">If the member lookup produces no match, the result is an error, or the result is anything except a method group, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="02c3d-128">La risoluzione dell'overload viene eseguita sul gruppo di metodi con un elenco di argomenti vuoto.</span><span class="sxs-lookup"><span data-stu-id="02c3d-128">Overload resolution is performed on the method group with an empty argument list.</span></span> <span data-ttu-id="02c3d-129">Se la risoluzione dell'overload non produce metodi applicabili, comporta un'ambiguità o produce un unico metodo migliore, ma tale metodo è statico o non pubblico oppure il tipo restituito non lo è `bool` , viene generato un errore e non vengono eseguiti altri passaggi.</span><span class="sxs-lookup"><span data-stu-id="02c3d-129">If overload resolution results in no applicable methods, results in an ambiguity, or results in a single best method but that method is either static or not public, or its return type is not `bool`, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="02c3d-130">Il ***tipo di raccolta*** è `X` , il ***tipo di enumeratore*** è `E` e il tipo di ***elemento*** è il tipo della `Current` Proprietà.</span><span class="sxs-lookup"><span data-stu-id="02c3d-130">The ***collection type*** is `X`, the ***enumerator type*** is `E`, and the ***element type*** is the type of the `Current` property.</span></span>
>
>*  <span data-ttu-id="02c3d-131">In caso contrario, verificare la presenza di un'interfaccia enumerabile:</span><span class="sxs-lookup"><span data-stu-id="02c3d-131">Otherwise, check for an enumerable interface:</span></span>
>    * <span data-ttu-id="02c3d-132">Se tra tutti i tipi `Ti` per i quali esiste una conversione implicita da `X` a `IEnumerable<Ti>` , esiste un tipo univoco `T` che `T` non è `dynamic` e per tutti gli altri `Ti` esiste una conversione implicita da `IEnumerable<T>` a `IEnumerable<Ti>` , quindi il tipo di ***raccolta*** è l'interfaccia `IEnumerable<T>` , il ***tipo di enumeratore*** è l'interfaccia `IEnumerator<T>` e il ***tipo di elemento*** è `T` .</span><span class="sxs-lookup"><span data-stu-id="02c3d-132">If among all the types `Ti` for which there is an implicit conversion from `X` to `IEnumerable<Ti>`, there is a unique type `T` such that `T` is not `dynamic` and for all the other `Ti` there is an implicit conversion from `IEnumerable<T>` to `IEnumerable<Ti>`, then the ***collection type*** is the interface `IEnumerable<T>`, the ***enumerator type*** is the interface `IEnumerator<T>`, and the ***element type*** is `T`.</span></span>
>    * <span data-ttu-id="02c3d-133">In caso contrario, se è presente più di un tipo di questo tipo `T` , viene generato un errore e non vengono eseguiti altri passaggi.</span><span class="sxs-lookup"><span data-stu-id="02c3d-133">Otherwise, if there is more than one such type `T`, then an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="02c3d-134">In caso contrario, se esiste una conversione implicita da `X` all' `System.Collections.IEnumerable` interfaccia, il ***tipo di raccolta*** è questa interfaccia, il ***tipo di enumeratore*** è l'interfaccia `System.Collections.IEnumerator` e il ***tipo di elemento*** è `object` .</span><span class="sxs-lookup"><span data-stu-id="02c3d-134">Otherwise, if there is an implicit conversion from `X` to the `System.Collections.IEnumerable` interface, then the ***collection type*** is this interface, the ***enumerator type*** is the interface `System.Collections.IEnumerator`, and the ***element type*** is `object`.</span></span>
>*  <span data-ttu-id="02c3d-135">In caso contrario, determinare se il tipo ' X ' ha un `GetEnumerator` metodo di estensione appropriato:</span><span class="sxs-lookup"><span data-stu-id="02c3d-135">Otherwise, determine whether the type 'X' has an appropriate `GetEnumerator` extension method:</span></span>
>    * <span data-ttu-id="02c3d-136">Eseguire la ricerca del metodo di estensione sul tipo `X` con l'identificatore `GetEnumerator` .</span><span class="sxs-lookup"><span data-stu-id="02c3d-136">Perform extension method lookup on the type `X` with identifier `GetEnumerator`.</span></span> <span data-ttu-id="02c3d-137">Se la ricerca dei membri non produce una corrispondenza o produce un'ambiguità o produce una corrispondenza che non è un gruppo di metodi, viene generato un errore e non vengono eseguiti altri passaggi.</span><span class="sxs-lookup"><span data-stu-id="02c3d-137">If the member lookup does not produce a match, or it produces an ambiguity, or produces a match which is not a method group, an error is produced and no further steps are taken.</span></span> <span data-ttu-id="02c3d-138">Si consiglia di generare un avviso se la ricerca dei membri produce qualsiasi elemento tranne un gruppo di metodi o nessuna corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="02c3d-138">It is recommended that a warning be issues if member lookup produces anything except a method group or no match.</span></span>
>    * <span data-ttu-id="02c3d-139">Eseguire la risoluzione dell'overload usando il gruppo di metodi risultante e un singolo argomento di tipo `X` .</span><span class="sxs-lookup"><span data-stu-id="02c3d-139">Perform overload resolution using the resulting method group and a single argument of type `X`.</span></span> <span data-ttu-id="02c3d-140">Se la risoluzione dell'overload non produce metodi applicabili, genera un'ambiguità o genera un solo metodo migliore, ma tale metodo non è accessibile, viene generato un errore senza ulteriori passaggi.</span><span class="sxs-lookup"><span data-stu-id="02c3d-140">If overload resolution produces no applicable methods, results in an ambiguity, or results in a single best method but that method is not accessible, an error is produced an no further steps are taken.</span></span>
>        * <span data-ttu-id="02c3d-141">Questa risoluzione consente il passaggio del primo argomento tramite Ref se `X` è un tipo struct e il tipo di riferimento è `in` .</span><span class="sxs-lookup"><span data-stu-id="02c3d-141">This resolution permits the first argument to be passed by ref if `X` is a struct type, and the ref kind is `in`.</span></span>
>    * <span data-ttu-id="02c3d-142">Se il tipo restituito `E` del `GetEnumerator` metodo non è una classe, uno struct o un tipo di interfaccia, viene generato un errore e non vengono eseguiti altri passaggi.</span><span class="sxs-lookup"><span data-stu-id="02c3d-142">If the return type `E` of the `GetEnumerator` method is not a class, struct or interface type, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="02c3d-143">La ricerca del membro viene eseguita `E` con l'identificatore `Current` e nessun argomento di tipo.</span><span class="sxs-lookup"><span data-stu-id="02c3d-143">Member lookup is performed on `E` with the identifier `Current` and no type arguments.</span></span> <span data-ttu-id="02c3d-144">Se la ricerca dei membri non produce corrispondenze, il risultato è un errore o il risultato è qualsiasi eccezione, ad eccezione di una proprietà di istanza pubblica che consente la lettura, viene generato un errore e non vengono eseguiti altri passaggi.</span><span class="sxs-lookup"><span data-stu-id="02c3d-144">If the member lookup produces no match, the result is an error, or the result is anything except a public instance property that permits reading, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="02c3d-145">La ricerca del membro viene eseguita `E` con l'identificatore `MoveNext` e nessun argomento di tipo.</span><span class="sxs-lookup"><span data-stu-id="02c3d-145">Member lookup is performed on `E` with the identifier `MoveNext` and no type arguments.</span></span> <span data-ttu-id="02c3d-146">Se la ricerca dei membri non produce corrispondenze, il risultato è un errore o il risultato è qualsiasi eccezione a un gruppo di metodi, viene generato un errore e non vengono eseguiti altri passaggi.</span><span class="sxs-lookup"><span data-stu-id="02c3d-146">If the member lookup produces no match, the result is an error, or the result is anything except a method group, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="02c3d-147">La risoluzione dell'overload viene eseguita sul gruppo di metodi con un elenco di argomenti vuoto.</span><span class="sxs-lookup"><span data-stu-id="02c3d-147">Overload resolution is performed on the method group with an empty argument list.</span></span> <span data-ttu-id="02c3d-148">Se la risoluzione dell'overload non produce metodi applicabili, comporta un'ambiguità o produce un unico metodo migliore, ma tale metodo è statico o non pubblico oppure il tipo restituito non lo è `bool` , viene generato un errore e non vengono eseguiti altri passaggi.</span><span class="sxs-lookup"><span data-stu-id="02c3d-148">If overload resolution results in no applicable methods, results in an ambiguity, or results in a single best method but that method is either static or not public, or its return type is not `bool`, an error is produced and no further steps are taken.</span></span>
>    * <span data-ttu-id="02c3d-149">Il ***tipo di raccolta*** è `X` , il ***tipo di enumeratore*** è `E` e il tipo di ***elemento*** è il tipo della `Current` Proprietà.</span><span class="sxs-lookup"><span data-stu-id="02c3d-149">The ***collection type*** is `X`, the ***enumerator type*** is `E`, and the ***element type*** is the type of the `Current` property.</span></span>
>*  <span data-ttu-id="02c3d-150">In caso contrario, viene generato un errore e non vengono eseguiti altri passaggi.</span><span class="sxs-lookup"><span data-stu-id="02c3d-150">Otherwise, an error is produced and no further steps are taken.</span></span>

<span data-ttu-id="02c3d-151">Per `await foreach` , le regole vengono modificate in modo analogo.</span><span class="sxs-lookup"><span data-stu-id="02c3d-151">For `await foreach`, the rules are similarly modified.</span></span> <span data-ttu-id="02c3d-152">L'unica modifica necessaria a tale specifica è la rimozione della `Extension methods do not contribute.` riga dalla descrizione, poiché il resto di tale specifica è basato sulle regole precedenti con nomi diversi sostituiti dai metodi di pattern.</span><span class="sxs-lookup"><span data-stu-id="02c3d-152">The only change that is required to that spec is removing the `Extension methods do not contribute.` line from the description, as the rest of that spec is based on the above rules with different names substituted for the pattern methods.</span></span>

## <a name="drawbacks"></a><span data-ttu-id="02c3d-153">Svantaggi</span><span class="sxs-lookup"><span data-stu-id="02c3d-153">Drawbacks</span></span>
[drawbacks]: #drawbacks

<span data-ttu-id="02c3d-154">Ogni modifica aggiunge ulteriore complessità al linguaggio e questo potenzialmente consente a elementi che non sono stati progettati per essere `foreach` ed `foreach` , ad esempio `Range` .</span><span class="sxs-lookup"><span data-stu-id="02c3d-154">Every change adds additional complexity to the language, and this potentially allows things that weren't designed to be `foreach`ed to be `foreach`ed, like `Range`.</span></span>

## <a name="alternatives"></a><span data-ttu-id="02c3d-155">Alternativi</span><span class="sxs-lookup"><span data-stu-id="02c3d-155">Alternatives</span></span>
[alternatives]: #alternatives

<span data-ttu-id="02c3d-156">Non eseguire alcuna operazione.</span><span class="sxs-lookup"><span data-stu-id="02c3d-156">Doing nothing.</span></span>

## <a name="unresolved-questions"></a><span data-ttu-id="02c3d-157">Domande non risolte</span><span class="sxs-lookup"><span data-stu-id="02c3d-157">Unresolved questions</span></span>
[unresolved]: #unresolved-questions

<span data-ttu-id="02c3d-158">Nessuno a questo punto.</span><span class="sxs-lookup"><span data-stu-id="02c3d-158">None at this point.</span></span>
